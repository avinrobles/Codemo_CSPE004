python_solutions,label
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
         left = 0
         right = len(nums)
         while left < right:
             if target-nums[left] in nums and nums.index(target-nums[left]) != left:
                 return [left,nums.index(target-nums[left])]
             else:
                 left+=1",1
"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        i, j = 0, 0
        n = len(s)
        frequencyArray = [0]*(5 * 10**4)
        maxSize = 0
        while j < n:
            frequencyArray[ord(s[j]) - ord('a')] += 1
            mapSize = (5*10**4) - frequencyArray.count(0)
            
            if mapSize == j - i + 1:
                maxSize = max(maxSize, j - i + 1)
                j += 1
            
            elif mapSize < j - i + 1:
                while mapSize < j - i + 1:
                    frequencyArray[ord(s[i]) - ord('a')] -= 1
                    mapSize = (5*10**4) - frequencyArray.count(0)
                    i += 1
                j += 1
        return maxSize",0
"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        sum_list = nums1 + nums2
        sum_list.sort()
        sum_size = len(sum_list)

        if sum_size % 2 == 0:
            x = (sum_list[int(sum_size/2)] + sum_list[int((sum_size/2) - 1)]) / 2
        else:
            x = sum_list[int(sum_size/2)]

        return x",1
"class Solution:
    def longestPalindrome(self, s: str) -> str:
        self.res = """";
        self.resLen = 0;
        for i in range(len(s)):
            self.getPalindrome(s,i,i);
            self.getPalindrome(s,i,i+1);
        return self.res;
    def getPalindrome(self,s,l,r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            if (r - l + 1) > self.resLen:
                self.res = s[l:r+1];
                self.resLen = len(self.res);
            l -= 1;
            r += 1;",0
"class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        a = ['' for i in range(numRows)]
        c = numRows
        inc = False
        for i in s:
            a[numRows-c] += i # If numRows = 3, the range of numRows-c is [0, 2] as c is in the range of [1, 3]
            if not inc:
                c -= 1
                if c == 1:
                    inc = True
            else:
                c += 1
                if c == numRows:
                    inc = False
        return ''.join(a)",0
"class Solution:
    def reverse(self, x: int) -> int:
        reverse = 0
        num, x = x, abs(x)
        while x:
            last = x % 10
            x //= 10
            reverse = reverse * 10 + last
            if not (reverse <= 2 ** 31 and reverse >= -2 ** 31):
                return 0
            
        return reverse if num > 0 else -reverse",1
"class Solution:
    def myAtoi(self, s: str) -> int:
        s= s.strip("" "")
        if len(s) == 0:return 0
        s = list(s)
        sign = 1
        
        if s[0] == ""-"":
            sign = -1
            s.pop(0) # Removing the sign from the first term 
        elif s[0] == ""+"":
            sign = 1
            s.pop(0)
        else:
            pass
        
        if len(s) > 2 and not s[0].isdigit():
            return 0
        _ = ""0""
        
        for i in s:
            if i.isdigit():
                _+=i
            else:
                break
                
        return_val = int(_) * sign
        
        if return_val < -2147483648:
            return -2147483648
        
        elif return_val > 2147483647:
            return 2147483647
        
        else:
            return return_val",1
"class Solution:
    def isPalindrome(self, x: int) -> bool:
        y = list(str(x))
        return y== list(reversed(y))",1
"class Solution:
    @lru_cache
    def isMatch(self, s, p):
        if not p:   return not s
        if p[-1] == '*':
            return (self.isMatch(s, p[:-2])) or (s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p))
        return s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1])",0
"class Solution:
    def maxArea(self, height: List[int]) -> int:
        """"""Uses two pointers. 
        Left pointer starts with 0th index and
        Right pointer starts at last index.
        Calculate the area and update if greater than
        area variable.
        If heigh[right] is greater than heigh[left], increment
        left, otherwise decrement right.
        """"""
        area = 0
        left = 0
        right = len(height) -1
        while left < right:
            side = min(height[left], height[right])
            width = right - left
            area = max(side * width, area)
            if height[right] > height[left]:
                left += 1
            else:
                right -= 1
        return area",1
"class Solution:
    def intToRoman(self, num: int) -> str:
        """"""
        Symbol       Value
        I             1     ones
        V             5     ones
        X             10    tens
        L             50    tens
        C             100   hundreds
        D             500   hundreds
        M             1000  thousands
        """"""
        # mode the number to get digits
        # based on the digits, append the letter to the ans
        # reverse the ans or use dequeue()
        letters = [[""I"", ""IV"", ""V"", ""IX""],
                  [""X"", ""XL"", ""L"", ""XC""],
                  [""C"", ""CD"", ""D"", ""CM""],
                  [""M"","""","""",""""]]
        place = 0 # value place. 0-> ones, 1->tens
        ans = deque()
        while num > 0:
            digit = num % 10            
            num //= 10
            lt = letters[place]
            if digit < 4:
                ans.appendleft(lt[0]*digit)
            elif digit == 4:
                ans.appendleft(lt[1])
            elif digit < 9:
                ans.appendleft(lt[2]+lt[0]*(digit-5))      
            elif digit == 9:
                ans.appendleft(lt[3])
            place += 1
        return """".join(ans)",0
"class Solution:
    def romanToInt(self, s: str) -> int:
        dic={""I"":1, ""V"":5, ""X"":10, ""L"":50, ""C"":100, ""D"":500, ""M"":1000 }
        m,total=dic[s[0]],0
        for i in s:
            n=dic[i]
            total = (total- 2*m + n) if(m<n) else (total+ n)
            m=n
        return total",0
"class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        result = """"
        
        strs.sort()
        
		# Loop over the characters in the first index of the array
        for char in range(len(strs[0])):
		
			#If the character is the same in both the first and last string at the same index, append to result and continue with the loop.
            if strs[0][char] == strs[-1][char]:
                result += strs[0][char]
                continue
            else:
				# Break out of the loop here.  Personally, I find this this easier to read, could also just return the result.
                break
                
        return result",1
"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        levels = []
        
        def order(node, level):
            if level >= len(levels):
                levels.append([])
            
            if node:
                levels[level].append(node.val)
            
                if node.left:
                    order(node.left, level + 1)
                
                if node.right:
                    order(node.right, level + 1)
        
        if not root:
            return []
        
        order(root, 0)
        return levels",1
"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return root
        q = [root]
        level = []
        res = [[root.val]]
        x = 0
        while q and root:
            for node in q:
                if node.left:
                    level.append(node.left)
                if node.right:
                    level.append(node.right)
            temp = []
            for i in level:
                temp.append(i.val)
            x += 1
            if temp:
                if x % 2 != 0:
                    res.append(temp[::-1])
                else:
                    res.append(temp)
            q = level
            level = []
        return res",1
"class Solution:

    def maxDepth(self, root: Optional[TreeNode]):
        queue = []
        height = 0
        if not root:
            return 0
        queue.append(root)

        while queue:
            current_length = len(queue)
            height += 1
            for _ in range(0, current_length):
                popped_elem = queue.pop(0)
                if popped_elem.left:
                    queue.append(popped_elem.left)
                if popped_elem.right:
                    queue.append(popped_elem.right)

        return height",1
"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def buildTree(preorder, inorder):
            if inorder:
                root = TreeNode(preorder.pop(0))
                root_index = inorder.index(root.val)
                root.left = buildTree(preorder,inorder[:root_index])
                root.right = buildTree(preorder,inorder[root_index+1:])
                return root
        return buildTree(preorder, inorder)",0
"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        m = {}
        for i in range(len(inorder)):
            m[inorder[i]] = i
            
        def helper(in_l, in_r, inorder, po_l, po_r, postorder):
            if po_l >= po_r:
                return TreeNode(postorder[po_r])
            curr = TreeNode(postorder[po_r])
            idx = m[postorder[po_r]]
            num_right_tree = in_r - idx
            num_left_tree = idx - in_l
            if num_right_tree > 0:
                curr.right = helper(idx+1, in_r, inorder, po_r-num_right_tree, po_r-1, postorder)
            if num_left_tree > 0:
                curr.left = helper(in_l, idx-1, inorder, po_l, po_l+num_left_tree-1, postorder)
            return curr
        
        return helper(0, len(inorder)-1, inorder, 0, len(postorder)-1, postorder)",0
"class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if root is None: return
        queue = deque([root])
        op = []
        while queue:
            level = []
            for i in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            op.append(level)
        return op[::-1]",1
"class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:

        def recur(start, end):
            if end < start:
                return None
            mid = floor((start+end)/2)
            node = TreeNode(nums[mid])
            node.left = recur(start, mid-1)
            node.right = recur(mid+1, end)
            return node
        
        return recur(0, len(nums)-1)",1
"class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        if not head or not head.next:
            return TreeNode(head.val) if head else None
			
        slow, fast = head, head.next
        while fast.next and fast.next.next:
            slow, fast = slow.next, fast.next.next
        fast, slow.next = slow.next, None
		
        node = TreeNode(fast.val)
        node.left = self.sortedListToBST(head)
        node.right = self.sortedListToBST(fast.next)
        return node",1
"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        
        if not root:
            return True
        
        def recur(node, level):
            if not node:
                return level-1
            left = recur(node.left, level+1)
            right = recur(node.right, level+1)
            if not left or not right:
                return 0
            if abs(left-right) > 1:
                return 0
            return max(left, right)
        
        level = recur(root, 1)
        
        if not level:
            return False
        return True",1
"class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        import queue
        if not root:
            return 0

        q = queue.Queue()
        q.put((1, root))
        while not q.empty():
            level, node = q.get()
            if not node.left and not node.right:
                return level
            
            if node.left:
                q.put((level+1, node.left))
                
            if node.right:
                q.put((level+1, node.right))",1
"class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        f = False
        def util(root, c):
            nonlocal f
            if root:
                c += root.val
                util(root.left, c)
                util(root.right, c)
                if not root.left and not root.right and c == targetSum:
                    f= True
        util(root, 0)
        return f",1
"class Solution:
    def solve(self, root, S , curr , res):
        if(not root):
            return
        curr.append(root.val)
        
        
        if(root.val == S and not root.left and not root.right):
            res.append(list(curr))
            #remeber that when append lisi of list convert into a list
        self.solve(root.left, S - root.val , curr , res)
        
        self.solve(root.right, S - root.val , curr , res)
        
        #del curr[-1]
        curr.pop()
        
        
        
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        curr = []
        self.solve(root , targetSum , curr , res)
        return res",1
"class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """"""
        Do not return anything, modify root in-place instead.
        """"""
        if not root:
            return None
        
        # left is the last node of the left subtree.
        # and similarly right is the last node of the right subtree
        left = self.flatten(root.left)
        right = self.flatten(root.right)
        
        if left:
            # First, we join the last node of left subtree to first node in right subtree
            # Then we move the left subtree to the right of the node, and delete the left subtree pointer
            left.right = root.right
            root.right = root.left
            root.left = None
        
        # if theres a right subtree, we return its last node, failing which the last node of the left subtree,
		# and if none are present (i.e. its a leaf node), we return the node itself.
        return right or left or root",1
"class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [[0 for i in range(m + 1)] for i in range(n + 1)]
        
        for i in range(0, m + 1):
            dp[i][0] = 1
        for i in range(1,m + 1):
            for j in range(1,n + 1):
                dp[i][j] += dp[i - 1][j] + (dp[i - 1][j - 1] if s[i - 1] == t[j - 1] else 0)
        return dp[m][n]",0
"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if root == None:
            return None
        q = collections.deque([root])
        while len(q) > 0:
            size = len(q)
            prev = None
            for _ in range(size):
                node = q.popleft()
                if prev:
                    prev.next = node
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                prev = node
            prev.next = None
        return root",1
"class Solution(object):
    def generate(self, numRows):
        """"""
        :type numRows: int
        :rtype: List[List[int]]
        """"""
        response = [[1]*i for i in range(1, numRows+1)]
        
        for i in range(2, numRows):
            for j in range(1,i):
                response[i][j] = response[i-1][j] + response[i-1][j-1]
                
        return response",1
"class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        l=[[1]*(i+1) for i in range(rowIndex+1)]
        
        if(rowIndex==0):
            l[0]=[1]
        
        else:
            l[0]=[1]
            l[1]=[1,1]
        
            for i in range(2,len(l)):
                for j in range(0,len(l[i])):
                    if(j==0 or j==len(l[i])+1):
                        continue
                    else:
                        l[i][j]=sum(l[i-1][j-1:j+1])
        return l[-1]",1
"class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        dp = [[-1] * n for x in range(n)]
        
        for j in range(n):
            dp[n-1][j] = triangle[n-1][j]
        i = n-2
        while(i>=0):
            j = i
            while(j>=0):
                down = triangle[i][j] + dp[i+1][j]
                dia = triangle[i][j] + dp[i+1][j+1]
                dp[i][j] = min(down,dia)
                j -= 1
            i -= 1
        return dp[0][0]",1
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price, max_profit = math.inf, 0
        for p in prices:
            if p < min_price:
                min_price = p
            elif p-min_price > max_profit:
                max_profit = p-min_price
        return max_profit",1
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        @cache
        def trade(day_d):
            
            if day_d == 0:
                
                # Hold on day_#0 = buy stock at the price of day_#0
                # Not-hold on day_#0 = doing nothing on day_#0
                return -prices[day_d], 0
            
            prev_hold, prev_not_hold = trade(day_d-1)
            
            hold = max(prev_hold, prev_not_hold - prices[day_d] )
            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )
            
            return hold, not_hold
        
        # --------------------------------------------------
        last_day= len(prices)-1
        
        # Max profit must come from not_hold state (i.e., no stock position) on last day
        return trade(last_day)[1]",1
"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        @cache
        def dfs(i, hasBought, transactions):
            if (i >= len(prices) or transactions >= 2):
                return 0
            maxProfit = 0
            if (hasBought):
                maxProfit = prices[i] + dfs(i + 1, False, transactions + 1)
            else:
                maxProfit = -prices[i] + dfs(i + 1, True, transactions)     
            return max(maxProfit, dfs(i + 1, hasBought, transactions))
        return dfs(0, False, 0)",0
"class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        return self.maxPathSumHelper(root)[2]

    def maxPathSumHelper(self, root: TreeNode):
        """"""
            (alo, connected, sum)
        """"""
        if root == None:
            return (False, False, 0)
        
        (l_alo, l_connected, l_subtree) = self.maxPathSumHelper(root.left)
        (r_alo, r_connected, r_subtree) = self.maxPathSumHelper(root.right)
        
        max_sum = max( \
            (root.val + l_subtree + r_subtree) if r_connected and l_connected else root.val, \
            (root.val + l_subtree) if l_connected else root.val, \
            (root.val + r_subtree) if r_connected else root.val, \
            root.val
         )
        
        
        if (l_alo and l_subtree > max_sum) or (r_alo and r_subtree > max_sum):
            if l_alo and not r_alo:
                return (True, False, l_subtree)
            elif not l_alo and r_alo:
                return (True, False, r_subtree)
            else:
                return (True, False, max(l_subtree, r_subtree))
        else:",0
"class Solution:
    def isPalindrome(self, s: str) -> bool:
        Snew = """"
        for char in s:
            if char.isalnum():
                Snew += char.lower()
        return Snew == Snew[::-1]",1
"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        """"""
        cog
        + log
          + 
        + dog
        """"""
        def ppath(p):
            if d.get(p):
                path.append(p)
                if d[p][1]==-1:
                    print(path[::-1])
                    ans.append([v for v in path[::-1]])
                else:
                    for v in d:
                        if d[v][0]+1==d[p][0] and sum([1 for i in range(k) if v[i]!=p[i]])<=1:
                            ppath(v)
                path.pop(-1)
            pass
            
        n, k = len(wordList), len(wordList[0])
        
        # build tries
        tries = {}
        for i in range(n):
            for j in range(k):
                w = wordList[i][:j] + ""?"" + wordList[i][j+1:]
                tries[w] = tries.get(w, [])                
                tries[w].append(wordList[i])
            pass
        
        print(beginWord, endWord)
        print(""[build] tries: "", tries)
        
        # bfs (only closing node after 1-level)
        q = [beginWord]
        d = {q[0]: (0, -1)}
        flag = False
        while len(q)>0:
            u = q.pop(0)
            for j in range(k):
                w = u[:j] + ""?"" + u[j+1:]
                for v in tries.get(w, []): # for all v adjacent u
                    if not d.get(v):
                        d[v] = (d[u][0]+1, u)
                        q.append(v)
                    if v==endWord:
                        break
                if d.get(endWord):
                    break
            if d.get(endWord):
                    break
                        
        print(""\n[bfs] d: "", d)
        
        print(""\npath: "")
        
        path = []
        ans = []
        ppath(endWord)
        print(""="" * 20)
        return ans

print = lambda *a,**aa: ()",0
"class Solution:
    def ladderLength(self, beginWord: 'str', endWord: 'str', wordList: 'List[str]') -> 'int':
        wordSet = set(wordList)
        if endWord not in wordSet:
            return 0
        wordDict = {1:[beginWord]}
        output = 1
        while True:
            words = wordDict[output] 
            wordDict[output + 1] = []
            for word in words:
                for i in range(len(word)):
                    for j in string.ascii_lowercase:
                        wordChange = word[:i] + j + word[i+1:]
                        if wordChange == endWord:
                            return output + 1
                        if wordChange in wordSet:
                            wordDict[output+1].append(wordChange)
                            wordSet.remove(wordChange)
            if wordDict[output+1] == []:
                break
            output += 1
        return 0",0
"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        lengthLong=0
        prevMap = {}
        for i, n in enumerate(nums):
            prevMap[n]=i
        for i, n in enumerate(nums):
            count=1
            while n+1 in prevMap:
                count+=1
                n+=1
            lengthLong=max(lengthLong,count)
        return lengthLong",1
"class Solution:
def sumNumbers(self, root: Optional[TreeNode]) -> int:
    
    def path(root,local):
        nonlocal res
        if root is None:
            return 
        if root.left is None and root.right is None:
            res.append(local*10+root.val)
            return
        
        path(root.left,local*10+root.val)
        path(root.right,local*10+root.val)
    
    res = []
    path(root,0)
    return sum(res)",1
"class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                visited = set()
                if board[i][j]=='O':
                    bfs_arr = [(i,j)]
                    visited.add((i,j))
                    surrounded = True
                    while len(bfs_arr)>0:
                        curr = bfs_arr.pop()
                        if curr[0]==0 or curr[0]==m-1 or curr[1]==0 or curr[1]==n-1:
                            surrounded = False
                        
                        for shift in [(+1,0),(-1,0),(0,+1),(0,-1)]:
                            ind_i = curr[0]+shift[0]
                            ind_j = curr[1] + shift[1]                            
                            if ind_i>=0 and ind_i<m and ind_j>=0 and ind_j<n and board[ind_i][ind_j] == 'O' and (ind_i, ind_j) not in visited:
                                bfs_arr.append((ind_i,ind_j ))
                                visited.add((ind_i, ind_j))

                    for val in visited:
                        if surrounded:
                            board[val[0]][val[1]] = 'X'",0
"class Solution:
    def partition(self, s: str) -> List[List[str]]:
        part = [[] for _ in range(len(s))]
        def sub_part(l, r):
            if 0 <= l <= r < len(s) and s[l]==s[r]:
                part[l].append(s[l:r+1])
                sub_part(l-1, r+1)
                
		# find all palindromes
        for i in range(len(s)):
            sub_part(i,i)
            sub_part(i-1,i)
			
        # generate output
		res=[]
		
        def dfs(i, tmp):
            if i >=len(s):
                res.append(tmp)
			else:
				for p in part[i]:
					dfs(i + len(p), tmp + [p])        
        
		dfs(0, [])
        return res",1
"class Solution:
    def minCut(self, s: str) -> int:
        if len(s)<=1: return 0
        dp = []
        for x in range(-1,len(s)):
            dp.append(x)
        for i in range(len(s)):
            for j in range(i,len(s)):
                if s[i:j]==s[j:i:-1]:
                    dp[j+1]=min(dp[j+1],dp[i]+1)
        return dp[len(s)]
    
    def minCut1(self, s: str) -> int:
        if len(s)<=1: return 0
        self.memo=[None]*(len(s)+1)
        self.memo[0]=[[]]
        ps = self.partition(s)
        min_len=float(""inf"")
        for p in ps:
            min_len=min(min_len,len(p))
        return min_len - 1
    
    def partition(self,s):
        l = len(s)
        if self.memo[l]: return self.memo[l]
        result=[]
        for i in range(l-1,-1,-1):
            current=s[i:]
            if current==current[::-1]:
                prevs=self.partition(s[:i])
                for prev in prevs:
                    result+=[prev+[current]]
        self.memo[l]=result
        return result",0
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        
        return clone(node, {})

def clone(node, dict):
    if node not in dict:
        dict[node] = Node(node.val, [])
        for n in node.neighbors:
            dict[node].neighbors.append(clone(n, dict))
    return dict[node]",1
"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas)<sum(cost): return -1
        n=len(gas)
        minn=float('inf')  #Variable to track the largest cumulative gas deficit
        debt=0 #Variable indicating the gas deficit at each station
        for i in range(n):
            debt+=gas[i]-cost[i]
            if debt<minn:
                minn=debt
                index=i
        return index+1 if index <n-1 else 0 #return the station right after the one with the largest cumulative deficit",0
"class Solution:
    def candy(self, ratings: List[int]) -> int:
        '''
        1. According to solution 2, use two arrays initialized by n 1's where n is length of ratings array,
                - one to check whether ratings[i]<ratings[i+1] starting from the leftmost position, if so then in the array set the value of index (i+1) = 1 + the value of index i
                - other to check whether ratings[i+1]<ratings[i] starting from the rightmost position, if so then in the array set the value of index i = 1 + the value of index (i+1)
        2. If those two arrays are LeftToRight and RightToLeft respectively, then the result will be sum of all maximum(LeftToRight[i], RightToLeft[i]) for 0<=i<=n-1.
        '''
        
        res_1 = [1]*len(ratings)                                        #array for LeftToRight checking
        res_2 = [1]*len(ratings)                                        #array for RightToLeft checking
        res=0                                                           #initial value of minimum no. of candies
        
        #we can check whether ratings[0]<ratings[1] and ratings[n-1]<ratings[n-2] in the same iteration
        #in the following way we can change the values of index i of both LeftToRight array and RightToLeft array in single iteration
        for i in range(0,len(ratings)-1):
            if ratings[i+1]>ratings[i] and res_1[i+1]<=res_1[i]:               
                res_1[i+1]=res_1[i]+1
            if ratings[len(ratings)-1-i]<ratings[len(ratings)-1-i-1] and res_2[len(ratings)-1-i]>=res_2[len(ratings)-1-i]:
                res_2[len(ratings)-1-i-1]=res_2[len(ratings)-1-i]+1
            
        for i in range(0,len(ratings)):
            res+=max(res_1[i], res_2[i])                                        #getting the maximum of LeftToRight[i] and RightToLeft[i] and adding it to the minimum value
            
        return res",0
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
            return [x for x in nums if nums.count(x)==1][0]",0
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return (sum(set(nums))*3-sum(nums))//2",1
"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        def copyList(node):
            if not node:
                return node
            
            newNode = Node(node.val)
            newNodes[node] = newNode
            newNode.next = copyList(node.next)
            newNode.random = newNodes[node.random]
            
            return newNode
        
        newNodes = {None: None}
        return copyList(head)",1
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        t = [0 for _ in range(n)]
        for i in range(n):
            for j in range(i+1):
                word = s[j:i+1]
                if word in wordDict:
                    t[i] += t[j-1] if j > 0 else 1
        return t[n-1]",1
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        self.res = []
        
        def helper(s,dic,path):
            if not s:
                self.res.append(' '.join(path))
                return
            if s in dic:
                return
            for i in range(1,len(s)+1):
                if s[:i] in wd:
                    helper(s[i:],dic,path+[s[:i]])
                else:
                    dic.add(s[:i])
        wd = set(wordDict)  
        dic = set()
        helper(s,dic,[])
        return self.res",1
"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        # if linkedlist empty
        if not head:
            return False
        
        # fast, slow nodes
        fast = slow = head
        
        # counter for fast and slow
        cnt = 0
        
        # while before end of linkedlist
        while fast:
            # advance fast
            fast = fast.next

            # every other loop
            if cnt % 2:
                # advance slow
                slow = slow.next
            
            # if fast and slow point to the same node, we have a loop
            if fast is slow:
                return True
            
            # increment cnt
            cnt += 1
        
        return False",1
"class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        if not head or not head.next:
            return None
        
        s = set()
        
        while head:
            
            if head in s:
                return head
            
            s.add(head)
            head = head.next
            
        return head",1
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        curr = head
        lst_ref = []
        while curr:
            lst_ref.append(curr)
            curr = curr.next
        if len(lst_ref) <= 2:
            return
        half_len, rem = divmod(len(lst_ref), 2)
        if rem:
            for a, b in zip(lst_ref[:half_len:1],
                            lst_ref[len(lst_ref) - 1: half_len:-1]):
                a.next = b
            for a, b in zip(lst_ref[len(lst_ref) - 1: half_len + 1:-1],
                            lst_ref[1:half_len:1]):
                a.next = b
            lst_ref[half_len + 1].next = lst_ref[half_len]
        else:
            for a, b in zip(lst_ref[:half_len:1],
                            lst_ref[len(lst_ref) - 1: half_len - 1:-1]):
                a.next = b
            for a, b in zip(lst_ref[len(lst_ref) - 1: half_len:-1],
                            lst_ref[1:half_len:1]):
                a.next = b
        lst_ref[half_len].next = None",0
"class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
	    ans = []
	    stack = [root]

	    while stack:
		    node = stack.pop()
		    if node:
			    ans.append(node.val)
			    stack.append(node.right)
			    stack.append(node.left)
	    return ans",1
"class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if not root:
            return res
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
            pass
        dfs(root)
        return res",1
"class ListNode:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.next = None
        self.prev = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
		# a hashmap stores key to ListNode(key, value) pair
        self.map = dict()
        # dummy nodes to mitigate edge cases
        self.head = ListNode(0, 0)
        self.tail = ListNode(0, 0)
        # init the doubly linked list with [head<->tail]
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if (key in self.map):
            curr = self.map.get(key)
            self.removeX(curr)
            self.addX(curr)
            return curr.val
        return -1

    def put(self, key: int, value: int) -> None:
        if (key in self.map):
            self.removeX(self.map[key])
        
        self.map[key] = ListNode(key, value)
        self.addX(self.map[key])
            
        if (len(self.map) > self.capacity):
            # remove the first(LRU) element in the list
            n = self.head.next
            self.removeX(n)
            self.map.pop(n.key, None)              

        
    def addX(self, head):
        # set the current head pointer's prev to tail's prev pointer
        head.prev = self.tail.prev
        # set the current head pointer's next to tail pointer
        head.next = self.tail
        # set the tail pointer's old prev's next to the current head pointer
        self.tail.prev.next = head
        # set the tail pointer's old prev pointer to the new prev(head) pointer
        self.tail.prev = head
    
    def removeX(self, head):
        # set the old prev's next pointer to current head's next pointer
        head.prev.next = head.next
        # set old next's prev pointer to current head's prev pointer
        head.next.prev = head.prev",0
"class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        
        # No need to sort for empty list or list of size 1
        if not head or not head.next:
            return head
        
        nodes = []
        cur = head
        while head:
            nodes.append(head)
            head = head.next
            
        # Sort nodes by their values ascendingly
        nodes = sorted(nodes, key=lambda node: node.val)

        # Re-organize list
        cur = head = nodes[0]
        for node in nodes[1:]:
            cur.next = node
            cur = cur.next
        cur.next = None
            
        return head",1
"class Solution(object):
    def sortList(self, head):
        if not head or not head.next:
            return head
        fast, slow = head.next, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        start = slow.next
        slow.next = None
        l, r = self.sortList(head), self.sortList(start)
        return self.merge(l, r)
        
        
    def merge(self, l, r):
        if not l or not r:
            return l or r
        dummy = p = ListNode(0)
        while l and r:
            if l.val < r.val:
                p.next = l
                l = l.next
            else:
                p.next = r
                r = r.next
            p = p.next
        p.next = l or r
        return dummy.next",1
"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        def solve(p1, p2):
            if p2[0] == p1[0]:
                return math.inf, p1[0]
            m = (p2[1] - p1[1]) / (p2[0] - p1[0])
            b = p2[1] - m*p2[0]
            return m, b
        
        n = len(points)
        if n == 1:
            return 1
        lines = defaultdict(set)
        for i in range(n):
            for j in range(i+1, n):
                m, b = solve(points[i], points[j])
                lines[(m,b)].add(i)
                lines[(m,b)].add(j)
                
        return max([len(v) for v in lines.values()])",0
"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def calculate(num1, num2, operator):
            if operator=='+':
                return num1+num2
            if operator=='-':
                return num2-num1
            if operator=='*':
                return num1*num2
            if operator=='/':
                return int(num2/num1)
            return 0
        

        stack=[]
        for i in range(len(tokens)):
            if tokens[i] == '+' or tokens[i] == '-' or tokens[i] == '*' or tokens[i] == '/':
                num1=stack.pop()
                num2=stack.pop()
                stack.append(calculate(num1, num2, tokens[i]))
            else:
                stack.append(int(tokens[i]))
        return stack.pop()",0
"class Solution:
    def reverseWords(self, s: str) -> str:
        s=s.split()
        a=s[::-1]
        return(' '.join(a))",1
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        f = lambda x, y:  y if x == 0 else x * y 
        return max(max(accumulate(nums, f)), max(accumulate(nums[::-1], f)))",0
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        # Binary search
        lo = 0
        hi = len(nums) - 1
        global_min = inf
        while lo <= hi:
            mid = (lo + hi) // 2
            # Update minimum if needed
            global_min = min(nums[mid], global_min)
            # Case: if the pivot index is within the top half and the top half array is unsorted
            # e.g. [4,5,6,7|mid|8,0,1,2]
            if nums[mid] > nums[hi]:
                lo = mid + 1
            # Case: if the pivot index is within the top half but the top half of array is sorted
            # e.g. [5,6,7,8|mid|0,1,2,3]
            elif mid + 1 < len(nums) and nums[mid + 1] < nums[mid]:
                return nums[mid + 1]
            else:
                hi = mid - 1
        return global_min",0
"class Solution:
    def findMin(self, nums: List[int]) -> int:
        len_nums = len(nums)
        len_nums1, len_nums2 = len_nums - 1,  len_nums - 2
        for i in range(len_nums // 2):
            if nums[i] > nums[i + 1]:
                return nums[i + 1]
            if nums[len_nums2 - i] > nums[len_nums1 - i]:
                return nums[len_nums1 - i]
        return nums[0]",1
"class MinStack:

    def __init__(self):
        self.myStack = list()
        self.min = math.inf

    def push(self, val: int) -> None:
        self.myStack.append(val)
        if val < self.min:
            self.min = val

    def pop(self) -> None:
        if len(self.myStack) == 0:
            return
        self.myStack.pop()
        if len(self.myStack) == 0:
            self.min = math.inf
            return
        self.min = min(self.myStack)

    def top(self) -> int:
        if len(self.myStack) == 0:
            return
        return self.myStack[-1]

    def getMin(self) -> int:
        if len(self.myStack) == 0:
            return
        return self.min",1
"class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        Set=set()
        curr= headA
        while curr:
            Set.add(curr)
            curr=curr.next
        curr=headB
        while curr:
            if curr in Set:
                return curr
            curr=curr.next
        return None",1
"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        return nums.index(max(nums))",1
"class Solution:
    def maximumGap(self, num):
        if len(num) < 2:    return 0
        num.sort()
        return max(abs(n2 - n1) for n1, n2 in zip(num[1:], num[:-1]))",1
"class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = list(map(int, version1.split(""."")))
        v2 = list(map(int, version2.split(""."")))
        
        
        for i in range(max(len(v1),len(v2))):
            
            if i<len(v1):
                v1.append(0)
            if i<len(v2):
                v2.append(0)
            if v1[i] > v2[i]:
                return 1
            elif v1[i] < v2[i]:
                return -1
            
        return 0",1
"class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator*denominator<0:
            ans=""-""
        else:
            ans=""""
        q=abs(numerator)//abs(denominator)
        r=abs(numerator)%abs(denominator)
        d=set()
        decimal=[]
        if r==0:
            ans=ans+str(q)
            return ans
        else:
            flag=False
            while r!=0:
                if r not in d:
                    n=r*10
                    q1=n//abs(denominator)
                    d.add(r)
                    decimal.append((q1,r))
                    r=n%abs(denominator)
                else:
                    r1=r
                    flag=True
                    break
        ans+=str(q)+'.'
        if flag==False:
            for Q,R in decimal:
                ans+=str(Q)
        if flag==True:
            for i in range(0,len(decimal)):
                if decimal[i][1]!=r1:
                    ans+=str(decimal[i][0])
                else:
                    break
            ans+='('
            for x in range(i,len(decimal)):
                ans+=str(decimal[x][0])
            ans+=')'         
       return ans",0
"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # O(n), O(1)
        left = 0
        right = len(numbers) - 1

        while left < right:
            add = numbers[left] + numbers[right]
            if add == target:
                return [left + 1, right + 1]
            elif add > target:
                right -= 1
            else:
                left += 1",1
"class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
         
        column_title = """"
        while columnNumber > 0:
            columnNumber, remainder = divmod(columnNumber - 1, 26)
            column_title = chr(65 + remainder) + column_title
        return column_title",1
"class Solution:
    def majorityElement(self, nums: List[int]) -> int: 
        n = len(nums)
        d = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        for x, v in d.items():
            if v>n/2:
             return x",1
"class Solution(object):
    def titleToNumber(self, s):
        return reduce(lambda a,b:a*26+b, map(lambda x:ord(x)-ord('A')+1, s))",0
"class Solution:
    def trailingZeroes(self, n: int) -> int:
        x = 1
        res = 0
        while 5**x < 10**4+1:
            res += n//5**x
            x += 1
        return res",1
"class BSTIterator:   
    
    def __init__(self, root: Optional[TreeNode]):
        self.nodes = []
        self.inorder(root)
        
    def inorder(self, root):
        if root is None:
            return
        self.inorder(root.left)
        self.nodes.append(root.val)
        self.inorder(root.right)

    def next(self) -> int:
        return self.nodes.pop(0)
        

    def hasNext(self) -> bool:
        return len(self.nodes) > 0
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()",1
"class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        dp = [[0 for i in range(len(dungeon[0]))] for i in range(len(dungeon))]
        for i in reversed(range(len(dungeon))):
            for j in reversed(range(len(dungeon[0]))):
                if i==len(dungeon)-1 and j==len(dungeon[0])-1: dp[i][j] = min(dungeon[i][j], 0); continue
                val = max(dp[i][j+1] if j<len(dungeon[0])-1 else float(""-inf""), dp[i+1][j] if i<len(dungeon)-1 else float(""-inf""))
                dp[i][j] = 0 if dungeon[i][j] + val>0 else dungeon[i][j] + val
        return max(-dp[0][0], -dungeon[0][0], 0) + 1",0
"class Solution:
    
    def compare(self,n1,n2):
        if str(n1)+str(n2)>str(n2)+str(n1):
            return True
        else:
            return False
    
    def largestNumber(self, nums: List[int]) -> str:
        
        if len(list(set(nums)))==1 and nums[0]==0:
            return ""0""
        
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                
                if not self.compare(nums[i],nums[j]):
                    nums[i],nums[j]=nums[j],nums[i]
        
        return ''.join(map(str,nums))",1
"class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        if len(s)<10: return []
        ht=collections.defaultdict(int)
        res=set()
        while len(s)>=10:
            ht[s[:10]]+=1
            if ht[s[:10]]>1: res.add(s[:10])
            s=s[1:]            
        return list(res)",1
"class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        
        if k == 0: return 0
        
        t0 = [0] * (k+1)
        t1 = [float('-inf')] * k
        
        for p in prices:
            for tr in range(k):
                t0[tr] = max(t0[tr], t1[tr] + p)
                t1[tr] = max(t1[tr], t0[tr-1] - p)
        return t0[-2]",1
"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        for _ in range(k):
            nums.insert(0, nums.pop())",1
"class Solution:
    def reverseBits(self, n: int) -> int:
        return int(str(bin(n)[2:]).rjust(32,'0')[::-1], 2)",0
"class Solution:
    def hammingWeight(self, n: int) -> int:
        return len([c for c in f""{n: b}"" if c==""1""])",0
"class Solution:
    def rob(self, nums: List[int]) -> int:
        dp= [0] * len(nums)
        if len(nums) == 1:
            return nums[0]
        for i in range(len(nums)):
            dp[i] = max(dp[i-2]+nums[i],dp[i-1])
        return max(dp)",1
"class Solution:
    def rightSideView(self, root: TreeNode):
        rightside = {}
        self.seeTree(root, rightside, 1)
        numbers = [value for value in rightside.values()]
        return numbers
                
    def seeTree(self, root: TreeNode, rightside: dict, nodo: int):
        if root == None:
            return
        if root.val != None:
            rightside[nodo] = root.val
            self.seeTree(root.left, rightside, nodo + 1)
            self.seeTree(root.right, rightside, nodo + 1)
        return",0
"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows,cols = len(grid),len(grid[0])
        islands = 0
        visit = set()
        # using dfs in 2 methods
        # firstone
        def dfs(r,c):
            if r <0 or r >= rows or c <0 or c >= len(grid[0]) or grid[r][c]!=""1"" :
                return 
            if (r,c) not in visit:
                visit.add((r,c))
                dfs(r+1,c)
                dfs(r-1,c)
                dfs(r,c+1)
                dfs(r,c-1)

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == ""1"" and (r,c) not in visit:
                    dfs(r,c)
                    islands+=1
        return islands",0
"class Solution:
def rangeBitwiseAnd(self, left: int, right: int) -> int:
    
    k = 0
    while left!=right:
        left>>=1
        right>>=1
        k+=1
    
    return left<<k",1
"class Solution:
    def isHappy(self, n: int) -> bool:
        while n != 1:
            n = sum([int(i) ** 2 for i in str(n)])
            if n == 4:
                return False
        
        return True",1
"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if not head:
            return head
        # print(head.val)
        if head.val == val:
            head = self.removeElements(head.next, val)
        else:
            head.next =  self.removeElements(head.next, val)
        return head",1
"class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 3:
            return 0
        
        primes = [1]*n
        primes[0] = primes[1] = 0
        for i in range(2,int(n**0.5)+1):
            if primes[i] != 0:
                for j in range(2*i,n,i):
                    primes[j] = 0
        return sum(primes)
        
    def countPrimesOptimized(self, n: int) -> int:
        if n < 3:
            return 0
        
        primes = [1]*n
        primes[0] = primes[1] = 0
        for i in range(2,int(n**0.5)+1):
            if primes[i]:
                primes[i*i:n:i] = [0]*len(primes[i*i:n:i])
                #print(i,primes[i*i:n:i])
        return sum(primes)",0
"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        MAX_CHARS = 256
        n = len(s)
        m = len(t)
        if n != m:
            return False
        marked = [False] * MAX_CHARS
        map = [-1] * MAX_CHARS

        for i in range(n):
            if map[ord(s[i])] == -1:
                if marked[ord(t[i])] == True:
                    return False
                marked[ord(t[i])] = True
                map[ord(s[i])] = t[i]
            
            elif map[ord(s[i])] != t[i]:
                return False
        return True",1
"class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        prev = None
        while head:
            head.next,head,prev = prev,head.next,head
        return prev",1
"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        STATUS_VISITING = 0
        STATUS_VISITED = 1
        
        def no_cycle(node):        
            if node in status:
                if status[node] == STATUS_VISITED:
                    return True
                else:
                    return False
            
            status[node] = STATUS_VISITING
            for child in adj[node]:
                if not no_cycle(child):
                    return False
            
            status[node] = STATUS_VISITED
            return True
        
        adj = defaultdict(list)
        nodes = set()
        for a, b in prerequisites:
            adj[b].append(a)
            nodes.add(b)
            
        status = {}
        for node in nodes:
            if not no_cycle(node):
                return False           
            
        return True",1
"class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        lb = 0
        ub = 0
        wSum = nums[0]
        numLen = len(nums)
        ans = []
        while lb<numLen:
            # print(lb, ub, wSum)
            if wSum >= target:
                ans.append(ub-lb+1)
            
            if wSum < target and ub+1< numLen:
                ub+=1
                wSum += nums[ub]
            else:
                wSum -= nums[lb]
                lb+=1
                
        # print(ans)
        if ans:
            return min(ans)
        return 0",1
"class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        ans = []
        d = {}
        indegree = {}
        for i in range(numCourses):
            d[i] = []
            indegree[i] = 0
        
        for i in prerequisites:
            d[i[0]].append(i[1])
            indegree[i[1]] += 1
        
        queue = []
        for i in indegree:
            if indegree[i] == 0:
                queue.append(i)
        
        while queue:
            curr = queue.pop(0)
            ans.insert(0,curr)
            for i in d[curr]:
                if indegree[i] > 0:
                    indegree[i]-= 1
                    if indegree[i] == 0:
                        queue.append(i)
        
        for i in indegree:
            if indegree[i] != 0:
                return []
        return(ans)",0
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        #  My Effort - Passed all test cases, yet backtracking line doesn't work
        cntBoard = collections.Counter(''.join([e for row in board for e in row ]))
        cntW = [collections.Counter(w) for w in words]
        idxBoard = collections.defaultdict(list)
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                idxBoard[board[i][j]].append((i,j))
        # print(idxBoard)
        dirs = [(0,1), (0,-1), (-1,0), (1,0)]
        # dirs = [(0,1), (0,-1), (1,0), (-1,0)] # fail some test cases

        def dfs(x, y, w, i):
            if i == len(w):
                return True
            for a, b in dirs:
                nx, ny = x + a, y + b
                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and board[nx][ny] == w[i]:
                    visited.add((nx, ny))
                    return dfs(nx, ny, w, i+1) # if I don't add return, the recursive function call returns None or False
                    # visited.remove((nx, ny)) # However, if I add return, this line is never executed, backtracking doesn't work but we actually need backtracking

        ans = []
        
        for w in words:
            if collections.Counter(w) - cntBoard:
                continue
            for x, y in idxBoard[w[0]]:
                visited = set()
                visited.add((x,y))
                result = dfs(x, y, w, 1)
                if result:
                    ans.append(w)
                    break
        return ans",0
"class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n == 1:
            return nums[0]
        
        if n == 2:
            return max(nums[0], nums[1])
        
        # result1: don't consider the first house
        # result2: don't consider the last house
        result1 = self.robRange(nums, 1, n-1)
        result2 = self.robRange(nums, 0, n-2)
        return max(result1, result2)
    
    def robRange(self, nums, start, end):
        dp = [0] * len(nums)
        dp[start] = nums[start]
        dp[start + 1] = max(nums[start], nums[start + 1])
        
        for i in range(start + 2, end + 1):
            dp[i] = max(dp[i -2] + nums[i], dp[i - 1])
        
        return dp[end]",0
"class Solution:
    def shortestPalindrome(self, s: str) -> str:
        i,l = 0,len(s)
        for j in range(l-1,-1,-1):
            if s[i]==s[j]: i+=1
        if i==l: return s
        return s[i:][::-1] + self.shortestPalindrome(s[:i]) + s[i:]",0
"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        k = n - k

        def quickSort(l=0, r=n-1):
            p, pivot = l, nums[r]
            for i in range(l, r):
                if nums[i] <= pivot:
                    nums[i], nums[p] = nums[p], nums[i]
                    p += 1

            nums[p], nums[r] = pivot, nums[p]

            if k > p:
                return quickSort(p + 1, r)
            elif k < p:
                return quickSort(l, p - 1)
            return nums[k]

        return quickSort()",0
"class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
    
        res = []
        
        self.backtrack(k, n, [],0,1, res)
        
        return res
    
    def backtrack(self, k, n, cur, comb, ind, res):
        
        if comb > n:
            return 
        elif comb == n and len(cur) == k:
            res.append([]+cur)
        else:
            
            for i in range(ind,10):
                cur.append(i)
                
                self.backtrack(k, n, cur, comb+i, i+1, res)
                cur.pop()",0
"class Solution(object):
    def containsDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        #1
        # a = list(set(nums))
        # nums.sort()
        # a.sort()
        # return False if a==nums else True
        
        #2
        hash_table = {}
        for num in nums:
            hash_table[num] = hash_table.get(num, 0)+1
            
        return False if max(hash_table.values()) == 1 else True
        
#         #3
#         from collections import Counter
#         return False if set(Counter(nums).values()) == {1} else True",1
"class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        if not buildings:
            return []
        if len(buildings) == 1:
            return [[buildings[0][0], buildings[0][2]],[buildings[0][1], 0]]

        mid = (len(buildings)-1) // 2
        left = self.getSkyline(buildings[0:mid+1])
        right = self.getSkyline(buildings[mid+1:])

        return self.merge(left, right)

    def merge(self, left, right):
        i = j = h1 = h2 = 0
        ret = []
        while i < len(left) and j < len(right):
            if left[i][0] < right[j][0]:
                h1 = left[i][1]
                new = [left[i][0], max(h1, h2)]
                if not ret or ret[-1][1] != new[1]:
                    ret.append(new)
                i += 1
            elif left[i][0] > right[j][0]:
                h2 = right[j][1]
                new = [right[j][0], max(h1, h2)]
                if not ret or ret[-1][1]!=new[1]:
                    ret.append(new)
                j+=1
            else:
                h1 = left[i][1]
                h2 = right[j][1]
                new = [right[j][0], max(h1, h2)]
                if not ret or ret[-1][1] != new[1]:
                    ret.append([right[j][0],max(h1, h2)])
                i += 1
                j += 1

        while i < len(left):
            if not ret or ret[-1][1] != left[i][1]:
                ret.append(left[i][:])
            i+=1

        while j < len(right):
            if not ret or ret[-1][1] != right[j][1]:
                ret.append(right[j][:])
            j+=1

        return ret",0
"class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if not nums or k<1 or t<0 or (t==0 and len(nums)==len(set(nums))): return False
        for i in range(len(nums)):
            for j in range(1,k+1):
                if (i+j)>=len(nums): break
                if abs(nums[i+j]-nums[i])<=t: return True
        return False",0
"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        for y, row in enumerate(matrix):
            count_x = 1
            for x, val in enumerate(row):
                if val is '1':
                    matrix[y][x] = count_x
                    count_x += 1
                else:
                    matrix[y][x] = 0
                    count_x = 1

        # transpose
        best = 0
        matrix = list(zip(*matrix))
        popper = list()
        for i in range(10000):
            flag = False
            for j, col in enumerate(matrix):
                count = 0
                for val in col:
                    if val > i: 
                        count += 1
                        if count > i:
                            best = i + 1
                            flag = True
                            break
                    else:
                        count = 0
                if flag:
                    break
                else:
                    popper.append(j)
            if flag:
                matrix = [col for j, col in enumerate(matrix) if j not in popper]
                popper.clear()
            else:
                break
        
        return best ** 2",0
"class Solution:
    
    def count(self,node):

        if node is None: # travelled beyond a leaf
            return 0

        return 1 + self.count(node.left) + self.count(node.right) # all other cases
    
    def countNodes(self, root: Optional[TreeNode]) -> int:
        return self.count(root)",1
"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area",0
"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        temp = root.left
        root.left = root.right
        root.right = temp
        
        self.invertTree(root.left)
        self.invertTree(root.right)
        
        return root",1
"class Solution:
    def calculate(self, s: str) -> int:
        #pre-processing to tokenize string 
        s = s.replace("" "", """") #remove white space
        
        tokens = []
        lo = hi = 0
        while hi <= len(s):
            if hi == len(s) or s[hi] in ""+-*/"": 
                tokens.append(s[lo:hi]) #tokenize number
                if hi < len(s): tokens.append(s[hi]) #tokenize operator
                lo = hi + 1
            hi += 1
        
        #dijkstra's two-stack algo
        opd, opr = [], [] #operand &amp; operator stacks 
        sign = 1
        for token in tokens: 
            if token in ""+-*/"": 
                opr.append(token)
                if token == ""-"": sign = -1
            else: 
                token = sign*int(token)
                sign = 1
                if opr and opr[-1] in ""*/"":
                    op = opr.pop()
                    x = opd.pop()
                    if op == ""*"": token = x * token
                    elif op == ""/"": token = int(x / token) #not floor division 
                opd.append(token)
            
        return sum(opd)",0
"class Solution:
    def summaryRanges(self, a: List[int]) -> List[str]:
        if not a:
            return []
        ans=[]
        n=len(a)
        start=a[0]
        flag=0
        for i in range(n-1):
            if a[i]+1==a[i+1]:
                flag=1
            else:
                if flag==1 and start!=a[i]:
                    ans.append(str(start)+'->'+str(a[i]))
                else:
                    ans.append(str(start))
                start=a[i+1]
        if flag==1 and start!=a[i+1]:
            ans.append(str(start)+'->'+str(a[i+1]))
        else:
            ans.append(str(start))
        return ans",0
"class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        return [v for v in set(nums) if nums.count(v)>math.floor(len(nums)/3)]",0
"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        node_vals = []

        def traverse_inorder(node):
            if node is None:
                return
            traverse_inorder(node.left)
            node_vals.append(node.val)
            traverse_inorder(node.right)

        traverse_inorder(root)

        return node_vals[k - 1]",1
"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        return n &amp; (n-1) == 0",1
"class Solution:
    def countDigitOne(self, n: int) -> int:
        if n < 1: return 0

        # i = 0
        p = 1 # 10 ** i
        c = 0 # count of 1s less than 10 ** i
        
        result = 0
        for char in str(n)[::-1]:
            d = int(char)
            # if d == 0: pass
            if d == 1:
                result += c + n%(p) + 1
            elif d > 1:
                result += p + d*c
            c += p + (c<<3)+c # c = p + 8*c + c
            p = (p<<3)+p+p # p *= 10
            # i += 1
        return result",0
"class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:

        slow_node = head
        fast_node = slow_node
        prev_node = None
        while fast_node is not None:

            if fast_node.next is None:
                # list is odd length (don't add another node to reversed 1st half list - the next node is the odd mid-point)
                fast_node = fast_node.next
                slow_node = slow_node.next
            else:
                # list is even length (add another node to reversed 1st half list)
                fast_node = fast_node.next.next
                temp_node = slow_node
                slow_node = slow_node.next
                temp_node.next = prev_node
                prev_node = temp_node

        # At this point prev_node points to the head of reversed 1st half of list and slow_node points to head of remaining half of list

        while slow_node is not None:
            if slow_node.val != prev_node.val:
                return False
            slow_node = slow_node.next
            prev_node = prev_node.next

        return True",0
"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        cur =root
        while cur:
            if p.val > cur.val and q.val>cur.val:
                cur=cur.right
            elif p.val<cur.val and q.val<cur.val:
                cur=cur.left
            else:
                return cur",1
"class Solution:
    def __init__(self):
        self.seen = collections.defaultdict(TreeNode)
        
    def get_list(self, cur, prev, target):
        if not cur:
            return None
        
        self.seen[cur.val] = cur
        
        new_cur = TreeNode(cur.val)
        new_cur.left = prev
        
        if new_cur.val == target.val:
            return new_cur
        
        _next = cur.left
        head_from_left = self.get_list(_next, new_cur, target)
        if head_from_left:
            return head_from_left
        
        _next = cur.right
        head_from_right = self.get_list(_next, new_cur, target)
        if head_from_right:
            return head_from_right
        
        new_cur.left = None
        
        return None

    
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        head1 = self.get_list(root, None, p)
        head2 = self.get_list(root, None, q)
        
        it1, it2 = head1, head2
        
        while it1.val != it2.val:
            if not it1.left:
                it1 = head2
            else:
                it1 = it1.left
            
            if not it2.left:
                it2 = head1
            else:
                it2 = it2.left
        
        return self.seen[it1.val]",0
"class Solution:
    def deleteNode(self, node):
        """"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """"""            
        node.val = node.next.val
        node.next = node.next.next",1
"class Solution:
    def productExceptSelf(self, n: List[int]) -> List[int]:
        ans = [1] * len(n)
        
        pre, pos = 1, 1
        
        for i in range(len(n)):
            ans[i] = pre
            pre *= n[i]
            
        for i in range(len(n)-1, -1, -1):
            ans[i] *= pos
            pos *= n[i]
            
        return ans",1
"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        l,r = 0,0
        q = []
        
        while True:
            if not q:
                q.append(nums[l])
            else:
                while q and nums[r]>=q[-1]:
                    q.pop()
                q.append(nums[r])         
            if r-l+1==k:
                break
            r+=1
          
        ans = []
        
        while r!=len(nums):
            maxi = q[0]
            ans.append(maxi)	
            if r+1<len(nums):
                while q and (len(q)==0 or nums[r+1]>q[-1]):
                    q.pop()
                q.append(nums[r+1])  
            if nums[l]==q[0]:
                q.pop(0)
            l+=1
            r+=1
        return ans",0
"class Solution:
    def binarysrc(self,arr,k):
        l=0
        r=len(arr)-1
        while l<=r:
            m=(l+r)//2
            if arr[m]==k:
                return m
            elif k>arr[m]:
                l=m+1
            else:
                r=m-1
        else:
            return -1  
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        for i in range(len(matrix)):
            if target>=matrix[i][0] and target<=matrix[i][-1]:
                if self.binarysrc(matrix[i],target)!=-1:
                    return True
        return False",0
"class Solution:
    def diffWaysToCompute(self, input: str) -> List[int]:
        ops={
            '+':lambda x,y:x+y,
            '-':lambda x,y:x-y,
            '*':lambda x,y:x*y
        }
        def ways(s):
            ans=[]
            for i in range(len(s)):
                if s[i] in '+-*':
                    ans+=[ops[s[i]](l,r) for l,r in itertools.product(ways(s[0:i]),ways(s[i+1:]))]
            if not ans:
                ans.append(int(s))
            return ans
        return ways(input)",0
"class Solution:
    def isAnagram(self, s, t):
        return Counter(s) == Counter(t)",1
"class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        self.ans = []
        
        def recurse(node, s):
            if node is None:
                return True
            
            s += str(node.val)
            left = recurse(node.left, s + ""->"")
            right = recurse(node.right, s + ""->"")
            
            if left and right:
                self.ans.append(s)
            
        recurse(root, '')
     
        return self.ans",1
"class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        counter = collections.Counter(nums)
        res = sorted(counter, key=lambda x:counter[x])
        return [res[0], res[1]]",1
"class Solution:
    def isUgly(self, n: int) -> bool:
        if n == 0:      # CRITICAL edge case!
            return False
        a = n
        for d in [2, 3, 5]:  # means -- taking out all ""banned"" factors from the input number
            while a % d == 0:
                a //= d
        return a == 1",1
"class Solution:
    def find_upper(self, d, n_list, beg):
        re = 1
        for i in range(beg, len(n_list)):
            re = n_list[i]
            if (d < n_list[i]):
                break
        return(re)
            
    def nthUglyNumber(self, n: int) -> int:
        re = 1
        ll = [1]
        for i in range(n-1):
            new_n = ll[len(ll)-1]
            min_n = new_n * 10
            
            d2 = self.find_upper(new_n//2, ll, len(ll)//2) * 2
            if (d2 < min_n):
                min_n = d2
            d3 = self.find_upper(new_n//3, ll, len(ll)//3) * 3
            if (d3 < min_n):
                min_n = d3 
            d5 = self.find_upper(new_n//5, ll, len(ll)//5) * 5
            if (d5 < min_n):
                min_n = d5
                
            ll.append(min_n)
            re = min_n
            
        return(re)",0
"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        #nums.sort()
        list1=[x for x in range(0,len(nums)+1) if x not in nums]
        print(list1[0])
        return list1[0]",1
"class Solution:
    def numberToWords(self, num: int) -> str:
        ones = {1:'One', 2:'Two', 3:'Three', 4:'Four', 5:'Five', 
                6:'Six', 7:'Seven', 8:'Eight', 9:'Nine'}
        teens = {10:'Ten', 11:'Eleven', 12:'Twelve', 13:'Thirteen', 14:'Fourteen', 15:'Fifteen',
                 16:'Sixteen', 17:'Seventeen', 18:'Eighteen', 19:'Nineteen'}
        tens = {2:'Twenty', 3:'Thirty', 4:'Forty', 5:'Fifty', 
                6:'Sixty', 7:'Seventy', 8:'Eighty', 9:'Ninety'}
        comas = {0:'', 1:'Thousand', 2:'Million', 3:'Billion'}

        def threeDigit(n):
            res = ''
            if n // 100:
                res += (ones[n//100]+' Hundred ')
                if n%100 == 0:
                    return res
                n %= 100
            
            if int(n) == 0:
                return res
            elif n < 10:
                res += (ones[n]+' ')
            elif n < 20:
                res += (teens[n]+' ')
            elif n%10 == 0:
                res += (tens[n//10]+' ')
            else:
                res += (tens[n//10]+' '+ones[n%10]+' ')
            return res
        
        if num == 0:
            return 'Zero'
        if num < 1000:
            return threeDigit(num).strip()

        numdiv, res = [], ''        
        while num > 0:
            numdiv.insert(0, num%1000)
            num //= 1000
        #num: 1234567 => [1,234,567]
        
        for i in range(len(numdiv)):
            part = threeDigit(numdiv[i])
            if part == '':
                continue
            else:
                res += (part+comas[len(numdiv)-1-i]+' ')
        
        return res.rstrip()",0
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort(reverse = True)
        
        for indx, citation in enumerate(citations):
            if indx >= citation:
                return indx
        return len(citations)",1
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        while citations and citations[0]<len(citations):
            citations.pop(0)
        return len(citations)",1
"class Solution:
    def firstBadVersion(self, n: int) -> int:
        left  = 1
        while n >= left:
            mid = (n + left) // 2
            if isBadVersion(mid) and not isBadVersion(mid-1):
                return mid
            elif not isBadVersion(mid) :
                left = mid + 1
            else:
                n = mid -1",1
"class Solution:
    def numSquares(self, n: int) -> int:
        #check whether n is perfect square
        if int(n**0.5)**2==n:
            return 1
        #collect the possible perfect squares used to construct n
        ps=set()
        i=1
        while i**2<=n:
            ps.add(i**2)
            i+=1
        #create two ends of the bfs
        begin=set()
        begin.add(0)
        end=set()
        end.add(n)
        step=0
        while begin and end:
            step+=1
            temp=set()
            high=max(end)
            for i in begin:
                for j in ps:
                    #check if begin reaches end
                    if (i+j) in end:
                        return step
                    #if i+j>high, it's not possible to be a part of the answer
                    elif i+j<high:
                        temp.add(i+j)
            begin=temp
            step+=1
            temp=set()
            low=min(begin)
            for i in end:
                for j in ps:
                    #check if end reaches begin
                    if (i-j) in begin:
                        return step
                    #if i-j<low, it's not possible to be a part of the answer
                    elif i-j>low:
                        temp.add(i-j)
            end=temp
        return -1",0
"class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        
        def fn(i, expr, total, last):
            """"""Populate ans with expression evaluated to target.""""""
            if i == len(num): 
                if total == target: ans.append(expr)
            else: 
                for ii in range(i, len(num) if num[i] != ""0"" else i+1): 
                    val = int(num[i:ii+1])
                    if i == 0: fn(ii+1, num[i:ii+1], val, val)
                    else: 
                        fn(ii+1, expr + ""*"" + num[i:ii+1], total - last + last * val, last * val)
                        fn(ii+1, expr + ""+"" + num[i:ii+1], total + val, val)
                        fn(ii+1, expr + ""-"" + num[i:ii+1], total - val, -val)
                    
        ans = []
        fn(0, """", 0, 0)
        return ans",0
"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        start = 0 
        second = 1

       
        while second < len(nums): 
           
            if(nums[start] == 0 and nums[second] !=0):
               nums[start], nums[second] = nums[second], nums[start]
               start+=1
            if(nums[start] != 0 ):
                start +=1
            second+=1",1
"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        
        freq = Counter(nums)
        return freq.most_common(1)[0][0]",1
"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        rows, cols = len(board),  len(board[0])     
        def transform(row, col, temp_board):
            nonlocal rows, cols
            neighbors = 0
            for r, c in [(row-1, col-1), (row, col-1), (row+1, col-1), (row-1, col), (row+1, col), (row-1, col+1), (row, col+1), (row+1, col+1)]:
                if 0 <= c < cols and 0 <= r < rows:
                    neighbors += temp_board[r][c]
                    
            if board[row][col] == 1:
                if neighbors < 2 or neighbors > 3:
                    return 0
                else:
                    return 1
            else:
                return 1 if neighbors == 3 else 0
        # Take a snapshot of the current board for calculation
        temp_board = [row[:] for row in board]
        for row in range(rows):
            for col in range(cols):
                board[row][col] = transform(row, col, temp_board)",0
"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s=s.split()
        if(len(s)!=len(pattern)):
            return False
        d=dict()
        for i,j in zip(list(pattern),s):
            if i not in d:
                if j not in d.values():
                    d[i]=j
                else:
                    return False
            else:
                if d[i]!=j:
                    return False
        return True",1
"class Solution:
    def canWinNim(self, n: int) -> bool:
        
        return n % 4",1
"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        fqs, fqg = {}, {} #frequency table 
        for s, g in zip(secret, guess): 
            if s == g: bulls += 1
            fqs[s] = 1 + fqs.get(s, 0)
            fqg[g] = 1 + fqg.get(g, 0)
        cows = sum(min(v, fqg.get(k, 0)) for k, v in fqs.items()) - bulls
        return f""{bulls}A{cows}B""",0
"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lis = [nums[0]]
        for num in nums[1:]:
            if lis and num > lis[-1]:
                lis.append(num)
            else:
                index = bisect_left(lis, num)
                lis[index] = num
        return len(lis)",1
"class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        self.ans = []
        self.minMoves = float('inf')
        
        @lru_cache(None)
        def rec(s, count):
            if not s or count > self.minMoves:
                return
            elif self.isValid(s):
                if count == self.minMoves:
                    self.ans.append(s)
                else:
                    self.minMoves = count
                    self.ans = [s]
            
            for i in range(len(s)):
                if s[i] in '()':
                    rec(s[:i] + s[i+1:], count+1)
                    
        rec(s, 0)
        return self.ans or ['']
            
            
    def isValid(self, s):
        l, r = 0, 0
        for i in range(len(s)):
            if s[i] == '(': l += 1
            elif s[i] == ')': r += 1
                
            if r > l: return False
            
        return r == l",0
"class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        for i in range(1, n//2+1):
            x = num[:i]
            if x.startswith(""0"") and len(x) > 1: break #no leading zero 
            for j in range(i+1, min(n-i, (n+i)//2)+1): #i <= n-j and j-i <= n-j
                yy = num[i:j]
                if yy.startswith(""0"") and len(yy) > 1: break #no leading zero
                
                ii, xx = i, x
                while num.startswith(yy, ii):
                    ii += len(yy)
                    xx, yy = yy, str(int(xx) + int(yy))
                if ii == len(num): return True 
                
        return False",0
"class Solution:
    def solve(self, prices, index, opt):
        if index >= len(prices):
            return 0
        if (index, opt) in self.dp:
            return self.dp[(index, opt)]
        if opt == 0:
            buy = self.solve(prices, index+1, 1) - prices[index]
            cool = self.solve(prices, index+1, 0)
            self.dp[(index, opt)] = max(buy, cool)
        else:
            sell = self.solve(prices, index+2, 0) + prices[index]
            cool = self.solve(prices, index+1, 1)
            self.dp[(index, opt)] = max(sell, cool)
        return self.dp[(index, opt)]
        
    def maxProfit(self, prices: List[int]) -> int:
        self.dp = {}
        return self.solve(prices, 0, 0)",0
"class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        
        if n<2:
            return range(n)
        
        graph=defaultdict(set)
        indegree=[0]*n
        for u,v in edges:
            graph[u].add(v)
            graph[v].add(u)
            indegree[u]+=1
            indegree[v]+=1
        
        queue=[]
        for i in range(n):
            if indegree[i]==1:
                queue.append(i)
        
        count=n
        
        while count>2:
            new_queue=[]
            
            for current in queue:
                
                for neighbour in graph[current]:
                    indegree[neighbour]-=1
                    graph[neighbour].remove(current)
                    if indegree[neighbour]==1:
                        new_queue.append(neighbour)
                
                count-=1
            queue=new_queue
        
        return queue",0
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]",0
"class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        ugly = [1]
        seen = set()
        x = []
        heapq.heapify(x)
        while len(ugly) != n:
            for i in primes:
                if ugly[-1]*i not in seen:
                    seen.add(ugly[-1]*i)
                    heapq.heappush(x,ugly[-1]*i)
            ugly.append(heapq.heappop(x))
        return ugly[-1]",1
"class Solution:
  def countSmaller(self, nums: List[int]) -> List[int]:
    l = len(nums)
    arr, ans = sorted(nums), [0] * l
    if l > 99:
      for i in range(l-1):
          ans[i] = bisect_left(arr, nums[i]) # binary search index
          del arr[ans[i]]
    else:
      for i in range(l):
          ans[i] = arr.index(nums[i]) # linear search index
          del arr[ans[i]]
    return ans",1
"class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        mp = {c: i for i, c in enumerate(s)}
        stack = []
        for i, c in enumerate(s): 
            if c not in stack: 
                while stack and c < stack[-1] and i < mp[stack[-1]]: stack.pop()
                stack.append(c)
        return """".join(map(str, stack))",1
"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n = len(words)
        hashmap = dict()
        i = 0
        ans = 0
        for word in words:
            hashmap[i] = set(word)
            i += 1
        
        for i in range(0, n - 1):
            a = hashmap[i]
            for j in range(i + 1, n):
                b = hashmap[j]
                if not len(a.intersection(b)):
                    ans = max(ans, len(words[i]) * len(words[j]))
        return ans",1
"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on",1
"class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        
        def find_k_max_number_in_an_array(nums, k):
            drop_possible = len(nums) - k
            n = len(nums)
            stack = []
            for i, val in enumerate(nums):
                while stack and drop_possible and stack[-1] < val:
                    drop_possible -= 1
                    stack.pop()
                
                stack.append(val)
            
            return stack[:k]
                
        
        def merge_two_array(arr1, arr2):
            #print(arr1, arr2)
            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]

        def compare_two_array(arr1, arr2):
            """"""
            determine whether arr1 is greater than arr2
            """"""
            if not arr2:
                return True
            i = j = 0
            n = len(arr1)
            while i < n and j < n:
                if arr1[i] > arr2[j]:
                    return True
                elif arr1[i] < arr2[j]:
                    return False
                i += 1
                j += 1
            
            return True
        
        ans = 0
        for i in range(k + 1):
            p = k - i
            
            if i > len(nums1) or p > len(nums2):
                continue
            
            # get this two array by solving function find_k_max_number_in_an_array
            # using similar concept of 402. Remove K Digits
            first_arr = find_k_max_number_in_an_array(nums1, i)
            second_arr = find_k_max_number_in_an_array(nums2, p)
            
            # merge two array with everytime taking lexicographily larger list
            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B
            # see explanation
            curr_arr = merge_two_array(first_arr, second_arr)
            #print(curr_arr)
            
            # can be directly use python max function
            if compare_two_array(curr_arr, ans):
                ans = curr_arr
            # ans = max(ans, curr_arr) if ans else curr_arr
            
            #print(ans)
        
        return ans",0
"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # min number of coins summing up to current amount i
        memo = [-666]*(amount + 1)
        return self.dp(coins, amount, memo)
    
    def dp(self, coins, amount, memo):
        if (amount == 0): return 0
        if (amount < 0): return -1
        
        if (memo[amount] != -666):
            return memo[amount]
        
        res = sys.maxsize
        for coin in coins:
            subProblem = self.dp(coins, amount - coin, memo)
            if (subProblem == -1):
                continue
            res = min(subProblem + 1, res)
        
        memo[amount] = res if res != sys.maxsize else -1
        return memo[amount]",0
"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        if len(nums)>1:
            nums.sort()
            temp=nums[:]
            r=len(nums)-1
            ind=1
            while r>=0:
                nums[ind]=temp[r]
                ind+=2
                if ind>=len(nums):
                    ind=0
                r-=1",1
"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and math.isclose(round(math.log(n, 3)), math.log(n, 3), rel_tol = 0.000000000000001)",0
"class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        def find(l,r):
            if l > r:
                return 0
            m = (l+r)//2
            left = [0]
            s = 0
            for i in range(m-1,l-1,-1):
                s += nums[i]
                left.append(s)
            right = [0]
            s = 0
            for i in range(m+1,r+1):
                s += nums[i]
                right.append(s)
            right.sort()
            ans = 0
            for i in left:
                ans += (bisect.bisect_right(right,upper-i-nums[m]) - bisect.bisect_left(right,lower-i-nums[m]))
            return ans + find(l,m-1)+find(m+1,r)
        return find(0, len(nums)-1)",0
"class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head: return head
        p1 = head
        p2 = p1.next
        t = p2
        while p1.next and p2.next:
            p1.next = p2.next
            p1 = p1.next
            p2.next = p1.next
            p2 = p2.next
        p1.next = t
        return head",1
"class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0])
        indegree = defaultdict(int)
        graph = defaultdict(list)
        queue = deque()
        
        for r in range(m):
            for c in range(n):
                for r1, c1 in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:
                    if 0 <= r1 < m and 0 <= c1 < n and matrix[r1][c1] > matrix[r][c]:
                        graph[(r1, c1)].append((r, c))
                        indegree[(r, c)] += 1
                        
                if indegree[(r, c)] == 0: queue.append((r, c, 1))
                    
        while queue:
            r, c, d = queue.popleft()
            
            for r1, c1 in graph[(r, c)]:
                indegree[(r1, c1)] -= 1
                if indegree[(r1, c1)] == 0:
                    queue.append((r1, c1, d+1))
                    
        return d",0
"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans",1
"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        preorder = preorder.split(',')
        n = len(preorder)
        idx, enough = 0, True                    # static `idx`, `enough` node to build a binary tree
        def dfs():
            nonlocal n, idx, enough 
            if idx >= n: enough = False; return  # if not enough node to build a binary tree
            if preorder[idx] == '#': return 
            if preorder[idx] != '#':
                idx += 1                         # say this is `idx_1`
                dfs()                            # build left tree
                idx += 1                         # now, `idx` is not `idx_1 + 1` because `idx` is static and it's increasing during recursion. Hope this solve your confusion
                dfs()                            # build right tree
        dfs()
        return enough and idx >= n-1             # all characters are visited and they are enough to build a tree",0
"class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        edges = collections.defaultdict(list)
        n = len(tickets)
        
        for i in range(len(tickets)):
            edges[tickets[i][0]].append(tickets[i][1])
        for k in edges:
            edges[k].sort()
        
        itinerary_list = ['JFK']
        self.traverse(edges, itinerary_list, n)
        return itinerary_list
    
    
    def traverse(self, edges, itinerary_list, n):
        if len(itinerary_list) == n+1:
            return True
        cur_node = itinerary_list[-1]
        
        for i in range(len(edges[cur_node])):
            if edges[cur_node][i] != '#':
                temp = edges[cur_node][i]
                itinerary_list.append(temp)
                edges[cur_node][i] = '#'
                if self.traverse(edges, itinerary_list, n):
                    return True
                edges[cur_node][i] = temp
                itinerary_list.pop()
        return False",0
"class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
		m1 = float(""inf"")
		m2 = float(""inf"")
        for i in nums:
            if i<m1:
                m1 = i
            elif i<m2 and i>m1:
                m2 = i
            elif i>m2: return True
        return False",1
"class Solution:
    def isSelfCrossing(self, x: List[int]) -> bool:
        def intersect(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real
            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real
        
        def overlap(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real
            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag
                
        uv = complex(0, 1)
        p = complex(0, 0)
        segments = deque()
        for s in x:
            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))
            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):
                    return True
            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):
                    return True
            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):
                    return True
            if len(segments) == 6:
                segments.popleft()
            p = np
            uv *= complex(0, 1)
        return False",0
"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        def isPal(word):
            return word == word[::-1]
        palPairs = []
        wordDict = {}
        for i, word in enumerate(words):
            wordDict[word] = i
        for i, word in enumerate(words):
            for j in range(0, len(word)):
                prefix, suffix = word[:j], word[j:] # find all suffix and prefix
                if prefix[::-1] in wordDict and wordDict[prefix[::-1]] != i and isPal(suffix):
                    palPairs.append([i, wordDict[prefix[::-1]]]) # check if reverse prefix in dict and suffix palindrome
                if suffix[::-1] in wordDict and wordDict[suffix[::-1]] != i and isPal(prefix):
                    palPairs.append([wordDict[suffix[::-1]], i]) # check if reverse suffix in dict and prefix palindrome
                if len(palPairs) > 0 and words[palPairs[-1][1]] == '': # tricky part for prefix or suffix is ''. for example, if '1' + '' is palindrome, then '' + '1' should also be palindrome. and add '' + '1' manually
                    pair = palPairs[-1]
                    palPairs.append([pair[1], pair[0]])
        return palPairs",0
"class Solution:
    def rob(self, root: TreeNode) -> int:
        
        @lru_cache(None)
        def fn(node): 
            """"""Return max money from sub-tree rooted at node.""""""
            if not node: return 0 
            ans = node.val 
            if node.left: ans += fn(node.left.left) + fn(node.left.right)
            if node.right: ans += fn(node.right.left) + fn(node.right.right)
            return max(ans, fn(node.left) + fn(node.right))
        
        return fn(root)",1
"class Solution:
    def countBits(self, n: int) -> List[int]:
        lst=[]
        for x in range(0,n+1):
            if x>1:
                lst.append(lst[x//2]+(x%2))
            else:
                lst.append(x)
        return lst",1
"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        arr=[]
        for i in range(100):
            arr.append(4**i)
        if n in arr:
            return True
        else:
            return False",1
"class Solution:
    def integerBreak(self, n: int) -> int:
    	return 3**(n//3-((n-3*(n//3))<=1))*((n-3*(n//3))+3*((n-3*(n//3))<=1)) if n>3 else n-1",0
"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        n = len(s)-1
        for i in range(n,-1,-1):
            s.append(s[i])
            s.pop(i)",1
"class Solution:
    def reverseVowels(self, s: str) -> str:
        s = list(s)
        vowel = list('AEIOU')
        left_counter, right_counter = 0, len(s) - 1
        l_val, r_val = None, None
        while left_counter<right_counter:
            if s[left_counter].upper() in vowel:
                l_val = left_counter
            elif l_val is None:
                left_counter += 1
            if s[right_counter].upper() in vowel:
                r_val = right_counter
            elif r_val is None:
                right_counter -= 1
            if l_val is not None and r_val is not None:
                s[l_val], s[r_val] = s[r_val], s[l_val]
                l_val = r_val = None
                left_counter +=1
                right_counter -=1
            if left_counter > right_counter:
                break
        return """".join(s)",0
"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        
        nTof = {}
        
        for i in nums:
            if nTof.get(i) is None:
                nTof[i] = 1
            else:
                nTof[i] += 1
        
        unique = list(nTof.keys())
        
        def partition(unique, l, r):
            pivot, p = nTof[unique[r]], r
            
            i = l
            while i < p:
                if nTof[unique[i]] > pivot:
                    unique[i], unique[p-1] = unique[p-1], unique[i]
                    unique[p], unique[p-1] = unique[p-1], unique[p]
                    i -= 1
                    p -= 1
                i += 1
            return p
            
        def quickSelect(unique, l, r, k):
            p = partition(unique, l, r)
            
            if p > k:
                quickSelect(unique, l, p-1, k)
            if p < k:
                quickSelect(unique, p+1, r, k)

            return unique[k:]
            
        return quickSelect(unique, 0, len(unique)-1, len(unique)-k)",0
"class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1).intersection(set(nums2)))",0
"class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums = []
        n1 = len(nums1)
        n2 = len(nums2)
        loc1= []
        loc2= []
        for i in range(n1):
            loc1.append(0)
        for j in range(n2):
            loc2.append(0)
        for i in range(n1):
            for j in range(n2):
                if nums1[i] == nums2[j] and loc1[i]==0 and loc2[j]==0:
                    nums.append(nums1[i])
                    loc1[i] = 1
                    loc2[j] = 1
        return nums",0
"class Solution:
    def maxEnvelopes(self, en: List[List[int]]) -> int:
        def bs(t,n,v):
            i = 0
            j = n-1
            while i<=j:
                m = (i+j)//2
                if t[m][1] == v:
                    return m
                elif v<t[m][1]:
                    j = m-1
                else:
                    i = m+1
            return i
        en.sort(key = lambda x:(x[0],-x[1]))
        t = [en[0]]
        c = 1
        for i in range(len(en)):
            if t[-1][1] < en[i][1]:
                t.append(en[i])
                c += 1
            else:
                x = bs(t,c,en[i][1])
                t[x] = en[i]
        return len(t)",0
"class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
    	if n == 0:
    		return 1
    	g, h = 10, 9
    	for i in range(n-1):
    		g += 9*h
    		h *= (8-i)
    	return(g)
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        # initialize rows and columns values and determine transposed flag if needed 
        rows = len(matrix) # m 
        cols = len(matrix[0]) # n 
        transposed_matrix_flag = False
        transposed_matrix = list()

        # consider a power of 10 as siginficant 
        # if cols is significantly larger than rows in our implementation
        # we will do the significantly larger work^2
        # If this were to occur, we should flip our set up 
        if cols > (10*rows) : 
            # set transpose flag to true 
            transposed_matrix_flag = True
            # loop over columns amount 
            for row in range(cols) : 
                # generate rows 
                transposed_row = list()
                # for column in matrix is actually the rows 
                for col in matrix : 
                    # append the row item at the row index to the row 
                    transposed_row.append(col[row])
                # put the transposed row into the transposed matrix 
                transposed_matrix.append(transposed_row)

        # if transposed flag 
        if transposed_matrix_flag :
            # set the transpose and adjust rows and cols as needed  
            matrix = transposed_matrix 
            rows = len(matrix)
            cols = len(matrix[0])

        # minimum value start for maximal sum 
        maximum_sum = -math.inf

        # loop all columns 
        for col_index in range(cols) : 
            # generate a temporary row 
            temp_row = [0] * rows
            # loop columns from col index to cols 
            # col_index_2 is then our bound column index 
            for col_index_2 in range(col_index, cols) : 
                # set that column sums and the column sum 
                column_sums = [0]
                column_sum = 0
                # loop every row index in range rows 
                for row_index in range(rows) :
                    # temp row at the row index is the matrix at the row and the bound col index 
                    temp_row[row_index] += matrix[row_index][col_index_2]
                    # column sum gets this valuation added 
                    column_sum += temp_row[row_index]
                    # difference is determined 
                    difference = column_sum - k
                    # index is determined by bisection 
                    index = bisect.bisect_left(column_sums, difference)
                    # if index is in range of column sums so far 
                    if index < len(column_sums) : 
                        # if column sums at that index is the difference 
                        if column_sums[index] == difference : 
                            # this is the maximal result, return it 
                            return k
                        else : 
                            # otherwise maximum sum is set to maximum of itself and difference of column sum and column sums at index 
                            maximum_sum = max(maximum_sum, column_sum - column_sums[index])
                    # do an insort of column sum into column sums, at most row times 
                    bisect.insort(column_sums, column_sum)
        # if you never returned k, you should return as good as you got 
        return maximum_sum",0
"class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        def eucid(x,y):
            if x<y: x,y=y,x
            while x!=y!=0:
                remainder=x%y
                x,y=y,remainder
            return x
        e=eucid(x,y)
        if not e: return not z
        return (x+y)>=z and z%e==0",0
"class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num**.5%1 == 0",1
"class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = []
        for i, x in enumerate(nums): 
            dp.append([x])
            for ii in range(i): 
                if x % nums[ii] == 0: 
                    dp[-1] = max(dp[-1], dp[ii] + [x], key=len)
        return max(dp, key=len)",1
"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return sum([a,b])",1
"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        b=int(''.join(map(str,b)))
        res = 1    
        a = a % 1337
        if (a == 0) :
            return 0
        while (b>0) :
            if ((b &amp; 1) == 1):
                res=(res*a)%1337
            b=b>>1      
            a=(a*a)%1337
        return res",1
"class Solution:
    def kSmallestPairs(self, nums1, nums2, k: int):
        temp=[]
        res=[]
        tot=[]
        end=0
        for i in nums1:
            for j in nums2:
                temp.append([i,j])
                tot.append(sum([i,j]))
        for i,v in sorted(zip(temp,tot),key = lambda x: x[1]):
            if end<k:
                res.append(i)
                end+=1
        return res",1
"class Solution:
    def guessNumber(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            val = guess(mid)
            if val == -1:
                r = mid - 1
            
            elif val == 1:
                l = mid + 1

            elif val == 0:
                return mid",1
"class Solution:
    def getMoneyAmount(self, n: int) -> int:
        
        new=[[0 for i in range(0,n+1)] for i in range(0,n+1)]
        for gap in range(1,n+1):
            for j in range(gap,n+1):
                i=j-gap
                if gap==1:
                    new[i][j]=min(i,j)
                    continue
                if i==0 or j==0:
                    continue
                mini=8765432
                for k in range(i,j+1):
                    if k==i:
                        ans=i+new[i+1][j]
                    elif k==j:
                        ans=j+new[i][j-1]
                    else:
                        ans=k+max(new[k+1][j],new[i][k-1])
                    mini=min(ans,mini)
                new[i][j]=mini
        print(new)
        return new[1][-1]",0
"class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if not nums:
            return 0
        less = [1]*len(nums)
        more = [1]*len(nums)
        res_l = 1
        res_m = 1
        
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i] > nums[j] and more[i] < less[j]+1:
                    more[i] = less[j]+1
                    res_m = more[i]
                
                elif nums[i] < nums[j] and less[i] < more[j]+1:
                    less[i] = more[j]+1
                    res_l = less[i]
        return max(res_l,res_m)",1
"class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for comb_sum in range(target+1):
            for num in nums:
                if comb_sum - num >= 0:
                    dp[comb_sum] = dp[comb_sum] + dp[comb_sum-num]
        return dp[target]",1
"class Solution:
    
    import heapq
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        
        heap = []
        for arr in matrix:
            heapq.heappush(heap,(arr[0],0,arr))
            
        while k > 0 and heap:
            val,idx,arr = heapq.heappop(heap)
            ans = val
            if idx+1<len(arr):
                heapq.heappush(heap,(arr[idx+1],idx+1,arr))
            k-=1
        return ans",1
"class Solution:

    def __init__(self, head: ListNode):
        """"""
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """"""
        self.res = []
        
        while head:
            self.res.append(head.val)
            head = head.next
        

    def getRandom(self) -> int:
        """"""
        Returns a random node's value.
        """"""
        return random.choice(self.res)",1
"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        note_freq = collections.Counter(ransomNote)
        mag_freq = collections.Counter(magazine)
        
        for letter in note_freq:
            if note_freq[letter] > mag_freq[letter]:
                return False
        return True",1
"class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        a = nums[0]+nums[1]+nums[len(nums)-1]
        nums.sort()
        for i in range(len(nums)-2):
            l = i+1
            h = len(nums)-1
            while l<h:
                b = nums[i]+nums[l]+nums[h]
                if b > target:
                    h -= 1
                else:
                    l += 1
                if abs(target - b)<abs(target - a):
                    a = b
        return a",1
"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))",0
"class Solution:
    def dfs(self, cur, n, res):
        if cur > n:
            return
        
        res.append(cur)
        for i in range(0, 10):
            self.dfs(cur * 10 + i, n, res)
    
    def lexicalOrder(self, n: int) -> List[int]:
        res = []
        
        for i in range(1, 10):
            self.dfs(i, n, res)
        
        return res",1
"class Solution:
    def firstUniqChar(self, s: str) -> int:
        counts = dict()
        
        for letter in s:
            counts[letter] = counts.get(letter, 0) + 1
        
        for i in range(len(s)):
            if counts[s[i]] == 1:
                return i
        return -1
        
        '''
        # SUPER slow solution
        for i in range(len(s)):
            if s.count(s[i]) == 1:
                return i
        return -1
        '''",1
"class Solution:
    def lengthLongestPath(self, input: str) -> int:
        longest = 0
        path = []
        i = 0
        while i < len(input):
            length = 0
            depth = 0
            is_file = False
            in_path_component = False
            whitespaces = 0
            while i < len(input) and input[i] != '\n':
                if input[i] == '\t':
                    depth += 1
                elif input[i] == ' ':
                    if in_path_component:
                        # We may have whitespaces in folder and file names:
                        length += 1
                    else:
                        # Some test cases seem to use 4 whitespaces instead of one tab character:
                        whitespaces += 1
                        if whitespaces == 4:
                            depth += 1
                            whitespaces = 0
                elif input[i] == '.':
                    in_path_component = True
                    is_file = True
                    length += 1
                elif input[i] != '\n' and input[i] != '\t':
                    in_path_component = True
                    length += 1
                i += 1

            # Move back up the file tree to where we currently are:
            while depth < len(path):
                path.pop()

            if is_file:
                # We may have leading whitespaces which could be mistaken with depth. Add these too.
                length += (depth-len(path))*4
                # We may have leading whitespaces in case we saw a number of whitespaces which was not a multiple of 4. Add these too.
                length += whitespaces
                longest = max(longest, sum(path) + length)
            else:
                path.append(length+1)  # +1 as we need to take the separator ""/"" into account.
            i += 1
        return longest",0
"class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        for i in t:
            if s.count(i)!=t.count(i):
                return i",1
"class Solution:
    def lastRemaining(self, n: int) -> int:
        return 1 if n==1 else 2*(1+n//2-self.lastRemaining(n//2))
    
    def lastRemaining1(self, n: int) -> int:
        """"""""
        removing from left to right [1 2 3 4 5 6 7 8 9]==[2 4 6 8]==2*[1 2 3 4]
        """"""
        def helper(n,is_left):
            if n == 1: return 1
            if is_left: return 2*helper(n//2,False)
            if n%2==1: return 2*helper(n//2,True)
            return 2*helper(n//2,2)-1
        return helper(n,True)
    
    def lastRemaining2(self, n: int) -> int:
        if n==0: return
        st1,st2,left=list(range(1,n+1)),[],True
        while len(st1)>1:
            if not left:
                st1=st1[::-1]
            for i in range(1,len(st1),2):
                st2.append(st1[i])
            st1=list(st2) if left else list(st2[::-1])
            st2=[]
            left = not left
        return st1[0]",0
"class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        area = 0
        corner = set()
        X0 = Y0 = inf
        X1 = Y1 = -inf
        for x0, y0, x1, y1 in rectangles: 
            area += (x1-x0)*(y1-y0)
            X0 = min(x0, X0)
            Y0 = min(y0, Y0)
            X1 = max(x1, X1)
            Y1 = max(y1, Y1)
            corner ^= {(x0, y0), (x0, y1), (x1, y0), (x1, y1)}
        return area == (X1-X0)*(Y1-Y0) and corner == {(X0, Y0), (X0, Y1), (X1, Y0), (X1, Y1)}",0
"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        for i in range(len(s)): 
            if s[i] in t: 
                t =  t[t.index(s[i])+1:]
            else: 
                return False
        return True",1
"class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        i=0
        while i<len(data):
            x=bin(data[i])[2:]
            if len(x)!=8:
                #Means it's a 1 byte
                i+=1
                continue
            cnt=0
            j=0
            while j<len(x) and x[j]=='1':
                cnt+=1#Count num of 1 or bytes 1(num of 1 must be 2,3 or 4)
                j+=1
            if cnt<=1 or cnt>4 or i+cnt>len(data):#cnt means number if bytes
                return False
            i+=1
            cnt-=1#because 1 one byte is used by current num
            while cnt>0:
                y=bin(data[i])[2:]
                if len(y)!=8 or not y.startswith('10'):
                    return False
                i+=1
                cnt-=1
        return True",0
"class Solution:
    def decodeString(self, s: str) -> str:
        def helper(sub):
            res = ''                               # empty new string initailaized
			i = 0                                 # every time we get a valid new substring, we need to traverse through all of it 
            while i < len(sub):
                if sub[i].isdigit():           # if its a digit, we know the next would be an opening bracket,then our substring
                    d = ''                          # To find the whole number we do another while loop 
                    while sub[i].isdigit():
                        d += sub[i]
                        i += 1
                    st = [""[""]                # preemptively intializing with ""["" because we already know a number will always be followed by a opening bracket 
                    new_sub = ''         # We know that the next x characters will be the substring we need for recursion 
                    i += 1                    # This increment is because we already added '[' to the stack which would have been the open bracket at i
                    while st:                            # Now we get the substring using stack approach, just basic bracket validation
                        if sub[i+1] == ""["":         # i+1 to prevent going out of bounds since we are doing i+=1 after the check 
                            st.append(""["")           # I think not doing i+=1 right before ""while st"" and doing i+=1 will then let you check using sub[i]
                        if sub[i+1] == ""]"":
                            st.pop()
                        new_sub += sub[i]
                        i += 1
                    for j in range(int(d)):              # Now, we have whole substring and hence we need to execute that substring the amount of times the number we obtained
                        res += helper(new_sub)    # recursively call the function on that particular substring
                elif sub[i].isalpha():              # if the character of the current string is an alphabet add it to res
                    res += sub[i]
                i += 1 
            return res                 # Return the res generated after traversing throughout the current string 
        
        return helper(s)             # returns the result of the total string",0
"class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        c_counts = []
        pc = None
        n = 0
        for c in s:
            if pc is None:
                pc = s
                n = 1
            else:
                if pc == c:
                    n += 1
                else:
                    c_counts.append((pc, n))
                    n = 1
            pc = c
        if pc:
            c_counts.append((pc, n))
        
        max_sub = 0
        for left in range(len(c_counts)):
            chars = {}
            for right in range(left, len(c_counts)):
                if not chars.get(c_counts[right][0]):
                    chars[c_counts[right][0]] = 0
                chars[c_counts[right][0]] += c_counts[right][1]
                if min(chars.values()) > k - 1:
                    max_sub = max(max_sub, sum(chars.values()))
        return max_sub",0
"class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        total = sum(A)
        ans = cur = sum(i * n for i, n in enumerate(A))
        for i in range(len(A)-1, 0, -1):
            cur += total - len(A) * A[i]
            ans = max(ans, cur)
        return ans",1
"class Solution:
    def integerReplacement(self, n: int) -> int:
        if n==1: return 0
        if n%2==0: return self.integerReplacement(n//2) + 1
        return min(self.integerReplacement(n-1),self.integerReplacement(n+1))+1",0
"class Solution:

    def __init__(self, nums: List[int]):
        self.val_index = collections.defaultdict(list)
        
        for i, num in enumerate(nums):
            self.val_index[num].append(i)

    def pick(self, target: int) -> int:
        return random.choice(self.val_index[target])",1
"class Solution:
    def calcEquation(self, e: List[List[str]], v: List[float], q: List[List[str]]) -> List[float]:
    	V, e, k = {j: False for i in q for j in i}, sorted(i[0]+[i[1]] for i in zip(e,v)), 0
    	for i,[n,d,v] in enumerate(e):
    		if not (V[n] or V[d]): V[n], k = [1,k], k+1
    		[V[n],V[d]] = [V[n],[V[n][0]/v,k-1]] if V[n] else [[V[d][0]*v,k-1],V[d]]
    	return [-1 if not (V[n] and V[d] and V[n][1] == V[d][1]) else V[n][0]/V[d][0] for [n,d] in q]
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def findNthDigit(self, n: int) -> int:
    	s, d = 0, 0
    	while s < n:
    		s += (d+1)*9*10**d
    		d += 1
    	n -= s-d*9*10**(d-1)
    	r, s = n % d, 10**(d-1)+n//d
    	return str(s)[r-1] if r > 0 else str(s-1)[-1]
				
				
- Python 3
- Junaid Mansuri",1
"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
    	n, N, j = list(num), [], k
    	for _ in range(len(num)-k):
    		i = n.index(min(n[:j+1]))
    		N.append(n[i])
    		j -= i
    		del n[:i+1]
    	return """".join(N).lstrip(""0"") or ""0""
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def canCross(self, s: List[int]):
		# memory variable
        mem = dict()
		
		# k = jump variable; i = current index; s = stones list; mem = memory dictionary
        def frog(s, k, i, mem):
			# unique key
            key = str(s[i]) + "":"" + str(k) + "":"" + str(i)

            if i == len(s)-1:
                return True
            if key in mem:
                return mem[key]
			# possible jumps
            jumps = [k-1, k, k+1]

            result = False

            for jump in jumps:
                if jump and s[i]+jump in s:
                    result = frog(s,jump,s.index(s[i]+jump,i),mem)
                mem[key] = result 

            return mem[key]
        
        frog(s, 0, 0, mem)
        
        return True in mem.values()",0
"class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        # Store only left children in stack
        self.stack = []
            
        # Add left children of rightmost diagonal to stack
        self.explore_right_add_left(root)
        
        total = 0
        # We have left children
        while self.stack:
            # Explore the right diagonal from next left child
             while self.stack and self.stack[-1] and self.stack[-1].right:
                # Explore right children and add all left children on this diagonal to stack
                self.explore_right_add_left(self.stack.pop())
				
            # If there is a node still at top of stack, it must be a left child with no direct right child
            if self.stack:
                if self.stack[-1].left:
					# has left child, so add left child to explore
                    self.stack.append(self.stack.pop().left)
                else:
                    # is a left leaf
                    total += self.stack.pop().val

        return total
    
    def explore_right_add_left(self, node):
		"""""" Explore right children and add left children to stack.""""""
        while node:
            if node.left:
                self.stack.append(node.left)
            node = node.right",1
"class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
		# Sort the array, with descending order for height and ascending order for the number of taller persons ahead
        people_sorted = sorted(people, key=lambda p: (p[0], -p[1]), reverse=True)
		# Add persons to the result, at respective indices
        for p in people_sorted:
            res.insert(p[1], p)
        return res",0
"class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])
        
        pq = []
        for i in range(m): 
            heappush(pq, (heightMap[i][0], i, 0))
            heappush(pq, (heightMap[i][n-1], i, n-1))
        for j in range(1, n-1): 
            heappush(pq, (heightMap[0][j], 0, j))
            heappush(pq, (heightMap[m-1][j], m-1, j))
        
        ans = most = 0 
        while pq: 
            ht, i, j = heappop(pq)
            most = max(most, ht)
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 < ii < m-1 and 0 < jj < n-1 and heightMap[ii][jj] != -1: 
                    ans += max(0, most - heightMap[ii][jj])
                    heappush(pq, (heightMap[ii][jj], ii, jj))
                    heightMap[ii][jj] = -1 # mark ""visited""
        return ans",0
"class Solution:
    def longestPalindrome(self, s: str) -> int:
        hashmap = {}
        if len(s) == 0:
            return 0
        for i in s:
            if i not in hashmap:
                hashmap[i] = 1
            else:
                hashmap[i]+= 1
        #Longest odd chars + even chars
        longest_odd_char = 0
        even_chars = 0
        print(hashmap)
        for i in hashmap.keys():
            if hashmap[i]%2 == 1: #odd char string
                if hashmap[i] > longest_odd_char:
                    longest_odd_char = hashmap[i]
            else:
                even_chars += hashmap[i]
        return longest_char + even_chars",1
"class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:        
        #return self.bruteForce(nums,m)
        #self.cache=collections.defaultdict(dict)
        #return self.memo(0,nums,m)
        low,high,res=max(nums),sum(nums),-1
        while low<=high:
            pivot=(low+high)//2
            if self.isValid(nums,m,pivot):
                res,high=pivot,pivot-1
            else:
                low=pivot+1
        return res
    
    def isValid(self,nums,m,pivot):
        chunk,current=0,0
        for v in nums:
            current+=v
            if current>pivot:
                chunk,current=chunk+1,v
        return chunk + 1 <= m
    
    def memo(self,i,nums,m):
        if not nums: return 0
        if m == 1: return sum(nums[i:])
        if i in self.cache and m in self.cache[i]:
            return self.cache[i][m]
        self.cache[i][m]=float(""inf"")
        for j in range(1,len(nums)+1):
            left,right=sum(nums[i:i+j]),self.memo(i+j,nums,m-1)
            self.cache[i][m]=min(self.cache[i][m],max(left,right))
            if left>right: break
        return self.cache[i][m]
    
    def bruteForce(self,nums,m):
        if not nums: return 0
        if m == 1: return sum(nums)
        min_value=float(""inf"")
        for i in range(1,len(nums)+1):
            left,right=sum(nums[:i]),self.bruteForce(nums[i:],m-1)
            min_value=min(min_value,max(left,right))
        return min_value",0
"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        total = []
        for i in range(1,n+1):
            if i % 3 == 0 and i % 5 == 0:
                total.append(""FizzBuzz"")
                continue
            if i % 3 == 0:
                total.append(""Fizz"")
                continue
            if i % 5 == 0:
                total.append(""Buzz"")
                continue
            total.append(str(i))
            
        return total",1
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def totSlices(nums,slices): # For total number of same difference consecutive integers
            count = 2
            co = nums[1]-nums[0]
            for i in range(2,n):
                pre = nums[i]-nums[i-1]
                if  pre == co:
                    count += 1
                else:
                    if count>2:
                        slices.append(count)
                    co = pre
                    count = 2  
                    
            if count>2:
                slices.append(count)
                
            return slices
        
        
        def totCombination(maxSlice,combination): #For combination of maximum slice integer
            combination = [0]*(maxSlice+1)
            st = 1
                
            for i in range(3,maxSlice+1):
                combination[i] = combination[i-1]+st
                st+=1
                
            return combination
                
        n = len(nums)
        
        if n < 3:
            return 0
        
        total = 0
        
        slices = totSlices(nums,[])
        
        if slices == []:
            return 0
            
        combination = totCombination(max(slices),[])
            
        for i in slices:
            total += combination[i]
                
        return total",0
"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        
        # Remove redundant element
        nums = set(nums)
        
        # Convert it back to list to use sort
        nums = list(nums)
        
        # Sort the list
        nums.sort()
        
        # Return the third one from the last if not exist then return the last one
        return nums[-3] if len(nums) >= 3 else nums[-1]",1
"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        if ""0"" in (num1, num2):
            return num2 if num1 == ""0"" else num1
        
        class MyStr(str):
            dic = {str(v): v for v in range(10)}
            
            def __getitem__(self, index):
                try:
                    return MyStr.dic[super().__getitem__(index)]
                except IndexError:
                    return 0
        
        num1, num2 = MyStr(num1), MyStr(num2)
        carry, s = 0, """"
        for idx in range(-1, -1-max(len(num1), len(num2)), -1):
            o_sum = num1[idx] + num2[idx] + carry
            carry = o_sum // 10
            s = f'{o_sum % 10}{s}'
                
        return f'1{s}' if carry else s",0
"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total % 2 != 0: return False 
        target = total // 2
        dp = [False]*(target + 1)
        dp[0] = True
        for num in nums:
            for i in range(target, num-1, -1):
                dp[i] = dp[i] or dp[i-num]
				if dp[target]: return True
        return dp[target]",1
"class Solution:
    def flow(self, q: List[List[int]], canFlowFrom: List[List[bool]], heights: List[List[int]]):
		# directions that we can water can flow from
        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        while len(q) != 0:
            inds = q.pop(0)
            for direction in directions:
                i = inds[0] + direction[0]
                j = inds[1] + direction[1]
				# check if coordinates are valid and that they haven't been visited
                if i >= 0 and j >= 0 and i < len(heights) and j < len(heights[i]) and heights[inds[0]][inds[1]] <= heights[i][j] and not canFlowFrom[i][j]:
                        q.append([i, j])
                        canFlowFrom[i][j] = True
            
        
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m = len(heights)
        n = len(heights[0])
        flowToAtlantic = [[False] * n for i in range(m)]
        flowToPacific = [[False] * n for i in range(m)]
        atlanticQ = []
        pacificQ = []
        # add edges touching ocean
        for i in range(m):
            pacificQ.append([i, 0])
            flowToPacific[i][0] = True
            atlanticQ.append([i, n - 1])
            flowToAtlantic[i][n - 1] = True
		# add edges touching ocean
        for j in range(n):
            pacificQ.append([0, j])
            flowToPacific[0][j] = True
            atlanticQ.append([m - 1, j])
            flowToAtlantic[m - 1][j] = True
        # flow from edges updwards to validate if can flow to specific ocean for each coordinate
        self.flow(atlanticQ, flowToAtlantic, heights)
        self.flow(pacificQ, flowToPacific, heights)
        res = []
        for i in range(m):
            for j in range(n):
				# if we can reach both oceans, then we can add it to the result list
                if flowToAtlantic[i][j] and flowToPacific[i][j]:
                    res.append([i, j])
        return res",0
"class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        if not board:
            return 0
        counter = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == ""X"":
                    self.dfs(board, i, j)
                    counter += 1
        return counter
    
    def dfs(self, board, i, j):
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[i]) or board[i][j] != ""X"":
            return
        board[i][j] = ""#""
        self.dfs(board, i+1, j)
        self.dfs(board, i-1, j)
        self.dfs(board, i, j+1)
        self.dfs(board, i, j-1)",0
"class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        lengthOfPassword=len(password)
        
        #IF PASSWORD IS LESS THAN 2 CHARACTER
        if lengthOfPassword<3:
            return 6-lengthOfPassword

        isLower=False
        isUpper=False
        isDigit=False

        repeatedCharacters=[]
        lastCharacter=''
        numberOfRepeatedCharacter=-1

        #LOOP TO CHECK ALL CONTITIONS
        for i in range(lengthOfPassword):

            #CHECKING FOR UPPER<LOER CASE AND DIGIT IN PASSWORD
            if not isUpper and password[i].isupper():
                isUpper=True
            elif not isLower and password[i].islower():
                isLower=True
            elif not isDigit and password[i].isdigit():
                isDigit=True

            #COUNTING TOTAL REPEATATION 
            if lastCharacter==password[i]:
                repeatedCharacters[numberOfRepeatedCharacter]+=1
            else:
                numberOfRepeatedCharacter+=1
                repeatedCharacters.append(1)
                lastCharacter=password[i]
         #<END OF FIRST FOR LOOP>
        cases=int(not isUpper)+int(not isLower)+int(not isDigit)                    
        #LOGIC

        if lengthOfPassword<6:
            #LESS THAN 6 CHARACTERS
            return cases if cases>6-lengthOfPassword else 6-lengthOfPassword
            
        elif lengthOfPassword<=20:        
            #ATLEAST 6 CHARACTER AND ATMOST 20 CHARACTERS
            totalRepeats=0
            for i in repeatedCharacters:
                totalRepeats+=int(i/3)
            return cases if cases>totalRepeats else totalRepeats
            
        elif lengthOfPassword>20:
            extra=lengthOfPassword-20
            totalchanges=0
            while extra!=0:
                #Negitive Value
                pos=-1
                #Modulo should be more than 2
                value=5.99
                countUnique=0
                for i in range(len(repeatedCharacters)):
                    if repeatedCharacters[i]<3:
                        countUnique+=1
                        continue
                    else:
                        if repeatedCharacters[i]%3==0:
                            pos=i
                            value=repeatedCharacters[i]
                            break
                        elif repeatedCharacters[i]%3<value%3:
                            pos=i
                            value=repeatedCharacters[i]

                if value%3==0:
                    if extra-1>=0:
                        repeatedCharacters[pos]-=1
                        extra-=1
                        totalchanges+=1
                    else:
                        break
                elif value%3==1:
                    if extra-2>=0:
                        repeatedCharacters[pos]-=2
                        extra-=2
                        totalchanges+=2
                    else:
                        break
                elif value%3==2:
                    if extra-3>=0:
                        repeatedCharacters[pos]-=3
                        extra-=3
                        totalchanges+=3
                    else:
                        break
                if countUnique>=len(repeatedCharacters):
                    break
            totalRepeats=0
            for number in repeatedCharacters:
                if number>=3:
                    totalRepeats+=int(number/3)
            first=totalchanges+extra
            second=totalRepeats if totalRepeats>cases else cases
            result=int(first+second)

            return result",0
"class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32)[::-1]:
            ans <<= 1
            prefix = {num >> i for num in nums}
            ans += any(ans^1^p in prefix for p in prefix)
        return ans",1
"class Solution:
    def originalDigits(self, s: str) -> str:
        freq = Counter(s)
        nums = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""]
        
        ans = [0]*10
        for c, i in (""g"", 8), (""u"", 4), (""w"", 2), (""x"", 6), (""z"", 0), (""s"", 7), (""v"", 5), (""h"", 3), (""i"", 9), (""o"", 1): 
            ans[i] = freq[c]
            freq -= Counter(nums[i]*freq[c])
        return """".join(sorted(str(i)*x for i, x in enumerate(ans)))",0
"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        res = 0
        left = 0
        count = {}
        maxf = 0
        for right in range(len(s)):
            count[s[right]] = 1 + count.get(s[right],0)
            maxf = max(maxf, count[s[right]])
    
            while (right-left+1) - maxf > k:
                count[s[left]] -= 1
                left+=1
            res = max(res, right-left+1)
        return(res)",1
"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        if not grid:
            return
        node = Node()
        grid_sum, n = sum(map(sum, grid)), len(grid)
        if grid_sum == (n * n) or grid_sum == 0:
            node.val, node.isLeaf = grid_sum // (n * n), True
            return node
        node.isLeaf, node.val = False, 1
        node.topLeft = self.construct([[j for j in i[:n//2]] for i in grid[:n//2]])
        node.topRight = self.construct([[j for j in i[n//2:]] for i in grid[:n//2]])
        node.bottomLeft = self.construct([[j for j in i[:n//2]] for i in grid[n//2:]])
        node.bottomRight = self.construct([[j for j in i[n//2:]] for i in grid[n//2:]])
        return node",0
"class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return None
        
        queue = collections.deque([root])
        res = []
        
        while queue:
            i, l = 0, len(queue)                # l is the number of nodes in current level
            temp_res = []                       # temp_res record node.val at current level
            
            while i < l:                        # i: to iterate through this level
                cur = queue.popleft()
                temp_res.append(cur.val)
                for c in cur.children:          
                    queue.append(c)
                i += 1
            res.append(temp_res)                # After dealing a level, add temp_res which recorded current level to final res
        
        return res",1
"class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        if head is None:
            return None

        return self.dfs(head)

    def dfs(self, node):
        original_next = node.next
        tail = node

        if node.child:
            node.next = self.dfs(node.child)
            node.next.prev = node
            node.child = None
            tail = node.next
            while tail.next:
                tail = tail.next

        if original_next:
            tail.next = self.dfs(original_next)
            tail.next.prev = tail

        return node",1
"class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        res = []
        def is_valid_mutate(a, b):
            return sum(1 if a[i] != b[i] else 0 for i in range(len(a))) == 1
        
        def helper(start, bank, count, res):
            if not bank:
                return
            
            for i in range(len(bank)):
                curr = bank[i]
				# curr gene can be mutated from start
                if not is_valid_mutate(curr, start):
                    continue
                
				# we found the mutation from curr to end
                if curr == end:
                    res.append(count + 1)
                    return
                # we put leftover gene bank without curr 
                # and see our curr gene as start can be mutate to leftover gene bank
                helper(curr, bank[:i] + bank[i+1:], count + 1, res)
                    
        helper(start, bank, 0, res)
        return min(res) if res else -1",0
"class Solution:
    def countSegments(self, s: str) -> int:
        count = 0
        for i in range(len(s)):
            if s[i] != "" "" and (i==0 or s[i-1]== "" ""):
                count+=1

        return count",1
"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # removing minimum number of intervals is equivalent to
        # keeping the maximum number of intervals, which can be
        # solved greedily. We can sort by finish time and schedule by
        # earliest non-conflicting finish time to leave for more space
        # for subsequent intervals.
        intervals.sort(key = lambda x: x[1])
        n_keep, prev_end = 1, intervals[0][1]
        for i in range(1, len(intervals)):
            cur_start, cur_end = intervals[i]
            if cur_start >= prev_end:
                n_keep += 1
                prev_end = cur_end
        return len(intervals)-n_keep",0
"class Solution:
    def findRightInterval(self, I: List[List[int]]) -> List[int]:
        N, S, A, D, k = len(I), sorted(i[0] for i in I), [-1]*len(I), {j[0]:i for i,j in enumerate(I)}, 0
        for L,R in sorted(I, key = lambda x: x[1]):
            k = bisect.bisect_left(S,R,k)
            if k < N: A[D[L]] = D[S[k]]
        return A
		
		
- Junaid Mansuri",0
"class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        cnt = 0
        if not root:
            return cnt
        
        def counter(n: TreeNode, s=0):
            nonlocal cnt
            if not n:
                return
            s += n.val
            if s == targetSum:
                cnt += 1
            counter(n.left, s)
            counter(n.right, s)
                        
        def dfs(n: TreeNode):
            if not n:
                return
            counter(n)
            dfs(n.left)
            dfs(n.right)
        
        dfs(root)
        return cnt",1
"class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def fn(x): 
            """"""Return node counts in denary trie.""""""
            ans, diff = 0, 1
            while x <= n: 
                ans += min(n - x + 1, diff)
                x *= 10 
                diff *= 10 
            return ans 
        
        x = 1
        while k > 1: 
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10 
        return x",1
"class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        nums.sort()
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                res.append(nums[i])
        return res",1
"class Solution:
    def compress(self, C: List[str]) -> int:
    	if len(C) <= 1: return
    	c, i, _ = 1, 0, C.append("" "")
    	while C[i] != "" "":
    		if C[i] == C[i+1]: c += 1
    		elif c > 1: C[i+2-c:i+1], i, c = list(str(c)), i + 1 - c + len(list(str(c))), 1
    		i += 1
    	del C[-1]
			

- Junaid Mansuri",1
"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        result = self.getNumberByIterList(l1) + self.getNumberByIterList(l2)
        divisor = 10
        if result == 0:
            return ListNode(0)
        head, prev = None, None
        while result > 0:
            result, remainder = divmod(result, divisor)
            head = ListNode(remainder, prev)
            prev = head
        return head

    
    def getNumberByIterList(self, li):
        number = 0 
        while li is not None:
            number = number * 10 + li.val
            li = li.next
        return number",0
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        dp = [defaultdict(int) for _ in range(len(nums))]
        res = 0
        for i in range(len(nums)):
            for j in range(i):
                dp[i][nums[i] - nums[j]] += dp[j][nums[i] - nums[j]] + 1
                res += dp[j][nums[i] - nums[j]]
        return res",1
"class Solution:
    def dist(self, p1, p2):
        return sqrt(pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2))
    
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        res = 0
        
        for i in range(len(points)):
            ""cache for every point""
            dist_cache = collections.defaultdict(int)
            
            for j in range(len(points)):
                if i == j:
                    continue
                    
                dist_cache[self.dist(points[i], points[j])] += 1
            
            
            for key in dist_cache:
                """"""
                The formula for generating permutations given n object where we are allowed to choose r of them, is: P(n, r) = n! / (n-r)! 
                In our case we have: n = dist_cache[key] (where key is some distance). Also we can choose 2 elements at a time: r = 2. So formula now: P(n, 2) = n! / (n-2)!
                Using some mathematical transformations: n! / (n-2)! = n * (n-1) * (n-2)! / (n-2)! = n * (n-1)
                This logic applies to each point.
                """"""
                res += dist_cache[key] * (dist_cache[key] - 1)
        
        return res",0
"class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        return {x for x in range(1,len(nums)+1)} - set(nums)",0
"class Solution:    
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == key:
            # first case - no childrens
            if not root.left and not root.right:
                return None
            
            # second case - there is one of chlidren (left or right)
            if not root.left:
                return root.right
            
            if not root.right:
                return root.left
            
            # third case - there are both childrens (left and right)
            tmp = root.left
            while tmp.right:
                tmp = tmp.right
            
            root.val = tmp.val
            root.left = self.deleteNode(root.left, root.val)
            
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root",1
"class Solution:
    def frequencySort(self, s: str) -> str:
        a = Counter(s)
        b = """"
        abc = sorted(a, reverse = True,  key = a.get)
        for i in abc:
            for j in range(a[i]):
                b+=i
        return b",1
"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for x, y in sorted(points, key=lambda x: x[1]): 
            if prev < x: 
                ans += 1
                prev = y
        return ans",1
"class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums) - min(nums)*len(nums)",1
"class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        AB = [a+b for a in A for b in B]
        CD = [c+d for c in C for d in D]
                
        # Two sum from AB and CD
        counts = 0
        CD_count = collections.Counter(CD)
        for num in AB:
            counts += CD_count.get(-num, 0)
                
        return counts",1
"class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i = j = 0
        out = 0
        while i < len(g) and j < len(s):
            if g[i] <= s[j]:
                i += 1
                out += 1
            j += 1
        return out",1
"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        prev_greater = [-1] * len(nums)
        stack = []
        for i, n in enumerate(nums):
            # Use >= so that PGE is strictly greater as opposed to greater or equal
            while stack and n >= nums[stack[-1]]:
                stack.pop()
            if stack:
                prev_greater[i] = stack[-1]
            stack.append(i)
            
        mins = [0]
        for i in range(1, len(nums)):
            mins.append(mins[-1])
            if nums[i] < nums[mins[-1]]:
                mins[-1] = i
            
        for i in range(1, len(nums)):
            if ((pg := prev_greater[i]) != -1 and
                nums[mins[pg]] < nums[i] and # nums[i] < nums[pg] by the definition of PGE
                mins[pg] != pg): # mins[pg] <= pg, so only need to check if mins[pg] != pg
                return True
        return False",0
"class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        seen = set() # visited &amp; no cycle 
        for i, x in enumerate(nums): 
            if i in seen: continue 
            temp = set() # visited in this round 
            while True: 
                ii = (i + nums[i])% len(nums)
                if ii in seen or nums[ii] * x < 0 or ii == i: # no cycle 
                    seen |= temp 
                    break 
                if ii in temp and ii != i: return True 
                temp.add(i := ii)
        return False",0
"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs",0
"class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        a = s[0]
        x = len(s)
        for i in range(1,len(s)):
            if a == s[i:i+len(a)]:
                c = int(len(s)/len(a))
                if a * c == s:
                    return True
            else:
                pass
            a += s[i]
        return False",1
"class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
    	xb, yb = bin(min(x,y))[2:], bin(max(x,y))[2:]
    	return list(yb[:(len(yb)-len(xb))]).count('1') + sum([1 for i in range(len(xb)) if xb[-1-i] != yb[-1-i]])
		
		
- Junaid Mansuri",1
"class Solution:
    def minMoves2(self, n: List[int]) -> int:
    	return (lambda x,y: sum(abs(i-x[y]) for i in x))(sorted(n), len(n)//2)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        
            p = 0
            for i in range(len(grid)):
                for j in range(len(grid[i])):
                    if grid[i][j]:
                        p += 4 - (i and grid[i-1][j])*2 - (j and grid[i][j - 1])*2
            return p",1
"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:

        @lru_cache(maxsize=None)
        def can_win(choices, remainder):
            if choices[-1] >= remainder: return True

            for index in range(len(choices)):
                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]): return True

            return False

        summed_choices =  maxChoosableInteger * (maxChoosableInteger + 1) / 2
        if summed_choices < desiredTotal: return False
        if summed_choices == desiredTotal: return maxChoosableInteger % 2

        return can_win(tuple(range(1, maxChoosableInteger + 1)), desiredTotal)",0
"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        cnt = idx = 0 
        count = []
        index = []
        for i in range(n1): 
            for ch in s1: 
                if ch == s2[idx]: 
                    idx += 1
                    if idx == len(s2): 
                        cnt += 1
                        idx = 0 
            count.append(cnt)
            index.append(idx)
            for ii in range(i): 
                if index[ii] == idx: 
                    prev = count[ii]
                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))
                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]
                    return (prev + repeat + post) // n2
        return count[-1]//n2",0
"class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        dp=[0 for i in range(26)]
        if p=="""":
            return 0
        count=1
        pre=ord(p[0])-ord('a')
        dp[pre]=1
        for i in p[1:]:
            cur=ord(i)-ord('a')
            if (pre+1)%26==cur:
                count+=1
                dp[cur]=max(dp[cur],count)
            else:
                count=1
                dp[cur]=max(dp[cur],count)
            pre=cur
        return sum(dp)",1
"class Solution:
    def validate_ipv4(self,IP:str)->str:
        for x in IP.split("".""):
            if len(x)==0 or len(x)>3: return ""Neither""
            if not x.isdigit() or not 0<=int(x)<=255 or (x[0]==""0"" and len(x)!=1): return ""Neither""
        return ""IPv4""
    
    def validate_ipv6(self,IP:str)->str:
        hex_digits=""0123456789abcdefABCDEF""
        for x in IP.split("":""):
            if len(x)==0 or len(x)>4 or not all(c in hex_digits for c in x): return ""Neither""
        return ""IPv6"" 
        
    def validIPAddress(self, IP: str) -> str:
        """"""
        O(n) time complexity
        O(1) space complexity
        """"""
        if ""."" in IP and IP.count(""."")==3:
            return self.validate_ipv4(IP)
        elif "":"" in IP and IP.count("":"")==7:
            return self.validate_ipv6(IP)
        else:
            return ""Neither""",0
"class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        
        wordset = set(words)
        
        @cache
        def f(word,i):
            if i >= len(word):
                return True
            j = i+1
            while j <= len(word):
                if word[i:j] in wordset and j-i != len(word) and f(word,j):
                    return True
                j += 1
            return False
        
        return [word for word in words if any(word) and f(word,0)]",1
"class Solution:
    def makesquare(self, matchsticks) -> bool:
        total_circumference = sum(matchsticks)
        side = total_circumference/4

        if int(side) != side:
            return False
			
        matchsticks.sort()
        
        paths = [0]*4
        h = {}
		
        if matchsticks[-1] > side:
            return False
        
        def r():
            if not matchsticks:
                return True

            num = matchsticks.pop()

            ret = False
            for x in range(4):
                if paths[x] + num <= side:
                    paths[x] += num
                    ret |= r()
                    if ret:
                        return True
                    paths[x] -= num
                    if not paths[x]:
                        break

            matchsticks.append(num)
            return ret
        return r()",1
"class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        arr = sorted([(len(i), sum([1 for j in i if j == '0'])) for i in strs])
        arr = [(i[1], i[0]-i[1], i[0]) for i in arr] # N0, N1, len
        
        ptr = 0
        larr = len(arr)
        print(larr)
        memo = {}

        def dfs(n0: int, n1: int, ptr: int):
            # print((n0, n1, ptr))
            if (n0, n1, ptr) in memo:
                return memo[(n0, n1, ptr)]

            if ptr == larr:
                return 0

            if n0 + n1 < arr[ptr][2]:
                return 0
            
            nextp = ptr + 1

            if not (n0 >= arr[ptr][0] and n1 >= arr[ptr][1]):
                return dfs(n0, n1, nextp)

            take = 1 + dfs(n0 - arr[ptr][0], n1 - arr[ptr][1], nextp)

            if arr[ptr][2] == 1:
                ntake = 0
            else:
                ntake = dfs(n0, n1, nextp)

            ans = take if take > ntake else ntake
            memo[(n0,n1,ptr)] = ans
            return ans
        
        return dfs(m, n, 0)",0
"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high",0
"class Solution:
    def findComplement(self, num: int) -> int:
        return int("""".join([""1"" if i == ""0"" else ""0"" for i in list(bin(num))[2:]]),2)",0
"class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        nums_len = len(nums)
        
        
        if (nums_len == 0):
            return 0
        
        current_bit = 1
        ret = 0
        max_ = max(nums) 

                
        while (current_bit <= max_):
            counter = 0
            
            
            for number in nums:
                if (number &amp; current_bit):
                    counter += 1
                    
            ret += counter * (nums_len - counter)
            current_bit <<= 1
            
        return ret",1
"class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius 
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self) -> List[float]:
        radius = self.radius*sqrt(random.random()) # sample radius as r*sqrt(x) 
        theta = 2*pi*random.random() # sample angle as unif [0, 2*pi) 
        return self.x_center + radius*cos(theta), self.y_center + radius*sin(theta)",1
"class Solution:
    def largestPalindrome(self, n: int) -> int:
        return [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]

        
    def isPalindrome(x):
        return str(x) == str(x)[::-1]

    def solve(n):
        best = 0
        for i in range(10**n-1, 0, -1):
            for j in range(max(i, (best-1)//i+1), 10**n):
                if isPalindrome(i*j):
                    #print(i, j, i*j)
                    best = i*j
        return best",1
"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        
        # Init
        medians = []
        n = len(nums)
        
        # Make median indexes
        m1,m2 = (k//2,k//2) if k%2 else ((k//2)-1,k//2)
       
        # Sort the array and find the first median
        arr = sorted(nums[:k])
        medians.append(float((arr[m1] + arr[m2])/2))
        
        # Find rest medians
        for i in range(0,n-k): 
            arr.remove(nums[i])
            bisect.insort(arr, nums[i+k])
            medians.append(float((arr[m1] + arr[m2])/2))
        
        # return
        return medians",1
"class Solution:
    def magicalString(self, n: int) -> int:
        if n==0: return 0
        if n<=3: return 1
        s,index = [1,2,2],2
        while len(s)<n:
            s+=[3-s[-1]]*s[index]
            index+=1
        return s[:n].count(1)",1
"class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -> str:
    	S = """".join([i for i in S if i != '-']).upper()
    	L = len(S)
    	t = L%K
    	if t == 0:
    		t = K
    	T = S[0:t] + '-'
    	for i in range(t,L,K):
    		T = T + S[i:i+K] + '-'
    	return(T[0:-1])
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def smallestGoodBase(self, n: str) -> str:
        n = int(n)
        for p in range(int(log2(n)), 1, -1): 
            k = int(n**(1/p))
            if (k**(p+1)-1)//(k-1) == n: return str(k)
        return str(n-1)",1
"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        l, output = 0,0
        
        for r, number in enumerate(nums):
            
            if number == 0:
                l = r+1
            
            output = max(output, r-l+1)
        
        return output",1
"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:
        
        N = len(nums)
        if N % 2 == 0: return True # can always win by picking larger one of odd or even subarray
        
		# DP
        dp = nums[:]
        for i in range(1, N):
            for j in range(N - i):
                dp[j] = max(nums[j] - dp[j + 1], nums[j + i] - dp[j])
        
        return dp[0] >= 0",1
"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        hand = ''.join(sorted(hand))
        
        @cache
        def fn(board, hand):
            """"""Return min number of balls to insert.""""""
            if not board: return 0
            if not hand: return inf 
            ans = inf 
            for i, ch in enumerate(hand): 
                if i == 0 or hand[i-1] != ch: # pruning 1
                    hh = hand[:i] + hand[i+1:]
                    for j in range(0, len(board)): 
                        if ch == board[j] or j and board[j-1] == board[j]: # pruning 2
                            bb, nn = """", board[:j] + ch + board[j:]
                            while bb != nn:
                                bb, nn = nn, """"
                                for k, grp in groupby(bb): 
                                    x = len(list(grp))
                                    if x < 3: nn += k*x
                            ans = min(ans, 1 + fn(bb, hh))
            return ans 
        
        return (lambda x: x if x < inf else -1)(fn(board, hand))",0
"class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        for i in range(2, len(nums)+1):
            for x in set(itertools.combinations(nums, i)):
                if all(a <= b for a, b in zip(x, x[1:])):
                    res.append(x)
        return res",1
"class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        sqrt_val = int(math.sqrt(area))
        l = w = sqrt_val
        while (l * w) != area and l > 0 and w > 0:
            l += 1
            w = area // l
            
        return [l, w] if w > 1 else (area, 1)",1
"class Solution(object):
    def reversePairs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def merge(array,start,mid,end):
            leftArray=array[start:mid+1]
            rightArray=array[mid+1:end+1]
            i,j=0,0
            m,n=len(leftArray),len(rightArray)
            for k in range(start,end+1):
                if j>=n or (i<m and leftArray[i]<rightArray[j]):
                    array[k]=leftArray[i]
                    i+=1
                else:
                    array[k]=rightArray[j]
                    j+=1
        def merge_sort(array,start,end):
            pairs=0
            if start<end:
                mid=start+(end-start)//2
                pairs+=merge_sort(array,start,mid)
                pairs+=merge_sort(array,mid+1,end)
                j=mid+1
                for i in range(start,mid+1):
                    while j<=end and array[i]>array[j]*2:
                        j+=1
                    pairs+=j-mid-1
                merge(array,start,mid,end)
            return pairs
        pairs=merge_sort(nums,0,len(nums)-1)
        return pairs",0
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def findtarget(nums,currsum, length,target,memo):
            if((length,currsum) in memo):
                return memo[(length,currsum)]
            if(length == len(nums)):
                if(currsum == target):
                    memo[(length,currsum)] = 1
                    return 1
                else:
                    memo[(length,currsum)] = 0
                    return 0
            memo[(length,currsum)] = findtarget(nums,currsum+nums[length],length+1,target,memo)+findtarget(nums,currsum-nums[length],length+1,target,memo)
            return memo[(length,currsum)]
        return findtarget(nums,0,0,target,{})",0
"class Solution:
    def findPoisonedDuration(self, t: List[int], duration: int) -> int:
        if not t:
            return 0
        n = len(t)
        return sum(min(t[t2] - t[t1], duration) for t1, t2 in zip(range(0, n - 1), range(1, n))) + duration",1
"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        dict_greater = {}

        stack = [nums2[0]]
        for num in nums2[1:]:

            if num < stack[-1]:
                stack.append(num)

            while len(stack) > 0 and num > stack[-1]:
                dict_greater[stack.pop()] = num
            stack.append(num)

        while len(stack) > 0:
            dict_greater[stack.pop()] = -1

        return [dict_greater[j] for j in nums1 if j in dict_greater]",1
"class Solution:

    def __init__(self, rects: List[List[int]]):
        self.rects = rects # store rectangles
        self.wt = [0] # weighted sampling 
        for x1, y1, x2, y2 in rects: 
            wt = (x2 - x1 + 1) * (y2 - y1 + 1) # wt ~ number of points 
            self.wt.append(self.wt[-1] + wt) 

    def pick(self) -> List[int]:
        n = randint(1, self.wt[-1]) # nth point
        k = bisect_left(self.wt, n)-1 # kth rectangle
        offset = n - self.wt[k] - 1 # offset from x1, y1
        x1, y1, x2, _ = self.rects[k]
        return [x1 + offset % (x2 - x1 + 1), y1 + offset // (x2 - x1 + 1)]",0
"class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix: return []
        temp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if len(temp)-1<i+j: temp.append([matrix[i][j]])
                else: temp[i+j].append(matrix[i][j])
        res,i = [],0
        for item in temp:
            if i%2==0: res += item[::-1]
            else: res += item
            i += 1
        return res",0
"class Solution:
    def findWords(self, w: List[str]) -> List[str]:
    	L = [set('qwertyuiop'),set('asdfghjkl'),set('zxcvbnm')]
    	D, A = {j:i for i in range(3) for j in L[i]}, []
    	for i,j in enumerate([i.lower() for i in w]):
    		if set(j).issubset(L[D[j[0]]]): A.append(w[i])
    	return A
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        dic = dict()
        if root is None:
            return []
        def inorder(root,dic):
            if root is None:
                return
            else:
                left = inorder(root.left,dic)
                if root.val in dic:
                    dic[root.val] += 1
                else:
                    dic[root.val] = 1
                
                right = inorder(root.right,dic)
                
            return dic
        dic = inorder(root,dic)
        max_val = float('-inf')
        val = 0
        lis = []
        for key,value in dic.items():
            if value == max_val:
                val = key
                lis.append(val)
            elif value > max_val:
                lis = []
                max_val = value
                val = key
                lis.append(val)
	```",0
"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        projects = sorted([(c, p) for p, c in zip(profits, capital)])
        i, N = 0, len(projects)
        profits_maxheap = []
        cur_capital = w
        while k > 0:
            while i < N and cur_capital >= projects[i][0]:
                heapq.heappush(profits_maxheap, -projects[i][1])
                i += 1
            if not profits_maxheap:
                break
            cur_capital -= heapq.heappop(profits_maxheap)
            k -= 1
        return cur_capital",0
"class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        old_len = len(nums)
        
        nums += nums
        
        res = [-1] * len(nums)
        for idx in range(len(nums) -1, -1, -1):
            while stack and nums[idx] >= stack[-1]:
                stack.pop()
            
            if stack:
                res[idx] = stack[-1]
            
            stack.append(nums[idx])
        
        return res[:old_len]",1
"class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return str(num)
        res = ''
        x = abs(num)
        while x > 0:
            res = str(x%7) + res
            x //= 7
        return '-' + res if num < 0 else res",1
"class Solution:
    def findRelativeRanks(self, nums: List[int]) -> List[str]:
        awarded_medals = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""]
        nums_with_indx = sorted([(i, s) for i, s in enumerate(nums)], key=lambda t: t[1], reverse=True)
        for rank, t in enumerate(nums_with_indx):
            pos, score = t
            nums[pos] = awarded_medals[rank] if rank < 3 else str(rank + 1)
        
        return nums",0
"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
    	if num <= 1: return False
    	s, q = 0, num**.5
    	for i in range(2,1+int(q)):
    		if num%i == 0: s += i + num//i
    	if int(q) == q: s -= int(q)
    	return s == num - 1
		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def traversal(self, node, d, max_freq):
        if node == None:
            return 0
        
        _sum = self.traversal(node.left, d, max_freq) + self.traversal(node.right, d, max_freq) + node.val

        d[_sum] = d.get(_sum, 0) + 1
        
        max_freq[0] = max(max_freq[0], d[_sum])
        
        return _sum
        
        
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        d = {}
        max_freq = [0]
        
        self.traversal(root, d, max_freq)

        ans = []
        for key in d:
            if d[key] == max_freq[0]:
                ans.append(key)
        
        return ans",1
"class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        fibs = [0,1]
        for i in range(2, n+1):
            fibs.append(fibs[-1] + fibs[-2])


        return fibs[-1]",1
"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)",0
"class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        levels = {}
        def dfs(node, level):
            if not node:return
            if level not in levels.keys():levels[level] = [node.val]
            else:levels[level].append(node.val)
            if node.right:dfs(node.right, level+1)
            if node.left:dfs(node.left, level+1)
        dfs(root, 1)
        return ([max(value) for value in levels.values()])",0
"class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        memo = {}
        
        def helper(s: str, i: int, j:int, memo: dict):
            if (i,j) in memo:
                return memo[(i,j)]
            
            if i==j:
                memo[(i,j)] = 1
                return 1
            
            if i>j:
                memo[(i,j)] = 0
                return 0
            
            if s[i] == s[j]:
                sub = helper(s, i+1, j-1, memo)
                memo[(i+1,j-1)] = sub
                return sub + 2
            
            left = helper(s, i, j-1, memo)
            memo[(i,j-1)] = left
            right = helper(s, i+1, j, memo)
            memo[(i+1,j)] = right
            return max(left, right)
        
        return helper(s, 0, len(s)-1, memo)",0
"class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        total = sum(machines)
        if total % len(machines): return -1 # impossible 
        avg = total // len(machines)
        
        ans = prefix = 0
        for i, x in enumerate(machines): 
            ans = max(ans, abs(prefix), x - avg)
            prefix += x - avg
        return ans",1
"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [[0] * (amount + 1) for i in range(len(coins) + 1)]
        for i in range(len(coins) + 1):
            for j in range(amount + 1):
                if j == 0:
                    dp[i][j] = 1
                elif i == 0:
                    dp[i][j] = 0
        for i in range(1 , len(coins) + 1):
            for j in range(1 , amount + 1):
                if coins[i - 1] <= j:
                    dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i - 1]]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]",0
"class Solution:

    def __init__(self, m: int, n: int):
        self.cols = n
        self.nums = m * n
        
        self.tail = self.nums - 1
        self.indexes = {}
        

    def flip(self) -> List[int]:
        ind = random.randint(0, self.tail)
        rc = self.indexes.get(ind, ind)
        self.indexes[ind] = self.indexes.get(self.tail, self.tail)
        self.tail -= 1
        
        return [rc // self.cols, rc % self.cols]
        

    def reset(self) -> None:
        self.tail = self.nums - 1
        self.indexes = {}",1
"class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        if len(a) != len(b):
            return max(len(a), len(b))
        return -1 if a == b else len(a)",1
"class Solution:
    def findLUSlength(self, strs: List[str]) -> int:
        
        def fn(p, s):
            """"""Return True if p is a subsequence of s.""""""
            ss = iter(s)
            return all(ch in ss for ch in p)
        
        ans = -1 
        for i, s in enumerate(strs): 
            for ii in range(len(strs)): 
                if i != ii and len(s) <= len(strs[ii]) and fn(s, strs[ii]): break 
            else: ans = max(ans, len(s))
        return ans",1
"class Solution:
    def checkSubarraySum(self, N: List[int], K: int) -> bool:
    	L, S, s = len(N), set([0]), 0
    	for i in range(L-1):
    		if (N[i]+N[i+1]) == 0 or (K and not (N[i]+N[i+1]) % K): return True
    	if K == 0: return False
    	for n in N:
    		a, s = s, (s + n) % K
    		if s in S and a != s: return True
    		else: S.add(s)
    	return False
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        def isSubsequence(a: str, b: str) -> bool:
            i = 0
            for c in a:
                if (i := b.find(c, i)) == -1:
                    return False
                i += 1
            return True
        
        heap = [(-len(word), word) for word in d]
        heapq.heapify(heap)
        while heap:
            word = heapq.heappop(heap)[1]
            if isSubsequence(word, s):
                return word
        return ''",1
"class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        acc = 0  # Stores the value for the current position in the nums

        # Why we have diff_dict?
        # we need to know how many elements before we had the difference value matching the current value at question

        # Example:
        # If at any point we have {0: 15, -1: 14, -2: 13}
        # and we have the acc as -1 on the 16th index, then the sequence must have been
        # 13 14 15 16
        # 1  1  1  0
        # Thus there is a combination that is valid between indexes 15-16
        # Next, if the acc is -2 on 16th index, then the sequence must have been
        # 13 14 15 16 17
        # 1  1  1  0  0
        # Thus there is a larger combination between indexes 14-17
        diff_dict = {0: -1}  # we have -1 here to make start index count
        # if we wouldn't the first starting value wouldn't be included in the calculation

        max_length = 0  # This stores the maximum value result
        for index, num in enumerate(nums):

            # FYI: To make negation of summation work we are saying that 0 is actually -1
            # (we could have easily said 1 is 2 and 0 is -2)
            # The important thing here is that we have something that we can use to count the discrepency.
            if num == 1:
                acc += 1
            else:
                acc -= 1

            if acc in diff_dict:  # There is a specific index that provides the longest subarray with the current acc
                length = index - diff_dict[acc]
                # Thus current index - first index to provide the same difference
                # is the maximum length for an array including the current index
                max_length = max(max_length, length)
            else:
                # We have never encountered an index with such a difference between values,
                # let's just store it for now.
                # If in the future we encounter another one, we will use this as the first one and calculate maximum
                # If the question were to ask for the minimum,
                # then we would update the dict with the newest index independent of whether it exists or not
                diff_dict[acc] = index
        return max_length",0
"class Solution:
    def countArrangement(self, N: int) -> int:        
        n_list = [i+1 for i in range(N)]

        a = 0
        def search_ba(rest_ns, curr_ns):
            if not rest_ns:
                # Found beautiful arrangement
                nonlocal a
                a +=1
                return

            i = len(curr_ns) + 1
            for j in range(len(rest_ns)):
                n = rest_ns[j]
                if (n % i)==0 or (i % n)==0:
                    # Found number from `rest_ns` fit for next position of `curr_ns`
                    search_ba(rest_ns[:j]+rest_ns[j+1:], curr_ns + [n])


        search_ba(n_list, [])
        return a",1
"class Solution:

    def __init__(self, w: List[int]):
        self.prefix = [0]
        for x in w: self.prefix.append(self.prefix[-1] + x)

    def pickIndex(self) -> int:
        r = randint(1, self.prefix[-1])
        return bisect_left(self.prefix, r)-1",1
"class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        i, j = click[0], click[1]
        
        # If a mine ('M') is revealed, then the game is over - change it to 'X'.
        if board[i][j] == ""M"":
            board[i][j] = ""X""
        # Else, proceed to *reveal* it.
        else:
            self.reveal(board, i, j)
        
        # Return the updated board.
        return board
    # End of updateBoard(...)
        
        
    def reveal(self, board, i, j):
        
        # We only need to check if the point on the board is an ""E'""
        if board[i][j] == ""E"":
            
            # Count number of adjacent mines
            n_adj_mines = self.countAdjMine(board, i, j)
            
            # If an empty square ('E') *with no adjacent mines is revealed*...
            if n_adj_mines == 0:
                
                # Then change it to revealed blank ('B')...
                board[i][j] = ""B""
                
                # ... and all of its adjacent unrevealed squares should be revealed recursively.
                for di, dj in [(1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1)]:
                    newi, newj = i+di, j+dj
                    if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                        self.reveal(board, newi, newj)
            
            # Else, if an empty square ('E') with at least one adjacent mine is revealed...
            else:
                # If the point contains a digit, we update the digit.
                if board[i][j].isdigit():
                     board[i][j] = str(int(board[i][j]) + n_adj_mines)
                
                # Else if the point is not a digit, we fill it with the digit that
                # represents the number of adjacent mines
                else:
                    board[i][j] = str(n_adj_mines)
    # End of reveal(...)
    
            
    # Helper function to count adjacent mines
    def countAdjMine(self, board, i, j):
        count = 0
        for di, dj in [(1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1)]:
            newi, newj = i+di, j+dj
            if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                if board[newi][newj] == ""M"":
                    count += 1
        return count
    # End of helpr function to count adj mines.",0
"class Solution(object):
    def getMinimumDifference(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""

        def get_values(values, root):
            if root is not None:
                values.append(root.val)
                values = get_values(values, root.left)
                values = get_values(values, root.right)
            return values

        values_list = get_values([], root)

        if len(values_list) != len(set(values_list)):
            return 0

        values_list.sort()
        minimum_diff = values_list[1] - values_list[0]

        for i in range(1, len(values_list)):
            diff = values_list[i] - values_list[i - 1]
            if diff < minimum_diff:
                minimum_diff = diff

        return minimum_diff",1
"class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        ans, seen = set(), set()
        for x in nums: 
            if x - k in seen: ans.add(x)
            if x + k in seen: ans.add(x+k)
            seen.add(x)
        return len(ans)",1
"class Solution:
    def complexNumberMultiply(self, a: str, b: str) -> str:
        k1=a.split('+')
        k2=b.split('+')
        (xa,ya)=(k1[0],k1[1][:-1])
        (xb,yb)=(k2[0],k2[1][:-1])
        return(str(int(xa)*int(xb)+int(ya)*int(yb)*-1)+'+'+str(int(xa)*int(yb)+int(ya)*int(xb))+'i')",0
"class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        val = 0
        node, stack = root, []
        while stack or node: 
            if node: 
                stack.append(node)
                node = node.right
            else: 
                node = stack.pop()
                node.val = val = node.val + val 
                node = node.left 
        return root",1
"class Solution:
    def time2min(self, t):
        return int(t[:2]) * 60 + int(t[3:])
    
    def findMinDifference(self, timePoints: List[str]) -> int:
        
        new = [self.time2min(t) for t in timePoints]
        new.sort()
        offset = 60*24
        new.extend([n+offset for n in new])
        
        diff = []
        for i in range(len(new)-1):
            diff.append(new[i+1] - new[i])
        
        return min(diff)",1
"class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        return self.helper(nums)
    
    def helper(self, nums):
        if len(nums)==1:
            return nums[0]
        mid = len(nums)//2
        if nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:
            return nums[mid]
        else:
            if mid%2==0:
                if nums[mid]==nums[mid-1]:
                    return self.helper(nums[:mid-1])
                else:
                    return self.helper(nums[mid:])
            else:
                if nums[mid]==nums[mid-1]:
                    return self.helper(nums[mid+1:])
                else:
                    return self.helper(nums[:mid])",0
"class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        res = ''
        for i in range(len(s)//(2*k)):
            res += s[2*k*i:2*k*i+k][::-1] + s[2*k*i+k:2*k*(i+1)]
        
        remainder = len(s) % (2*k)
        
        if remainder <= k and remainder > 0:
            res += s[-remainder:][::-1]
        elif remainder > k:
            res += s[-remainder:-remainder+k][::-1] + s[-remainder+k:]
        
        return res",0
"class Solution:
    def updateMatrix(self, A: List[List[int]]) -> List[List[int]]:
    	M, N, Q = len(A), len(A[0]), []
    	B = [[0]*N for _ in range(M)]
    	for i,j in itertools.product(range(M),range(N)):
    		if not A[i][j]: continue
    		b = 1
    		for k,l in [[i-1,j],[i,j+1],[i+1,j],[i,j-1]]:
    			if not (k in [-1,M] or l in [-1,N] or A[k][l]): B[i][j], b = 1, 0
    		if b: Q.append((i,j))
    	for a in range(2):
	    	for i,j in Q:
	    		m = math.inf
	    		for k,l in [[i-1,j],[i,j+1],[i+1,j],[i,j-1]]:
	    			if not (k in [-1,M] or l in [-1,N]) and B[k][l] > 0: m = min(m,B[k][l])
	    		if m != math.inf: B[i][j] = m + 1
    		if a == 1: return B
    		Q.reverse()
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        return self.dfs(root)[1]
    
    def dfs(self, root):
        if not root:
            return 0, -sys.maxsize
        l_depth, l_diameter = self.dfs(root.left)
        r_depth, r_diameter = self.dfs(root.right)
        
        return max(l_depth, r_depth) + 1, max(l_diameter, r_diameter, l_depth + r_depth)",1
"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)",0
"class Solution:
    
    def find(self, x: int) -> int:
        """"""
        C = cities
        
        Time: O(1) amortized time
        """"""
        if self.parents[x] != x:
            self.parents[x] = self.find(self.parents[x])
        return self.parents[x]

    def union(self, x: int, y: int) -> bool:
        """"""
        C = cities
        
        Time: O(1) amortized time
        """"""
        x_rep = self.find(x)
        y_rep = self.find(y)
        
        if x_rep == y_rep:
            return False
        
        if self.ranks[x_rep] > self.ranks[y_rep]:
            self.parents[y_rep] = x_rep
        elif self.ranks[x_rep] < self.ranks[y_rep]:
            self.parents[x_rep] = y_rep
        else:
            self.parents[y_rep] = x_rep
            self.ranks[x_rep] += 1
            
        return True
        
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        """"""
        C = number of cities
        
        Time: O(C^2)
        - We go over each C^2 pair. The union for each operation is O(1) amortized.
        
        Space: O(2C + logC) = O(C)
        - We keep track of C parents and ranks
        - The find operation will take at most logC recursion space.
        """"""
        total_cities = len(isConnected)
        total_provinces = total_cities

        self.parents = list(range(total_cities))
        self.ranks = [0] * total_cities

        for i in range(total_cities):
            for j in range(total_cities):
                if isConnected[i][j] == 1 and self.union(i, j):
                    total_provinces -= 1

        return total_provinces",0
"class Solution:
    def checkRecord(self, s: str) -> bool:
        a, l = 0, 0
        for i in range(len(s)):
            if s[i] == 'A':
                a += 1
                if l < 3:
                    l = 0
            elif s[i] == 'L':
                if l == 0:
                    l += 1
                elif l > 0 and s[i-1] == 'L':
                    l += 1
                else:
                    l = 0
            else:
                if l < 3:
                    l = 0
            if (a > 1 or l > 2):
                return False
            else:
                pass
        return True",0
"class Solution:
    def checkRecord(self, n: int) -> int:
        self.dp = defaultdict(int)

        self.dp[0] = 1
        self.dp[1] = 2
        self.dp[2] = 4
        self.dp[3] = 7

        self.helper(n)
        total = self.dp[n]

        for i in range(1, n + 1):
            total += self.dp[i - 1] * self.dp[n - i] 

        return total % ((10 ** 9) + 7)

    def helper(self, i):
        if i < 0:
            return 0
        if i in self.dp:
            return self.dp[i]

        self.dp[i] = (2 * self.helper(i - 1) - self.helper(i - 4)) % ((10 ** 9) + 7)
        
        return self.dp[i]",1
"class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        n=len(nums)
        new=[[(0,"""") for i in range(0,n)] for i in range(0,n)]
        for i in range(0,n):
            new[i][i]=(nums[i],str(nums[i]))
        for i in range(0,n-1):
            for j in range(i+1,n):
                new[i][j]=(new[i][j-1][0]/nums[j],new[i][j-1][1]+""/""+str(nums[j]))
        ans=[(0,"""")]*n
        ans[0]=(nums[0],str(nums[0])
        for i in range(1,n):
            for j in range(0,i):
                if (ans[i][0]<ans[j][0]/new[j+1][i][0]):
                    if i-j>=2:
                        ans[i]=(ans[j][0]/new[j+1][i][0],ans[j][1]+""/""+""(""+new[j+1][i][1]+"")"")
                    else:
                        ans[i]=(ans[j][0]/new[j+1][i][0],ans[j][1]+""/""+new[j+1][i][1])
        return ans[-1][1]",0
"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        edge = []
        for w in wall: 
            prefix = 0
            for k in range(len(w)-1): 
                prefix += w[k]
                edge.append(prefix)
        
        ans = cnt = 0
        prev = None
        for x in sorted(edge): 
            cnt = 1 if x != prev else cnt+1 # reset counter 
            ans = max(ans, cnt)
            prev = x
        return len(wall) - ans",1
"class Solution:
    def nextGreaterElement(self, n: int) -> int:
    	n = [int(i) for i in str(n)]
    	for i in range(2,len(n)+1):
    		b, f = 1, n[-i]
    		for j in range(1,10-f):
    			if f + j in n[-i+1:]:
    				b = 0
    				break
    		if b == 1: continue
    		n[n.index(f+j,-i)], n[-i] = f, f + j
    		n[-i+1:] = sorted(n[-i+1:])
    		n = int("""".join([str(i) for i in n]))
    		return n if n < 2**31 else -1
    	return -1
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def reverseWords(self, s: str) -> str:
        l1=s.split()
        l=[]
        for i in l1:
            c=i[::-1]
            l.append(c)
        for i in l:
            c=' '.join(l)
        return c
            
        ``",1
"class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf and quadTree2.isLeaf:                                    # case 1: both are leaf nodes
            node = Node(quadTree1.val | quadTree2.val, 1, None, None, None, None)
            return node
        elif quadTree1.isLeaf and not quadTree2.isLeaf:                              # case 2: node 1 is leaf node, node 2 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1, quadTree2.topLeft), 
                        self.intersect(quadTree1, quadTree2.topRight), 
                        self.intersect(quadTree1, quadTree2.bottomLeft), 
                        self.intersect(quadTree1, quadTree2.bottomRight))
        elif not quadTree1.isLeaf and quadTree2.isLeaf:                              # case 3: node 2 is leaf node, node 1 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2), 
                        self.intersect(quadTree1.topRight, quadTree2), 
                        self.intersect(quadTree1.bottomLeft, quadTree2), 
                        self.intersect(quadTree1.bottomRight, quadTree2))
        else:                                                                        # case 4: neither nodes are leaf 
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2.topLeft), 
                        self.intersect(quadTree1.topRight, quadTree2.topRight), 
                        self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft), 
                        self.intersect(quadTree1.bottomRight, quadTree2.bottomRight))
            
        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf \
            and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val \
            == node.bottomLeft.val == node.bottomRight.val:                          # shrink quad nodes to one leaf node is values in 4 areas are the same
            return Node(node.topLeft.val, 1, None, None, None, None)
        return node",0
"class Solution:
    def maxDepth(self, root: 'Node') -> int:
        
        def dfs(root: 'Node', length: int):
            if root is None:
                return
                
            length += 1
            
            if not root.children:
                result.append(length)
            else:
                for child in root.children:
                    dfs(child, length)
                
        result = []
        dfs(root, length=0)
        
        if not result:
            return 0
        
        return max(result)",1
"class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        
        if len(nums)==0:
            return 0
        rSum=0
        count=0
        res_map={}
        res_map[0]=1
        for i in range(len(nums)):
            rSum+=nums[i]
            
            compliment=rSum-k
            if compliment in res_map:
                count = count + res_map[compliment]
            if rSum in res_map:
                res_map[rSum]=res_map[rSum]+1
            else:
                res_map[rSum]=1
        return count",1
"class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum(nums[::2])",1
"class Solution:
    def findTilt(self, root: TreeNode) -> int:
        cur_sum = [0]
        def helper(node: TreeNode):
            if not node: return 0
            lt = helper(node.left)
            rt = helper(node.right)
            cur_sum[0] += abs(lt-rt)
            return node.val + lt + rt
        helper(root)
        return cur_sum[0]",1
"class Solution:
    def nearestPalindromic(self, n: str) -> str:
        sz = len(n)
        cand = n[:sz//2] + (n[sz//2] if sz&amp;1 else """") + n[0:sz//2][::-1]
        
        def fn(carry): 
            digits = list(map(int, n))[:(sz+1)//2]
            i = (sz-1)//2
            while i >= 0 and carry: 
                digits[i] += carry 
                carry = digits[i] // 10 
                digits[i] = (digits[i] + 10) % 10 
                i -= 1
            half = (str(carry)+''.join(map(str, digits))).lstrip('0')
            if len(half) < len(digits): return '9'*(sz-1) or '0'
            if len(half) > len(digits): return '1' + '0'*(sz-1) + '1'
            half = half or '0'
            if sz&amp;1: return half + half[:-1:][::-1]
            else: return half + half[::-1]
            
        large = fn(1)
        small = fn(-1)
        # print(cand, ""|"", large, ""|"", small)
        if cand == n: return min(small, large, key=lambda x: (abs(int(x)-int(n)), int(x)))
        return min(cand, large, small, key=lambda x: (abs(int(x)-int(n)), int(x)))",0
"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans = 0 
        for i in range(len(nums)): 
            cnt = 0
            while nums[i] != -1: 
                cnt += 1
                nums[i], i = -1, nums[i]
            ans = max(ans, cnt)
        return ans",1
"class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        newList = []
        
        #convert to 1-D list
        for i in mat:
            for j in i:
                newList.append(j)

        elements = len(newList)        #total no. of elements

        resMat = []
        
        #if the no. of elements of the new required matrix size (r x c) are not equal to total number of elements, we need to return the original matrix
        if r*c != elements:
            return mat
        else:
            for i in range(0,len(newList),c):
                resMat.append(newList[i:i+c])
            return resMat",1
"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        d1={}
        d2={}
        if(len(s1)>len(s2)):
            return False
        sl = len(s1)
        left = 0
        right = sl-1
        
        for i in s1:
            if(i not in d1):
                d1[i] = 1
            else:
                d1[i] +=1
        
        for i in range(left,right+1):
            if(s2[i] not in d2):
                d2[s2[i]] = 1
            else:
                d2[s2[i]] +=1
        
        if(d1 == d2):
            return True
            
        while(right < len(s2)-1):
            right+=1
            if(s2[right] not in d2):
                d2[s2[right]] = 1
            else:
                d2[s2[right]] +=1
            
            if(d2[s2[left]] == 1):
                del d2[s2[left]]
            else:
                d2[s2[left]]-=1
            left+=1
            if(d1 == d2):
                return True
            
            
        return False",0
"class Solution:
    
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if root is None:
            return False
        
        def add_hash(node):
            if not node:
                return hash('#')
            node.hash = hash(add_hash(node.left) + hash(node.val) + add_hash(node.right))
            return node.hash
        
        add_hash(root)
        add_hash(subRoot)
        return self.rec(root, subRoot)

    def rec(self, root, subRoot):
        if root is None:
            return False
        
        if root.hash == subRoot.hash and self.isEqual(root, subRoot):
                return True
        
        return self.rec(root.left, subRoot) or self.rec(root.right, subRoot)
    
    def isEqual(self, subroot1, subroot2):
        if subroot1 is None or subroot2 is None:
            return subroot1 is None and subroot2 is None
        else:
            return subroot1.val == subroot2.val and self.isEqual(subroot1.left, subroot2.left) and self.isEqual(subroot1.right, subroot2.right)",0
"class Solution:
    def distributeCandies(self, candies: List[int]) -> int:
        average = len(candies) // 2
        kind = len(set(candies))
        if average >= kind :
            return kind
        else:
            return average",1
"class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        
        @cache
        def fn(i, j, mv): 
            """"""Return out of boundary paths.""""""
            if not (0 <= i < m and 0 <= j < n): return 1 
            if mv == 0: return 0
            return (fn(i-1, j, mv-1) + fn(i, j-1, mv-1) + fn(i, j+1, mv-1) + fn(i+1, j, mv-1)) % 1_000_000_007
        
        return fn(startRow, startColumn, maxMove)",0
"class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sortednums = sorted(nums)
        if sortednums == nums:
            return 0
        start = 0
        end = len(nums)-1
        for i in range(len(nums)):
            if nums[i]!=sortednums[i]:
                start = i
                break
        for i in range(len(nums)-1,0,-1):
            if nums[i]!=sortednums[i]:
                end = i
                break
        return len(nums[start:end+1])",1
"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp=[[0 for _ in range(len(word2)+1)]for _ in range(len(word1)+1)]
        for i in range(1,len(dp)):
            for j in range(1,len(dp[0])):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                else:
                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])
        return len(word1)+len(word2)-2*dp[-1][-1]",0
"class Solution:
    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        def clockwise(p1,p2,p3):
            x1,y1=p1
            x2,y2=p2
            x3,y3=p3
            
            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))
        trees.sort()
        upper=[]
        lower=[]
        for t in trees:
            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:
                upper.pop()
            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:
                lower.pop()
            upper.append(tuple(t))
            lower.append(tuple(t))
            
        return list(set(upper+lower))",1
"class Solution:
    def __init__(self):     # initializing the answer list
        self.ans=[]
		
    def preorder(self, root: 'Node') -> List[int]:
        if not root:             # if leaf Node
            return
        self.ans.append(root.val)   # append the root value
        for i in root.children:    # iterate over every children 
            self.preorder(i)
        return self.ans        # return ans",1
"class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        st = [root]
        l = []
        while st:
            node = st.pop()
            if node:
                l.insert(0,node.val)
                if node.children:
                    for i in node.children:
                        st.append(i)
        return l",1
"class Solution:
    def isValid(self, code: str) -> bool:
        prefix = suffix = False 
        stack = []
        i = 0 
        while i < len(code): 
            if code[i:i+2] == '</': 
                ii = i = i+2
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if i == len(code)-1: suffix = True 
                tag = code[ii:i]
                if not stack or stack[-1] != tag: return False 
                stack.pop()
                if not stack and not suffix: return False 
            elif code[i:i+3] == '<![': 
                ii = i = i+3
                buffer = 1
                for i in range(i, len(code)): 
                    if code[i] == '[': 
                        if buffer: 
                            buffer = 0 
                            if code[ii:i] != ""CDATA"": return False 
                    elif code[i:i+3] == ']]>': 
                        if buffer: return False 
                        break 
                else: return False 
            elif code[i] == '<': 
                ii = i = i+1
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if ii == 1: prefix = True 
                tag = code[ii:i]
                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False 
                stack.append(tag)
            i += 1
        return prefix and suffix and not stack",0
"class Solution:
    def fractionAddition(self, expression: str) -> str:
        n, d = 0, 1
        nums = (int(x) for x in re.findall(""[+-]?\d+"", expression))
        for nn, dd in zip(*[iter(nums)]*2):
            n = n*dd + nn*d
            d *= dd
        g = gcd(n, d)
        return f""{n//g}/{d//g}""",1
"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    	D = [(i[0]-j[0])**2+(i[1]-j[1])**2 for i,j in itertools.combinations([p1,p2,p3,p4],2)]
    	return False if not D else [D.count(min(D)),D.count(max(D))] == [4,2]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        
        c = Counter(nums)
        res = 0
        for x in set(nums):
            
            less, big = x - 1, x + 1
            if less in c or big in c:
                res = max(res, c[less] + c[x], c[big] + c[x])
        return res",1
"class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        if not ops:
            return m*n
        return min(op[0] for op in ops)*min(op[1] for op in ops)",1
"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
    	D = {j:i for i,j in enumerate(list2)}
    	L = sorted([[i+D[j],j] for i,j in enumerate(list1) if j in D])
    	return [r[1] for r in L if r[0] == L[0][0]]
		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def findIntegers(self, n: int) -> int:
        # fn - count of numbers with size of n in bin representation which satisfy the rule
        # for example: fn[3] = 5 => *** = {'000', '001', '010', '100', '101'}
        # fn[2] = 3 => ** = {'00', '01', '10'}
        # fn[6] = {'10****', '0*****'} = fn[4] + fn[5]
        # fn[0] is trick for loop to append 1 to result if max_n has '1' in last bit
        fn = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269]
        # another words fn is count of numbers which satisfy the rule and less then 2^n for n >= 1
        
        nstr = bin(n)[2:]
        p = nstr.find('11')
        tmp = list(nstr)
        if p >= 0:
            for i in range(p + 1, len(tmp)):
                tmp[i] = '10'[(i - p) % 2]
        
        max_n = ''.join(tmp)
        # max_n - bin representation of max number that satisfy the rule
        # bin(n) = '10011010' -> max_n = '10010101'
        # bin(n) = '1100' -> max_n = '1010'
        
        # main idea:
        #  n = 154 = 10011010 -> max_n = 10010101 = 10000000 + 10000 + 100 + 1
        # 10000000 => {10000000} + {0*******} -> 1 + fn[7] = 35
        # 10000 => {10000} + {0****} - {00000} (just used in prev step) -> 1 + fn[4] - 1 = fn[4] = 8
        # 100 => {100} + {0**} - {000} -> fn[2] = 3
        # 1 or fn[0]
        # ans = 35 + 8 + 3 + 1 = 47
        
        ans = fn[len(max_n) - 1] + 1
        for i in range(2, len(max_n)):
            if max_n[i] == '1':
                ans += fn[len(max_n) - i - 1]
        
        return ans
	```",0
"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        l = None
        for i in range(len(flowerbed)):
            if n>len(flowerbed) or n==0:
                return n==0
            if not flowerbed[i] and not l and (i==len(flowerbed)-1  or (i<len(flowerbed)-1 and not flowerbed[i+1])):
                n-=1
                flowerbed[i] = 1
            l = flowerbed[i]
        return n==0",0
"class Solution:
    def tree2str(self, root: TreeNode) -> str:
        def rec(node: TreeNode) -> str:
            out = str(node.val)
            
            if node.left:
                out += f""({rec(node.left)})""
            elif node.right:
                out += ""()""
                
            if node.right:
                out += f""({rec(node.right)})""
                
            return out
    
        return rec(root)",1
"class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        mp = {} # mapping from content to file 
        for path in paths: 
            files = path.split()
            for i in range(1, len(files)): 
                f, c = files[i].split(""("")
                mp.setdefault(c[:-1], []).append(files[0] + ""/"" + f) 
        return [x for x in mp.values() if len(x) > 1]",0
"class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        count=0
        for i in range(len(nums)-2):
            k=i+2
            for j in range(i+1,len(nums)-1):
                if nums[i]==0: continue
                while k<len(nums) and nums[i] + nums[j] > nums[k]:
                    k+=1
                count+=k-j-1
        return count",1
"class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if root1 == root2 == None:
            return None
        
        if root1 and root2 == None:
            return root1
        
        if root2 and root1 == None:
            return root2

        if root1 and root2:
            root = TreeNode(root1.val + root2.val)
            root.left = self.mergeTrees(root1.left, root2.left)
            root.right = self.mergeTrees(root1.right, root2.right)
            return root",0
"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = {} # frequency table 
        for x in tasks: freq[x] = 1 + freq.get(x, 0)
        mx = max(freq.values()) # highest frequency
        cnt = sum(v == mx for v in freq.values()) # occurrences of most frequent tasks
        return max(len(tasks), (mx-1)*(n+1) + cnt)",0
"class Solution:
    def addOneRow(self, root: Optional[TreeNode], v: int, d: int) -> Optional[TreeNode]:
        temp=root
        def hii(temp,d):
            
            if d==2 and temp:
                x=TreeNode(v)
                y=TreeNode(v)
                x.left=temp.left
                y.right=temp.right
                temp.left=x
                temp.right=y
                return root
            else:
                if temp:
                    hii(temp.left,d-1)
                    hii(temp.right,d-1)
            return root
        
        if d==1:
            x=TreeNode(v)
            x.left=root
            return x
        
        return hii(temp,d)",1
"class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        
        nums.sort()
        return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",1
"class Solution:
    def kInversePairs(self, n: int, k: int) -> int:
        curr = [0 for _ in range(k+1)]
        prev = [0 for _ in range(k+1)]
        for i in range(1,n+1):
            value = 0
            for j in range(k+1):
                if j == 0:
                    curr[j] = 1
                    value += prev[j]
                else:
                    if j >= i:
                        value-=prev[j-i]
                    value+=prev[j]
                    curr[j] = value
            curr,prev = prev,curr
        return prev[-1] % (10**9+7)",0
"class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        prefix = 0 
        pq = [] # max-heap 
        for x, y in sorted(courses, key=lambda x: x[1]): 
            prefix += x
            heappush(pq, -x)
            while prefix > y: prefix += heappop(pq)
        return len(pq)",1
"class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        hi = -inf
        pq = []
        for i, num in enumerate(nums): 
            heappush(pq, (num[0], i, 0))
            hi = max(hi, num[0])
        
        ans = [-inf, inf]
        while pq: 
            ans = min(ans, [pq[0][0], hi], key=lambda x: (x[1]-x[0], x[0]))
            _, i, j = heappop(pq)
            if j+1 == len(nums[i]): break 
            hi = max(hi, nums[i][j+1])
            heappush(pq, (nums[i][j+1], i, j+1))
        return ans",0
"class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        # Fermat theorem on sum of two squares
        x = 2
        while x*x <= c: 
            if c % x == 0: 
                mult = 0
                while c % x == 0: 
                    mult += 1
                    c //= x
                if x % 4 == 3 and mult &amp; 1: return False 
            x += 1
        return c % 4 != 3",1
"class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        ans = [0] * n
        stk, start = [], None
        for log in logs:
            jid, kw, ts = log.split(':')
            jid, ts = int(jid), int(ts)
            if kw == 'start':
                if stk:
                    ans[stk[-1]] += (ts - start)
                stk.append(jid)
                start = ts
            else:
                ans[stk.pop()] += (ts - start + 1)
                start = ts + 1
        return ans",0
"class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        lst=[root]
        flst=[]
        avg=[]
        sm,ct=0,0
        while lst:
            x=lst.pop(0)
            sm+=x.val
            ct+=1
            if x.left:
                flst.append(x.left)
            if x.right:
                flst.append(x.right)
            if lst==[]:
                lst=flst[:]
                flst=[]
                av=sm/ct
                avg.append(round(av,5))
                sm=0
                ct=0
        return avg",1
"class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        #Approach: At every decision making node, we have an option to choose one of 
        #many available sale special offers! Once we run out of offers to choose from,
        #we will simply have to buy the remaining items needed at regular price described
        #from price array!
        
        #To keep track of the special offer I used so far, I will utilize a boolean array
        #s.t. b_arr[i] = 1 if already used 0 else!
        num_specials = len(special)
        b_arr = [0 for _ in range(num_specials)]
        
        #i will also use nonlocal variable to keep track of amount spent so far!
        #i will periodically update this as I recurse and also when I backtrack!
        amount_spent = 0
        #n will store the original number of items I need to buy!
        n = sum(needs)
        ans = float(inf)
        #paramter:
        #1. rem. total elements to buy!
        #2. array describing number of rem. items by item type!
        def helper(remaining, a):
            nonlocal b_arr, num_specials, amount_spent, ans, special, price
            #base case: rem. items == 0! We reach this base case if we are able to buy
            #every item type according to our needs just from using special offers and not 
            #paying at regular price!
            if(remaining == 0):
                #update answer!
                ans = min(amount_spent, ans)
                return
            
            #if not base case, that means we still have items to buy!
            #consider iterating through each and every special offer! 
            #check that it's available!
            #if available, check that speical offer does not require buying items more than need!
            #If so, deduct amount of items by each item type and update remaining amount
            #and recurse on it!
            #When recursing, restore state of b_arr, amount_spent, as well as array a!
            special_valid = False
            for i in range(num_specials):
                #ith offer already used!
                if(b_arr[i] == 1):
                    continue
                #run a loop to check if ith offer amount to buy never exceeds the
                #current needs!
                is_valid = True
                for j in range(len(a)):
                    #check if ith special offer causes overbuying! If so, set is_valid flag off!
                    if(a[j] < special[i][j]):
                        is_valid = False
                        break
                #check if flag is not set!
                if(not is_valid):
                    continue
                special_valid = True
                #otherwise, if current ith special offer is valid for all item types,
                #go ahead and update remaining items, state of array a, as well as amount spent!
                amount_spent += special[i][-1]
                
                #set the boolean array on to indicate we used up ith offer!
                b_arr[i] = 1
                overall_remaining = remaining
                for b in range(len(a)):
                    a[b] -= special[i][b]
                    overall_remaining -= special[i][b]
                
                #go ahead and recurse!
                helper(overall_remaining, a)
                
                #once we return from rec. call, set the flag back off,
                #update amount spent, as well as state of array a when
                #backtracking to parent caller in recursion!
                b_arr[i] = 0
                #update amount spent!
                amount_spent -= special[i][-1]
                
                for c in range(len(a)):
                    a[c] += special[i][c]
            #check if even a single special offer can be used by using special_valid boolean flag!
            #If not, then we have to buy remaining items and update amount_paid so far! 
            if(not special_valid):
                new_amount_paid = amount_spent
                for d in range(len(a)):
                    if(a[d] > 0):
                        new_amount_paid += (a[d] * price[d])
                ans = min(ans, new_amount_paid)
                        
        
        helper(n, needs)
        #edge case: without using any special offer, buying at regular price might be the best
        #option!
        without = 0
        for z in range(len(price)):
            without += (price[z] * needs[z])
        return min(ans, without)",0
"class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache 
        def fn(i): 
            """"""Return decode ways.""""""
            if i == len(s): return 1 
            if s[i] == ""0"": return 0 
            if i == len(s)-1: return 9 if s[i] == '*' else 1
            if s[i] == ""*"": 
                ans = 9*fn(i+1)
                if s[i+1] == ""*"": ans += 15*fn(i+2)
                else: 
                    ans += fn(i+2)
                    if s[i+1] <= ""6"": ans += fn(i+2)
            else: 
                ans = fn(i+1)
                if s[i+1] == ""*"": 
                    if s[i] == ""1"": ans += 9*fn(i+2)
                    elif s[i] == ""2"": ans += 6*fn(i+2)
                elif int(s[i:i+2]) <= 26: ans += fn(i+2)
            return ans % 1_000_000_007
        
        return fn(0)",0
"class Solution:
    def solveEquation(self, equation: str) -> str:
        s = ''
        x, i = 0, 0
        rev = False
		
        for c in equation:
            if c in '+-':
				if s:
					i += int(s or 0) * (rev or -1)
                s = c
            elif c == 'x':
                x -= int(s+'1' if s in '+-' else s) * (rev or -1)
                s = ''
            elif c == '=':
			    if s:
					i -= int(s or 0)
					s = ''
                rev = True
            else:
                s += c
        else:
		    if s:
				i += int(s or 0) * (rev or -1)
            return f'x={i//x}' if x else 'No solution' if i else 'Infinite solutions'",0
"class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        sums, ans = 0, float(""-inf"")
        i = 0
        for j in range(len(nums)):
            sums += nums[j]
            if j-i+1 == k:
                ans = max(ans, sums)
                sums -= nums[i]
                i = i+1
        return ans / k",1
"class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        a = Counter(nums)
        Fsm = sum(nums)
        Csm = (len(nums) * (len(nums)+1))//2
        tp = a.most_common(1)
        return [tp[0][0], Csm - (Fsm - tp[0][0])]",1
"class Solution:
def findLongestChain(self, pairs: List[List[int]]) -> int:
    n=len(pairs)
    dp=[1]*n
    pairs=sorted(pairs,key=lambda k:k[0])
    for i in range(1,n):
        for j in range(0,i):
            if pairs[i][0]>pairs[j][1] and dp[i]<dp[j]+1:
                dp[i]=dp[j]+1
    return max(dp)",1
"class Solution:
    def countSubstrings(self, s: str) -> int:
        count = 0
   
        for l in range(len(s)):
            count += Solution.check(l,l,s)
            count += Solution.check(l,l+1,s)
            
        return count
    
    @staticmethod
    def check(l, r, s):
        count = 0
        while(l>=0 and r<len(s)):
            if s[l] == s[r]:
                count +=1
            else:
                break
            l-=1
            r+=1
        return count",1
"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        s = sentence.split()
        dictionary.sort(key=lambda x:len(x))
        for i,j in enumerate(s):
            for v in dictionary:
                if j.startswith(v):
                    s[i] = v
                    break
        return ' '.join(s)",1
"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        d, r = senate.count(""D""), senate.count(""R"")
        killedR, killedD = 0, 0
        deleted = set()
        while d and r:
            for idx,letter in enumerate(senate):
                if idx in deleted: continue
                if letter == ""R"" and killedR == 0:
                    killedD += 1
                    d -= 1
                elif letter == ""D"" and killedD == 0:
                    killedR += 1
                    r -= 1
                elif letter == ""R"" and killedR > 0:
                    deleted.add(idx)
                    killedR -= 1
                else:
                    deleted.add(idx)
                    killedD -= 1
        return ""Dire"" if d else ""Radiant""",0
"class Solution:
    def minSteps(self, n: int) -> int:
        ans=0
        for d in range(2,n+1):
            while n%d==0:
                ans+=d
                n/=d
            if n<d:
                break
        return ans",1
"class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        
        def fn(node): 
            """"""Return serialized sub-tree rooted at node.""""""
            if not node: return "" ""
            left, right = fn(node.left), fn(node.right)
            srl = "","".join((str(node.val), left, right))
            if seen.get(srl, 0) == 1: ans.append(node)
            seen[srl] = 1 + seen.get(srl, 0)
            return srl
        
        ans, seen = [], {}
        fn(root)
        return ans",1
"class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
		#Generates node values depth-first from right-to-left
        def dftRtoL(root):
            if root.right: yield from dftRtoL(root.right)
            yield root.val
            if root.left: yield from dftRtoL(root.left)
        
		#Generates node values depth-first from left-to-right
        def dftLtoR(root):
            if root.left: yield from dftLtoR(root.left)
            yield root.val
            if root.right: yield from dftLtoR(root.right)
        
        pl, pr = dftLtoR(root), dftRtoL(root)
        l, r = next(pl), next(pr)
        
		#If the node values are equal then all nodes have been checked and there is no solution
        while l != r:
			#l+r is too small, decrease l
            if l + r < k:
                l = next(pl)
			#l+r is too big, increase r
            elif l + r > k:
                r = next(pr)
			#l+r == k, the solution is found
            else: return True
        return False",0
"class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if nums == []:
            return None
        else:
            node = TreeNode(max(nums))
        node.left = self.constructMaximumBinaryTree(nums[:nums.index(max(nums))])
        node.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:])
        return node",1
"class Solution:
    def printTree(self, root: TreeNode) -> List[List[str]]:
        ht = lambda node: 1 + max(ht(node.left), ht(node.right)) if node else 0 # height of binary tree 
        m = ht(root) # rows 
        n = 2**m - 1 # columns 
        
        def dfs(node, i, lo=0, hi=n): 
            """"""Populate ans via dfs.""""""
            if not node: return 
            mid = lo + hi >> 1
            ans[i][mid] = str(node.val)
            dfs(node.left, i+1, lo, mid) or dfs(node.right, i+1, mid+1, hi)

        ans = [[""""]*n for _ in range(m)]
        dfs(root, 0)
        return ans",0
"class Solution:
    def judgeCircle(self, moves: str) -> bool:
        x,y=0,0
        for i in range(len(moves)):
            if (moves[i] == 'L'):
                x += 1;
            if (moves[i] == 'R'):
                x -= 1;
            if (moves[i] == 'U'):
                y += 1;
            if (moves[i] == 'D'):
                y -= 1;
        return x==0 and y==0",0
"class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        li=[]
        ans=[]
        for i in range(len(arr)):
            diff=abs(arr[i]-x)
            heapq.heappush(li,[diff,arr[i]])
        for i in range(k):
            diff,val=heapq.heappop(li)
            ans.append(val)
        ans.sort()
        return ans",1
"class Solution:
    def isPossible(self, nums: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0) # frequency table of nums
        
        seen = deque()
        for i, x in enumerate(nums):
            if i == 0 or nums[i-1] != x: 
                if (n := freq[x] - freq.get(x-1, 0)) > 0: seen.extend([x]*n)
                elif any(x - seen.popleft() < 3 for _ in range(-n)): return False 
                if not freq.get(x+1, 0) and any(x - seen.popleft() < 2 for _ in range(freq[x])): return False 
        return True",0
"class Solution:
    def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        m, n = len(M), len(M[0])
        # Calculate sums in the same row.
        for i in range(m):
            tmp = M[i][0]
            for j in range(1, n):
                value = M[i][j]
                M[i][j - 1] += value
                M[i][j] += tmp
                tmp = value

        # Calculate the sums by columns.
        for j in range(n):
            tmp = M[0][j]
            for i in range(1, m):
                value = M[i][j]
                M[i - 1][j] += value
                M[i][j] += tmp
                tmp = value
        
        # Calulate the number of cells.
        for i in range(m):
            x = 3 - (1 if i == 0 else 0) - (1 if i == m - 1 else 0)
            for j in range(n):
                y = 3 - (1 if j == 0 else 0) - (1 if j == n - 1 else 0)
                M[i][j] //= x * y
        return M",0
"class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        L=[[root]]
        V=[[0]]
        while L[-1]:
            R=[]
            S=[]
            for i in range(len(L[-1])):
                if L[-1][i].left:
                    S.append(2*V[-1][i])
                    R.append(L[-1][i].left)
                if L[-1][i].right:
                    S.append(2*V[-1][i]+1)
                    R.append(L[-1][i].right)
            V.append(S)
            L.append(R)
        v=[S[-1]-S[0]+1 for S in V if S]
        return max(v)",1
"class Solution:
    def strangePrinter(self, s: str) -> int:
        s = """".join(ch for i, ch in enumerate(s) if i == 0 or s[i-1] != ch)
        
        @cache
        def fn(lo, hi): 
            """"""Return min ops to print s[lo:hi].""""""
            if lo == hi: return 0
            ans = 1 + fn(lo+1, hi)
            for mid in range(lo+1, hi): 
                if s[lo] == s[mid]: 
                    ans = min(ans, fn(lo, mid) + fn(mid+1, hi))
            return ans 
        
        return fn(0, len(s))",0
"class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        changes = 0
        for i, j in zip(range(0, len(nums) - 1), range(1, len(nums))):
            if nums[j] < nums[i]:
                lchanges, rchanges = 0, 0
                for x in reversed(range(0, j)):
                    if nums[x] > nums[j]:
                        lchanges += 1
                        if lchanges == 2:
                            break;
                    else:
                        break
                for y in range(j, len(nums)):
                    if nums[y] < nums[i]:
                        rchanges += 1
                        if rchanges == 2:
                            break
                    else:
                        break
                changes += min(lchanges, rchanges)
                if changes >= 2:
                    return False
        return True",0
"class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        t=[i for i in range(1,n+1)]
        for j in range(1,k):
            t[j:]=t[j:][::-1]
        return t",1
"class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        pq = [(1, 1, 1)]    # Priority queue (table[i][j], i, j)
        seen = set((1,1))   # Visited nodes
        
        # Traverse the first k-1 nodes
        for i in range(1, k):
            # Pop ith smallest node
            cur, a, b = heappop(pq)
            
            # Add right node if it hasn't been seen to pq
            if a < m and (a+1, b) not in seen: 
                heappush(pq, (cur+b, a+1, b))
                seen.add((a+1, b))
            
            # Add left node if it hasn't been seen to pq
            if b < n and (a, b+1) not in seen: 
                heappush(pq, (cur+a, a, b+1))
                seen.add((a, b+1))
        
        # Next node in priority queue is the kth smallest node
        return heappop(pq)[0]",0
"class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        # iterative
        if root is None: return None
        
        while root and (root.val < L or root.val > R):
            if root.val < L: root = root.right
            else: root = root.left
        
        lnode = rnode = root
        while lnode.left:
            if lnode.left.val < L:
                lnode.left = lnode.left.right
            else: lnode = lnode.left
        while rnode.right:
            if rnode.right.val > R:
                rnode.right = rnode.right.left
            else: rnode = rnode.right
        return root",0
"class Solution:
    def maximumSwap(self, num: int) -> int:
        num = str(num)
        
        for i in range(len(num)):
            max_number = max([k for k in num[i:]])
            index = max([k for k in range(i, len(num)) if num[k]==max_number])
            
            if int(num[i])<int(max_number):
			    # String does not support item assignment, so using slicing for swapping the elements.
                num = num[:i] + num[index] + num[i+1:index] + num[i] + num[index+1:]
                break
                
        return int(num)",0
"class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        if not root.left:
            return -1

        if not root:
            return -1
        left=self.findSecondMinimumValue(root.left)
        right = self.findSecondMinimumValue(root.right)
        if root.right.val>root.val:
            if left==-1:
                return root.right.val
            else:
                return min(left,root.right.val)
        elif root.left.val>root.val:
            if right==-1:
                return root.left.val
            else:
                return min(right,root.left.val)
        else:
            if left==-1:
                return right
            if right==-1:
                return left
            return min(left, right)",0
"class Solution:
    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)
    states = {
        'N': 0b000,
        'A': 0b111,
        'O': 0b101,
        'E': 0b010,
        'T': 0b001,
        'AT': 0b111 ^ 0b001,
        'OT': 0b101 ^ 0b001,
        'ET': 0b010 ^ 0b001,
    }
    steps = {
        0: ['N'],
        1: ['A', 'O', 'E', 'T'],
        2: ['N', 'A', 'O', 'E', 'AT', 'OT', 'ET'],
        3: states.keys(),
    }
    def flipLights(self, n: int, m: int) -> int:
        n, m = min(n, 3), min(m, 3)
        mask = (1 << n) - 1
        ans = set()
        for s in self.steps[m]:
            ans.add((0b111 ^ self.states[s]) &amp; mask)
        return len(ans)",0
"class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        lis = [[1, 1] for _ in nums] # longest increasing subsequence (length &amp; count)
        for i, x in enumerate(nums): 
            for ii in range(i): 
                if nums[ii] < x: 
                    if lis[ii][0] + 1 > lis[i][0]: lis[i] = [1 + lis[ii][0], lis[ii][1]]
                    elif lis[ii][0] + 1 == lis[i][0]: lis[i][1] += lis[ii][1]
        mx, _ = max(lis, default=(0, 0))
        return sum(y for x, y in lis if x == mx)",0
"class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        curlen = 0
        maxlen = 0
        if not nums:
            return 0
        for i in nums:
            if nums[i] < nums[i+1]:
                curlen +=1
                maxlen = curlen
        return maxlen",1
"class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        a = []
        n = len(forest)
        m = len(forest[0])
        for i in range(n):
            for j in range(m):
                if forest[i][j] > 1:
                    a.append(forest[i][j])
        a.sort()
        
        s = 0
        ux = 0
        uy = 0
        for h in a:
            if forest[ux][uy] == h:
                continue        
            dist = [[None] * m for i in range(n)]
            q = deque()
            q.append((ux, uy))
            dist[ux][uy] = 0
            found = False
            while q and not found:
                ux, uy = q.popleft()
                d = [(-1, 0), (0, 1), (1, 0), (0, -1)]
                for dx, dy in d:
                    vx = ux + dx
                    vy = uy + dy
                    if vx < 0 or vx >= n or vy < 0 or vy >= m:
                        continue
                    if forest[vx][vy] == 0:
                        continue
                    if dist[vx][vy] is None:
                        dist[vx][vy] = dist[ux][uy] + 1
						# It's important to stop here! Otherwise there will be TLE
                        if forest[vx][vy] == h:
                            s += dist[vx][vy]
                            ux = vx
                            uy = vy
                            found = True
                            break
                        q.append((vx, vy))
            if not found:
                return -1
        return s",0
"class Solution:
    def valid(self, s, stack=[]):
        i, l = 0, len(s)
        if not l:
            return True
        
        while i<l:
            c = s[i]
            if c == '(':
                stack.append(c)
                
            elif c == ')':
                if stack and stack[-1] == '(':
                    stack.pop()
                else:
                    return False
                
            else:
                sub = s[i+1:]
                return (self.valid('('+sub, stack[:])
                       or self.valid(')'+sub, stack[:])
                       or self.valid(sub, stack[:]))
            
            i += 1
            
        return True if len(stack)==0 else False
    
    
    def checkValidString(self, s: str) -> bool:
        return self.valid(s)",0
"class Solution:
    def validPalindrome(self, s: str) -> bool:
        n=len(s)
        left,right=0,n-1
        cnt=0
        while left<=right:
            if s[left]==s[right]:
                left+=1
                right-=1
            else:
                if cnt==1:
                    return False
                else:
                    if self.check(s,left+1,right):
                        left+=1
                    elif self.check(s,left,right-1):
                        right-=1
                    else:
                        return False
                    cnt+=1
        return True
    def check(self,s,left,right):
        if s[left:right+1]==s[left:right+1][::-1]:
            return True
        return False",0
"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        res = []
        for i in ops:
            if i == 'C':
                res.pop()
            elif i == 'D':
                x = res[len(res)-1]
                res.append(2*x)
            elif i == '+':
                x = res[len(res) - 1]
                y = res[len(res) - 2]
                res.append(x+y)
            else:
                res.append(int(i))
            
            
        return sum(res)",1
"class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        dict={}
        n=len(edges)
        for i in range(1,n+1):
            dict[i]=i
            
        def find_parent(u):
            if dict[u]==u:
                
                return u
            else:
                a=find_parent(dict[u])
                
                dict[u]=a
                return a
            
        for i,j in edges:
            u=find_parent(i)
            v=find_parent(j)
            
            if u==v:
                return [i,j]
            else:
                dict[v]=u",1
"class Solution:
    def longestUnivaluePathUtil(self, root: TreeNode, maxCounter) -> int:
        counter = 0
        counterChoose = [0]
        if root!=None:
            if root.left!=None:
                temp = self.longestUnivaluePathUtil(root.left, maxCounter) + 1
                if root.val==root.left.val:
                    counterChoose.append(temp)
                    counter+= temp
            if root.right!=None:
                temp = self.longestUnivaluePathUtil(root.right, maxCounter) + 1
                if root.val==root.right.val:
                    counter+= temp
                    counterChoose.append(temp)
        maxCounter[0] = max(maxCounter[0], counter)
        return max(counterChoose)
    def longestUnivaluePath(self, root: TreeNode) -> int:
        maxCounter = [0]
        self.longestUnivaluePathUtil(root, maxCounter)
        return maxCounter[0]",0
"class Solution:
    def __init__(self):
        self.possibleMoves = [(-2,1),(-1,2),(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1)]
        self.mem = dict()
        
    def isInside(self, r, c, N):
        if r < 0 or c < 0 or r >= N or c >= N:
            return False
        return True
    
    def Util(self, N, K, r, c):
        if K == 0:
            return 1
        if (K, r, c) in self.mem:
            return self.mem[(K, r, c)]
        total = 0
        for i, j in self.possibleMoves:
            if self.isInside(r + i, c + j, N):
                corMoves = self.Util(N, K - 1, r + i, c + j)
                total += corMoves
        self.mem[(K, r, c)] = total
        return total
    
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        totalPossible = self.Util(N, K, r, c)
        return totalPossible / 8 ** K",0
"class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        curr = sum(nums[:k])
        # groups of sum-k 
        g = [0]*n
        for i in range(n-k+1):
            g[i] = curr
            if i+k < n:
                curr += nums[i+k] - nums[i]
        # pre[i]: the previous group index with maximum sum when i is the center group
        pre = [0]*n
        for i in range(k+1, n-2*k+1):
            pre[i] = pre[i-1] if g[pre[i-1]] >= g[i-k] else i-k
        # after[i]: the next group index with maximum sum when i is the center group
        after = [n-k]*n
        for i in range(n-2*k, k-1, -1):
            after[i] = after[i+1] if g[after[i+1]] > g[i+k] else i+k
        
        # Final iteration: find the maximum total sum with their group index 
        ans = []
        S = 0
        for i in range(k, n-2*k+1):
            curr = g[pre[i]] + g[i] + g[after[i]]
            if curr > S:
                S = curr
                ans = [pre[i], i, after[i]]
        return ans",0
"class Solution(object):
    def getImportance(self, employees, id):
        """"""
        :type employees: Employee
        :type id: int
        :rtype: int
        """"""
        d = dict()
        for node in employees:
            d[node.id] = node
            
        def Importance(node):
            if len(node.subordinates)==0:
                return node.importance
            else:
                S = node.importance
                for _id in node.subordinates:
                    S += Importance(d[_id])
                return S
                
        return Importance(d[id])",1
"class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:

        stickers = [Counter(s) for s in stickers if set(s)&amp;set(target)]
        dp = {}
        def generate(target):
            if not target: return 0
            if target in dp: return dp[target]
            
            target_counter = Counter(target)
            res = float(""inf"")
            for sticker in stickers:
                if sticker[target[0]] == 0: continue
                tmp = 1 + generate("""".join([letter*count for letter,count in (target_counter-sticker).items()]))

                res = min(res,tmp)
            dp[target] = res
            return res

        res = generate(target)
        return -1 if res == float(""inf"") else res",0
"class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        """"""
        Firstly, we use a Counter to count the frequency of each word within
        words, assigning the outcome as count. Then, for each key, value pair
        in count, a tuple of (value, key) is created, which is subsequently 
        sorted using a lambda of -x[0] (the frequency, sorted high to low), and 
        the lexographical order within the frequency. Finally, the k largest
        values of words are returned.
        
        :param words: the words to be considered. (List[str])
        :param k: the number of words to be considered. (int)
        :return outcome_list: the list containing the outcome. (List[str])
        """"""
        words = ((value, key) for key, value in Counter(words).items())
        words = sorted(words, key=lambda x: (-x[0], x[1]))
        return [value for key, value in words[:k]]",0
"class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while True:
            previous_bit = n &amp; 1
            n >>= 1
            if not n:
                return True
            
            current_bit = n &amp; 1
            if previous_bit == current_bit:
                return False
            previous_bit = current_bit",1
"class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        def dfs(i,j):
            if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]==0:
                return 0
            grid[i][j]=0
            down = dfs(i+1,j)
            up = dfs(i-1,j)
            right = dfs(i,j+1)
            left = dfs(i,j-1)
            a = 1+(up+down+right+left)
            return a
        ans = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                ans = max(ans,dfs(row,col))
        return ans",0
"class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        group_lens = [len(list(g)) for _, g in groupby(s)]
        return sum(min(a, b) for a, b in zip(group_lens, group_lens[1:]))",0
"class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        d = {}
        m, j, count = 1, [nums[0]], []
        for i in nums:
            if i not in d:
                d[i] = 1
            else:
                d[i] += 1
                if d[i] > m:
                    m = d[i]
                    j = [i]
                elif d[i] == m:
                    j.append(i)
        for i in j:
            count.append(len(nums) - nums[::-1].index(i) - nums.index(i))
        return min(count)",0
"class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        if total % k: return False 
        
        avg = total // k
        
        @cache
        def fn(x, mask):
            """"""Return True if available elements can be parititioned.""""""
            if x > avg: return False 
            if x == avg: return fn(0, mask)
            if not mask: return True 
            for i in range(len(nums)): 
                if mask &amp; 1<<i and fn(x + nums[i], mask ^ 1<<i): return True 
            return False 
        
        nums.sort(reverse=True)
        return fn(0, (1 << len(nums))-1)",0
"class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        ans = []
        for i, (x, l) in enumerate(positions): 
            val = 0
            for ii in range(i): 
                xx, ll = positions[ii]
                if xx < x+l and x < xx+ll: val = max(val, ans[ii])
            ans.append(val + l)
        for i in range(1, len(ans)): ans[i] = max(ans[i-1], ans[i])
        return ans",0
"class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == val:
            return root
        
        return self.searchBST(root.left, val) or self.searchBST(root.right, val)",1
"class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        s = 'right' if val > root.val else 'left'
        if getattr(root, s) is None:
            setattr(root, s, TreeNode(val))
        else:
            self.insertIntoBST(getattr(root, s), val)
        return root",1
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums)-1
        loc = -1
        while (low <= high):
            mid = (high+low)//2
            if nums[mid] == target:
                return mid
            if nums[mid] > target:
                high = mid-1
            elif nums[mid] < target:
                low = mid+1
        return loc",1
"# Array List Solution

class MyHashSet:

    def __init__(self):
        self.buckets = []

    def add(self, key: int) -> None:
        count = 0
        for x in self.buckets:
            if key in x:
                x += [key]
                count += 1
        if count == 0:
            self.buckets += [[key]]

    def remove(self, key: int) -> None:
        for x in self.buckets:
            while key in x:
                x.remove(key)

    def contains(self, key: int) -> bool:
        for x in self.buckets:
            if key in x:
                return True
        return False",1
"class Solution:
    def toLowerCase(self, s: str) -> str:
        output = ''
        for char in s:
            ascii_index = ord(char)
            if 65 <= ascii_index <= 90:
                output += chr(ascii_index+32)
            else:
                output += char
        return output",1
"class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        # The size of whitelist
        self.white_len = n - len(blacklist)
        # Last index of the array
        self.last_idx = n - 1
        # Mapping dictionary
        self.mapping = {}
        # Set the index of blacklist element all to -1
        for i in blacklist:
            self.mapping[i] = -1
        
        for i in blacklist:
            # skip blacklist
            if i >= self.white_len:
                continue
            while self.last_idx in blacklist:
                self.last_idx -= 1
            self.mapping[i] = self.last_idx
            self.last_idx -= 1

    def pick(self) -> int:
        idx = randint(0,self.white_len-1)
        if idx in self.mapping:
            return self.mapping[idx]
        return idx",1
"class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        @lru_cache(None)
        def getASCII(char):
            return ord(char)
        
        if len(s1) < len(s2):
            s1, s2 = s2, s1
            
        m, n = len(s1), len(s2)
        
        dp = [0]*(n+1)
        
        for i in range(1, n+1):
            dp[i] += dp[i-1] + getASCII(s2[i-1])
            
        for i in range(1, m+1):
            new_dp = [0]*(n+1) 
            new_dp[0] = dp[0] + getASCII(s1[i-1])
            
            for j in range(1, n+1):
                if s1[i-1] == s2[j-1]:
                    new_dp[j] = dp[j-1]
                else:
                    new_dp[j] = min(getASCII(s1[i-1])+dp[j], getASCII(s2[j-1])+new_dp[j-1])
            
            dp = new_dp
        
        return dp[-1]",0
"class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
       
        # Init
        n = len(nums)
        m = 0 # no. of subarrays
       
        # Base Case
        if k == 0:
            return 0
        
        # Base Case
        if sum(nums) == n:
            return (n)*(n+1)//2 if k > 1 else 0 
        
        # For each element
        for i,num_i in enumerate(nums):
            
            # Calc curr product
            curr_prod = num_i
            
            # Check if is less then k, else continue
            if curr_prod < k:
                m += 1
            else:
                continue
            
            # For each j from i+1 to n-1
            for num_j in nums[i+1:]:
                
                # calc current product
                curr_prod = curr_prod * num_j
                
                # Check if is less then k, else break
                if curr_prod < k:
                    m += 1
                else:
                    break
                    
        return m",1
"class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        self.dp=[[-1 for i in range(2)] for i in range(50001)]
        return self.dfs(0,0,prices,fee)
    def dfs(self,day,own,prices,fee):
        if day==len(prices):
            return 0
        if self.dp[day][own]!=-1:
            return self.dp[day][own]
        if own:
            p1=prices[day]-fee+self.dfs(day+1,not own,prices,fee)
            p2=self.dfs(day+1,own,prices,fee)
            self.dp[day][own]=max(p1,p2)
        else:
            p1=-(prices[day])+self.dfs(day+1,not own,prices,fee) #here we are sending(not own) bcoz own is 0
            p2=self.dfs(day+1,own,prices,fee)# here we are sending(own) bcoz own is 0
            self.dp[day][own]=max(p1,p2)
        return self.dp[day][own]",0
"class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i = 0
        while i in range(len(bits)):
            if i == len(bits)-1:
                return True
            if bits[i] == 0:
                i += 1
            else:
                i += 2
        return False",1
"class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        def helper(l):
            base = 1 << 7
            M = 10 **9 + 7
            a = pow(base, l, M)
            t1, t2 = 0, 0
            hashes = set()
            for i in range(len(nums1)):
                t1 = (base * t1 + nums1[i]) % M
                if i >= l:
                    t1 -= a * nums1[i - l]
                    t1 %= M
                if i >= l - 1:
                    hashes.add(t1)
                    
            for j in range(len(nums2)):
                t2 = (base * t2 + nums2[j]) % M
                if j >= l:
                    t2 -= a * nums2[j - l]
                    t2 %= M
                if j >= l - 1:
                    if t2 in hashes: return True
            return False
        
        a, b = 0, min(len(nums1), len(nums2))
        while a < b:
            m = (a + b + 1) // 2
            if helper(m):
                a = m
            else:
                b = m - 1
        return a",0
"class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()
        N = len(nums)

        def less(v):
            """"""number of distances < v""""""
            cnt, left = 0, 0
            for right in range(1, N):
                while left < right and nums[right] - nums[left] >= v:
                    left += 1
                cnt += right - left
            return cnt

        lo, hi = 0, max(nums) - min(nums)
        while lo <= hi:
            v = (lo+hi) // 2
            cnt = less(v)
            if cnt < k:
                lo = v + 1
            else:
                hi = v - 1
        return hi",0
"class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort(reverse=True)
        words.sort(key=lambda x : len(x))
        i = len(words)-1
        while i > -1:
            flag = True
            for j in range(1,len(words[i])):
                if words[i][:j] not in words:
                    flag = False
            if flag:
                return words[i]
            i -= 1
        return ''",1
"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        email_to_ids = collections.defaultdict(list)
        visited_accounts = [False]*len(accounts)
        for i, acct in enumerate(accounts):
            for email in acct[1:]:            
                email_to_ids[email].append(i)
        
        res = []
        for id, acct in enumerate(accounts):
            if visited_accounts[id]: 
                continue
            visited_accounts[id] = True
            merged_emails = set()
            stack = acct[1:]
            while stack:
                email = stack.pop()
                merged_emails.add(email)
                for id in email_to_ids[email]:
                    if not visited_accounts[id]: 
                        stack.extend([new_email for new_email in accounts[id][1:] if new_email != email])            
                        visited_accounts[id] = True
            res.append([acct[0]] + sorted(merged_emails))
        return res",0
"class Solution:

    pat1 = re.compile(r""//[^~]*~"")
    pat2 = re.compile(r""/\*.*?\*/"")

    def removeComments(self, source: List[str]) -> List[str]:
        one_line = ""~"".join(source) + ""~""
        idx_pat1 = one_line.find(""//"")
        idx_pat2 = one_line.find(""/*"")

        while -1 < idx_pat1 or -1 < idx_pat2:
            if -1 < idx_pat1 and -1 < idx_pat2:
                if idx_pat1 < idx_pat2:
                    one_line = Solution.pat1.sub(""~"", one_line, 1)
                else:
                    one_line = Solution.pat2.sub("""", one_line, 1)
            elif -1 < idx_pat1:
                one_line = Solution.pat1.sub(""~"", one_line, 1)
            else:
                one_line = Solution.pat2.sub("""", one_line, 1)
            idx_pat1 = one_line.find(""//"")
            idx_pat2 = one_line.find(""/*"")

        return [line for line in one_line.split(""~"") if line]",0
"class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        if(len(nums) <= 1):
            return 0
        s = sum(nums)
        c = 0
        for i in range(len(nums)):
            if (s - nums[i]) / 2 == c:
                return i
            c += nums[i]
        return -1",1
"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        n = 0
        current = head
        while (current):
            n += 1
            current = current.next
        
        parts = []
        for k in range(k, 0, -1):
            partSize = ceil(n / k)
            nextNode = head
            for _ in range(partSize - 1):
                if (not nextNode): break
                nextNode = nextNode.next
            parts.append(head)
            if (nextNode):
                head = nextNode.next
                nextNode.next = None
            n -= partSize
                
        return parts",1
"class Solution:
    def countOfAtoms(self, formula: str) -> str:
        mp = {}
        stack = []
        for i, x in enumerate(formula): 
            if x == ""("": stack.append(i)
            elif x == "")"": mp[stack.pop()] = i
        
        def fn(lo, hi): 
            """"""Return count of atom in a freq table.""""""
            k = lo 
            ans = defaultdict(int)
            while k < hi: 
                cnt = 0 
                if formula[k] == ""("": 
                    freq = fn(k+1, mp[k])
                    k = mp[k] + 1
                    while k < hi and formula[k].isdigit(): 
                        cnt = 10*cnt + int(formula[k])
                        k += 1
                    for key, val in freq.items(): ans[key] += val * max(1, cnt)
                else: 
                    atom = formula[k]
                    k += 1
                    while k < hi and formula[k] != ""("" and not formula[k].isupper(): 
                        if formula[k].isalpha(): atom += formula[k]
                        else: cnt = 10*cnt + int(formula[k])
                        k += 1
                    ans[atom] += max(1, cnt)
            return ans 
        
        
        ans = []
        for k, v in sorted(fn(0, len(formula)).items()): 
            ans.append(k)
            if v > 1: ans.append(str(v))
        return """".join(ans)",0
"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
    	L = []
    	for i in range(left,right+1):
    		d = list(str(i))
    		m = len(d)
    		if '0' in d:
    			continue
    		j = 0
    		while j < m and i%int(d[j]) == 0:
    			j += 1
    		if j == m:
    			L.append(i)
    	return(L)
		
	- Python 3
	- Junaid Mansuri",1
"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)",0
"class Solution:
    def countPalindromicSubsequences(self, s: str) -> int:
        n = len(s)
        t = [[0 for _ in range(n)] for _ in range(n)]
        
        for g in range(n):
            i = 0
            for j in range(g, n):
                if g == 0:
                    t[i][j] = 1
                elif g == 1:
                    t[i][j] = 2
                else:
                    if s[i] != s[j]:
                        t[i][j] = t[i][j-1] + t[i+1][j] - t[i+1][j-1]
                    else:
                        if s[i:j+1].count(s[i]) == 2:
                            t[i][j] = 2*t[i+1][j-1] + 2
                        elif s[i:j+1].count(s[i]) == 3:
                            t[i][j] = 2*t[i+1][j-1] + 1
                        else:
                            temp = s[i+1:j]
                            x = i + temp.index(s[i]) + 2
                            y = j - temp[::-1].index(s[i]) - 2
                            t[i][j] = 2*t[i+1][j-1] - t[x][y]
                i = i+1
        
        return t[0][n-1]% (10**9 + 7)",0
"class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        
        rows = len(image)
        cols = len(image[0])
        color_to_change = image[sr][sc]
        
        def dfs(r,c):
            if(r<0 or c<0 or r>rows-1 or c>cols-1 or image[r][c] == newColor or image[r][c]!=color_to_change):
                return
            image[r][c] = newColor
            
            #iterate through all four directions
            dfs(r+1,c)
            dfs(r-1,c)
            dfs(r,c+1)
            dfs(r,c-1)
        
        dfs(sr,sc)
        return image",0
"class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        ans = []
        for a in asteroids:
            if a > 0:
                ans.append(a)
            else:
                appendFlag = True
                while ans:
                    if ans[-1] < 0:
                        break
                    else:
                        if ans[-1] + a < 0:
                            ans.pop(-1)
                        elif ans[-1] + a == 0:
                            ans.pop(-1)
                            appendFlag = False
                            break
                        else:
                            appendFlag = False
                            break
                if appendFlag:
                    ans.append(a)                    
        return ans",0
"class Solution:
    def evaluate(self, expression: str) -> int:
        loc = {}
        stack = []
        for i, x in enumerate(expression): 
            if x == ""("": stack.append(i)
            elif x == "")"": loc[stack.pop()] = i
        
        def fn(lo, hi, mp): 
            """"""Return value of given expression.""""""
            if expression[lo] == ""("": return fn(lo+1, hi-1, mp)
            i = lo
            vals = []
            while i < hi: 
                if expression[i:i+3] in (""let"", ""add""): 
                    op = expression[i:i+3]
                    i += 3
                elif expression[i:i+4] == ""mult"": 
                    op = ""mult""
                    i += 4
                elif expression[i].isalpha(): 
                    x = """"
                    while i < hi and expression[i].isalnum(): 
                        x += expression[i]
                        i += 1
                    if op in (""add"", ""mult""): vals.append(mp[x])
                elif expression[i].isdigit() or expression[i] == ""-"": 
                    v = """"
                    while i < hi and (expression[i].isdigit() or expression[i] == ""-""): 
                        v += expression[i]
                        i += 1
                    if op == ""let"": mp[x] = int(v)
                    else: vals.append(int(v))
                elif expression[i] == ""("": 
                    v = fn(i+1, loc[i], mp.copy())
                    i = loc[i] + 1
                    if op == ""let"": mp[x] = v
                    else: vals.append(v)
                else: i += 1
            if op == ""let"": return int(v)
            elif op == ""add"": return sum(vals)
            else: return reduce(mul, vals)
            
        return fn(0, len(expression), {})",0
"class Solution:
def monotoneIncreasingDigits(self, n: int) -> int:
    s = str(n)
    for i in range(len(s)-1,0,-1):
        if s[i]<s[i-1]:
            n = n-(int(s[i:])+1)
            s = str(n)
    return n",1
"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        N = len(temperatures)
        stack, answer = [], [0 for _ in range(N)]
        for index, value in enumerate(temperatures):
            while stack and stack[-1][1] < value:
                i = stack.pop()[0]
                answer[i] = index-i
            stack.append((index, value))
        return answer",1
"class Solution:
    def deleteAndEarn(self, n: List[int]) -> int:
    	if not n: return 0
    	a, b, C = 0, n.count(1), collections.Counter(n)
    	for i in range(2,max(n)+1): b, a = max(C[i]*i + a, b), b
    	return b
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        
        rows = len(grid)
        cols = len(grid[0])
        
        #Go down or go right
        directions = [(1, 0), (0, 1)]
        
        #Enables cache for our dp
        @lru_cache(None)
        def dp(row_1, row_2, col_1, col_2):
            
            #if we hit a wall or we go out of the grid
            if col_1 >= cols or col_2 >= cols or row_1 >= rows or row_2 >= rows or grid[row_1][col_1] == -1 or grid[row_2][col_2] == -1:
                return -inf
            #Pick current cherries
            result = grid[row_1][col_1]
            
            #Do not double cherries if both paths are the same
            if col_1 != col_2 or row_1 != row_2:
                result += grid[row_2][col_2]
            
            # If we are at the end of the grid stop
            if not (row_1 == rows - 1 and col_1 == cols - 1):
                result += max(dp(new_row_1 + row_1, new_row_2 + row_2, new_col_1 + col_1, new_col_2 + col_2) 
                              for new_row_1, new_col_1 in directions
                              for new_row_2, new_col_2 in directions)
            
            return result
        
        ans = dp(0, 0, 0, 0)
        return 0 if ans == -inf else ans",0
"class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        d = {}
        graph = [[] for _ in range(n)]
        for i in times:
            d[(i[0]-1,i[1]-1)] = i[2]
            graph[i[0]-1].append(i[1]-1)        
        parent = [-1]*n
        cost = [10**9]*n
        visited = [False]*n
        cost[k-1] = 0
        x = 0
        while x <= n-1:
            m = (-1,10**9)
            for i in range(n):
                if not visited[i] and m[1] > cost[i]:
                    m = (i,cost[i])
            for i,j in enumerate(graph[m[0]]):
                if (m[0],j) in d and cost[j] > cost[m[0]] + d[(m[0],j)]:
                    cost[j] = cost[m[0]] + d[(m[0],j)]
                    parent[j] = m[0]
            visited[m[0]] = True
            x += 1
        return -1 if (max(cost)) == 10**9 else max(cost)",0
"class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
    	t, n = ord(target), list(map(ord,letters))
    	if t >= max(n): return chr(min(n))
    	d = {c : i for i,c in enumerate(n) if c > t}
    	return letters[d[min(d)]]
		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int: 
        # Handle empty cost case
        if not cost: return 0
        
        # min_cost is the minimum cost to get to some step i
        min_cost = [0] * len(cost)
        min_cost[0] = cost[0]
        
        # Loop through. At each i, the cost is:
        #   - The cost of that step plus the minimum cost of the two steps before it
        for i in range(1, len(cost)):
            min_cost[i] = cost[i] + min(min_cost[i-1], min_cost[i-2])

        # Return the smaller of the two last steps (since two steps could be taken from the second last step out)
        return min(min_cost[-1], min_cost[-2])",1
"class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
    	M = max(nums)
    	return nums.index(M) if len([0 for i in nums if 2*i <= M]) == len(nums)-1 else -1
		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def shortestCompletingWord(self, l: str, w: List[str]) -> str:
        res={}
        lp=l.lower()
        d={}
        for i in lp:
            if i.isalpha():
                d[i]=lp.count(i)
        for i in w:
            j=i.lower()
            c=0
            for k in d.keys():
                if j.count(k)<d[k]:
                    c=1
                    break
            if c==0:
                m=res.get(len(j),[])
                res[len(j)]=m+[j]
        return res[(min(list(res.keys())))][0]",1
"class Solution:
    def containVirus(self, isInfected: List[List[int]]) -> int:

        # return number of walls needed
        def dfs(r, c):

            # return
            if (r, c) in visited or r < 0 or c < 0 or r >= m or c >= n:
                return 0

            # contained cells
            if isInfected[r][c] == -1:
                return 0
            
            # uninfected cells
            if isInfected[r][c] == 0:
                risky.add((r, c))
                return 1
            
            # infected cells
            visited.add((r ,c))
            walls = 0
            if isInfected[r][c] == 1:
                walls += dfs(r+1, c)
                walls += dfs(r-1, c)
                walls += dfs(r, c+1)
                walls += dfs(r, c-1)

            return walls
        
        m, n = len(isInfected), len(isInfected[0])
        total_wall = 0

        while True:
            # store (len(risky), risky, wall, starting points)
            gettingInfected = []
            visited = set()
            for i in range(m):
                for j in range(n):
                    if isInfected[i][j] == 1 and isInfected[i][j] not in visited:
                        risky = set()
                        w = dfs(i, j)
                        gettingInfected.append((-len(risky), risky, w, i, j))

            
            # heapy the gettingInfectious array to get the max len of risky
            heapq.heapify(gettingInfected)

            if not gettingInfected or gettingInfected[0][2] == 0:
                return total_wall

            # mark the infected cells as contained starting from (i, j)
            lr, risky, w, i, j = heapq.heappop(gettingInfected)
            # maybe a dfs for marking the cells?
            queue = collections.deque([(i, j)])
            while queue:
                r, c = queue.pop()
                if r < 0 or c < 0 or r >= m or c >= n or isInfected[r][c] != 1:
                    continue

                isInfected[r][c] = -1

                queue.append((r+1, c))
                queue.append((r-1, c))
                queue.append((r, c+1))
                queue.append((r, c-1))

            # increment the total walls
            total_wall += w
            for area in gettingInfected:
                riskyCells = area[1]
                for cell in riskyCells:
                    r, c = cell
                    isInfected[r][c] = 1",0
"class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        mp, queue, vis, ans = Counter(deadends), deque(), Counter(), 0
        
        if mp['0000'] > 0:
            return -1
        queue.append(['0','0','0','0'])
        vis['0000'], len_q = 1, 1
        while len_q:
            ans += 1
            while len_q:
                var = queue.popleft()
                digit = ''.join(var)
                if digit == target:
                    return ans - 1
                for i in range(4):
                    ch = var[i]
                    forw, rev = int(ch) + 1 if int(ch) + 1 < 10 else 9 - int(ch), int(ch) - 1 if int(ch) - 1 >= 0 else 9 + int(ch)
                    for direction in [forw, rev]:
                        var[i] = str(direction)
                        digit = ''.join(var)
                        if mp[digit] == 0 and vis[digit] == 0:
                            queue.append([d for d in digit])
                            vis[digit] = 1
                    var[i] = ch
                len_q -= 1
            len_q = len(queue)
        return -1",0
"class Solution:
    def crackSafe(self, n: int, k: int) -> str:

        total = k**n-1
        start = '0' * n
        visited = set()
        visited.add('0' * n)
        self.ans = '0' * n

        def dfs(total,start):
            if total == 0: 
                return True
            for i in range(k):
                last = start[1:n]
                #print(last+str(i))
                end = last+str(i)
                if end not in visited:
                    visited.add(end)
                    total = total-1
                    self.ans = self.ans+str(i)
                    if dfs(total, end):
                        return True
                    else:
                        visited.remove(end)
                        total = total+1
                        self.ans = self.ans[:-1]
                        #print(""l"")
            return False

        dfs(total,start)
        return self.ans",1
"class Solution:
    def reachNumber(self, target: int) -> int:
        t = abs(target)
        n = int(((1+8*t)**.5-1)/2)
        LT = n*(n+1)//2
        if LT == t: return n
        if (LT + n + 1 - t) % 2 == 0: return n + 1
        return n + 3 - n % 2
			
			
	- Python 3
	- Junaid Mansuri",1
"class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mem = dict()
        mem2 = set()
        for a in allowed:
            if a[:2] not in mem:
                mem[a[:2]] = list()
            
            mem2.add(a[0])

            mem[a[:2]].append(a[-1])
        
        n = len(bottom)

        def helper(cur_sol, i, j):
            if i == n:
                return True
            
            l, r = cur_sol[i - 1][j], cur_sol[i - 1][j + 1]
            if l + r in mem:
                for candidate in mem[l + r]:
                    if j == 0 or (j > 0 and cur_sol[i][j - 1] + candidate in mem):
                        if j == n - i - 1 or (j < n - i - 1 and candidate in mem2):
                            cur_sol[i].append(candidate)
                            if j < n - i - 1:
                                next_i, next_j = i, j + 1
                            else:
                                next_i, next_j = i + 1, 0
                            if helper(cur_sol, next_i, next_j):
                                return True

                            cur_sol[i].pop()

            return False

        cur_sol = [list(bottom)] + [list() for _ in range(n - 1)]
        return helper(cur_sol, 1, 0)",0
"class Solution:
    def intersectionSizeTwo(self, A: List[List[int]]) -> int:
        A.sort(key=lambda x:(x[1],-x[0]))
        ans = []
        ans.append(A[0][1]-1)
        ans.append(A[0][1])
        n = len(A)
        # print(A)
        for i in range(1,n):
            if A[i][0]>ans[-1]:
                ans.append(A[i][1]-1)
                ans.append(A[i][1])
            elif A[i][0]>ans[-2]:
                ans.append(A[i][1])
        # print(ans)
        return len(ans)",1
"class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        
        def fn(lo, hi): 
            if lo == hi: return """"
            vals = []
            ii, prefix = lo, 0
            for i in range(lo, hi):
                prefix += 1 if s[i] == ""1"" else -1 
                if prefix == 0: 
                    vals.append(""1"" + fn(ii+1, i) + ""0"")
                    ii = i+1
            return """".join(sorted(vals, reverse=True))
        
        return fn(0, len(s))",0
"class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        count=0
        s=[2,3,5,7,11,13,17,19,23,29,31]
        for i in range(left,right+1):
            if(bin(i).count('1') in s):
                count+=1
        return count",1
"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        
        # calculate last window index of each character in string
        # This will help to define the current window boundary
        last_idx = {c:i for i,c in enumerate(s)}    
                
        # Start with window size 1             
        res = [1]
        # define the boundary based on first character
        end = last_idx[s[0]]     
        
        # Following loop is similar to merge intervals
        # start the loop at index 1
        for i in range(1, len(s)):            
            if i <= end:
                # update current window boundary
                # and also the current window length
                end = max(end, last_idx[s[i]])
                res[-1] += 1
            else:
                # add the next window 
                res.append(1)
                end = last_idx[s[i]]
        
        return res",1
"class Solution:
    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        dp = [[n] * n for _ in range(n)]
        for i, j in mines:
            dp[i][j] = 0
        
        for i in range(n):
            left = up = right = down = 0
            for j in range(n):
                if dp[i][j] == 0:
                    left = 0
                else:
                    left += 1
                    dp[i][j] = min(dp[i][j], left)
                
                if dp[j][i] == 0:
                    up = 0
                else:
                    up += 1
                    dp[j][i] = min(dp[j][i], up)
                
                j = ~j
                if dp[i][j] == 0:
                    right = 0
                else:
                    right += 1
                    dp[i][j] = min(dp[i][j], right)
                
                if dp[j][i] == 0:
                    down = 0
                else:
                    down += 1
                    dp[j][i] = min(dp[j][i], down)
        
        return max(val for row in dp for val in row)",0
"class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        d = {v: k for k, v in enumerate(row)} # get the number->position dictionary
        count = 0
        for i in range(0, len(row), 2):
            pair = row[i]^1 # use XOR to find pair number
            if row[i+1] == pair: continue
            pos = d[pair]
            row[i+1], row[pos] = row[pos], row[i+1] # find the pair of row[i]
            d[row[pos]] = pos # update row[pos] position in dictionary
            count += 1
        return count",0
"class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        for i in range(1 ,len(matrix)):
            for j in range(1, len(matrix[0])):
                if matrix[i - 1][j - 1] != matrix[i][j]:
                        return False
        return True",1
"class Solution:
    def reorganizeString(self, S: str) -> str:
        L, A, m, B = len(S), [0]*len(S), 1-len(S) % 2, []
        for k,v in collections.Counter(S).most_common(): B += k*v
        for i,c in enumerate(B):
            I = (2*i + (2*i >= L)*m) % L
            A[I] = c
            if I != 0 and A[I-1] == c: return ''
        return """".join(A)
		
		
- Junaid Mansuri",1
"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        n=len(arr)
        que=[]
        res=0
        for i in range(n-1,-1,-1):
            if not que or arr[i]<=que[0]:
                que.insert(0,arr[i])
                res+=1
            else:
                a=bisect_left(que,arr[i])
                if len(que)-1-a<0:
                    que=que[0:1]
                    res=1
                elif a-1!=0:
                    res=len(que)-a+1
                    que=que[0:1]+que[a:]
        return res",0
"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        largest_chunk=0
        start=0
        for i in range(len(arr)):
            visited=[False]*len(arr)
            for j in range(start,i+1):
                visited[arr[j]]=True
            if all(visited[start:i+1]):
                largest_chunk+=1
                start=i+1
        return largest_chunk",1
"class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        count = 0
        for s in jewels:
            count += stones.count(s)
        return count",1
"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        board = board[0] + board[1] # flatten into vector 
        
        ans = 0 
        seen = set([tuple(board)])
        queue = [board]
        while queue: 
            newq = []
            for x in queue: 
                if x == [1,2,3,4,5,0]: return ans 
                k = x.index(0)
                for kk in (k-1, k+1, k-3, k+3): 
                    if 0 <= kk < 6 and (k, kk) not in ((2, 3), (3, 2)):
                        xx = x.copy()
                        xx[k], xx[kk] = xx[kk], xx[k]
                        if tuple(xx) not in seen: 
                            seen.add(tuple(xx))
                            newq.append(xx)
            queue = newq 
            ans += 1
        return -1",0
"class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        m=float('inf')
        for i in range(len(A)-1,1,-1):
            m=min(m,A[i])
            if A[i-2]>m:
                return False
        return True",1
"class Solution:
    def canTransform(self, start: str, end: str) -> bool: 
        ret_0 = collections.defaultdict(int)
        ret_1 = collections.defaultdict(int)
        lst_0, lst_1 = [[]]*2
        r0, r1 = [""""]*2 
        i = 0
        while i < len(start):
            if start[i] in ""LR"":
                ret_0[start[i]] += 1
                r0 += start[i]
            if end[i] in ""LR"":
                ret_1[end[i]] += 1
                r1 += end[i]
            if ret_0[""R""] >= ret_1[""R""] and ret_0[""L""] <= ret_1[""L""]:
                pass
            else:
                return False
            i += 1
                 
        return True if r0 == r1 else False",0
"class Solution:
    def swimInWater(self, grid) -> int:
        rows = len(grid)
        cols = len(grid[0])
        T = [[float('-inf') for _ in range(cols)] for _ in range(rows)]
        stack = [(grid[0][0], 0,0)]

        visited = {}

        while stack:
            time,x,y = heapq.heappop(stack)
            nei = [(1,0), (-1,0), (0,1),(0,-1)]
            for dx,dy in nei:
                nx, ny = x+dx, y+dy
                if (nx,ny) not in visited and nx >= 0 and nx < rows and ny >= 0 and ny < cols:
                    T[nx][ny] = max(grid[nx][ny], time)
                    visited[(nx,ny)] = True
                    if nx == rows-1 and ny == cols-1:
                        return T[-1][-1]
                    heapq.heappush(stack, (max(grid[nx][ny], time), nx, ny))

        return T[-1][-1]",0
"class Solution:
    def kthGrammar(self, N: int, K: int) -> int:
        memo = {(1,1): 0}
        def helper(n,k):
            if (n,k) in memo: 
                return memo[(n,k)]
                
            if k==1: return 0
            
            t = helper(n-1, math.ceil(k/2))
            if t==0:
                if k%2==0: return 1
                else: return 0
                
            if t==1:
                if k%2==0: return 0
                else: return 1
                
        return helper(N,K)",0
"class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        # if both of sx, sy are even, only evens can be generated, but not all evens can be generated 
        # as such, if you have any odds only in the end target, return false 
        if (sx % 2 == sy % 2 == 0) and ((tx % 2 != 0) or (ty % 2 != 0)) : 
            return False 
        # or if you have matches that are exactly equal, return True 
        elif (sx == sy == tx == ty) or (sx == tx and sy == ty) : 
            return True
        else : 
            # otherwise, return the euclidean gcd procession 
            return self.euclidean_gcd(sx, sy, tx, ty)

    def euclidean_gcd(self, sx, sy, tx, ty) : 
        # loop while tx and ty are greater than or equaal to their target 
        # count = 0 
        # loop zero printing can be commented out 
        # self.print_euclidean_progression(sx, sy, tx, ty, count)
        while (tx >= sx) and (ty >= sy) :
            # if these are equal to each other, break 
            if tx == ty : 
                break
            # otherwise, depending on which is larger 
            elif tx > ty : 
                # if the other target is above their start still 
                if ty > sy : 
                    # modulo reduction to remainder 
                    tx %= ty 
                else : 
                    # if it is at the target, return the modulo result for gcd 
                    return (tx - sx) % ty == 0 
            else : 
                # see above section for logic breakdown 
                if tx > sx : 
                    ty %= tx 
                else : 
                    return (ty - sy) % tx == 0 
            # increment count 
            # count += 1 
            # loop repeats with new values 
            # self.print_euclidean_progression(sx, sy, tx, ty, count)
        # either you broke early due to tx == ty or you completed thee loop when they are less than the valuation 
        # could still be the case that sx == tx and sy == ty 
        # handled by above edge cases for non-loop progression variant 
        # return (sx == tx and sy == ty)
        return False 
    
    def print_euclidean_progression(self, sx, sy, tx, ty, count) : 
        print(""At count "", count, "" the values of sx, sy are "", (sx, sy), "" and the values of tx, ty are "", (tx, ty))",0
"class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        ans = 0
        cnt = defaultdict(int)
        for x in answers: 
            if not cnt[x] % (1 + x): ans += 1 + x # reached capacity &amp; update ans
            cnt[x] += 1
        return ans",1
"class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        
        def fn(vals): 
            """"""Return min moves to transform to chessboard.""""""
            total = odd = 0 
            for i, x in enumerate(vals): 
                if vals[0] == x: 
                    total += 1
                    if i&amp;1: odd += 1
                elif vals[0] ^ x != (1 << n) - 1: return inf
            ans = inf 
            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)
            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)
            return ans 
        
        rows, cols = [0]*n, [0]*n
        for i in range(n): 
            for j in range(n): 
                if board[i][j]: 
                    rows[i] ^= 1 << j 
                    cols[j] ^= 1 << i
        ans = fn(rows) + fn(cols)
        return ans if ans < inf else -1",0
"class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        low = []
        def inorder (root):
            if root is None:
                return 
            inorder(root.left)
            low.append(root.val)
            inorder(root.right)
        inorder(root)
        print(low)
        return min(low[i+1] - low[i]
                   for i in range(len(low) - 1))",1
"class Solution:
    def letterCasePermutation(self, S: str) -> List[str]:
        
        # ending condition
        if len(S)==1:
            if S.isdigit(): return [S]
            else: return [S.lower(), S.upper()]
        
        first_char, remain = S[0], S[1:]
        remain_permutation = self.letterCasePermutation(remain)
        # if digit
        if first_char.isdigit():
            return [str(first_char) + item for item in remain_permutation]
        # if letter
        else:
            return [first_char.lower() + item for item in remain_permutation] + [first_char.upper() + item for item in remain_permutation]",1
"class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:      
        colors = [0]*len(graph)                         # 0: no color, 1: red, -1: green

        def dfs(node: int, node_color: int) -> bool:    # node: current node, node_color: current node's color
            if colors[node] != 0:                       # if current node was already colored
                return colors[node] == node_color       # return True if current node was colored the same
            
            colors[node] = node_color                   # color current node
            for neighbor in graph[node]:                # iterate current node's neighbor nodes
                if not dfs(neighbor, -1*node_color):    # DFS neighbor nodes with different color
                    return False                        # return False if neighbors are non-bipartite (short-circuit)
            return True

        for node in range(len(graph)):
            if colors[node] == 0 and not dfs(node, 1):  # iterate for nodes that are not connected 
                return False                            # return False if a connected nodes are non-bipartite (short-circuit)
            
        return True",0
"class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        pq = [(arr[i]/arr[-1], i, -1) for i in range(len(arr)-1)]
        for _ in range(k): 
            _, i, j = heappop(pq)
            if i - j + 1 < len(arr): heappush(pq, (arr[i]/arr[j-1], i, j-1))
        return [arr[i], arr[j]]",0
"class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        dist_price = [float('inf') for _ in range(n)]
        dist_price[src]=0
        
        for source,dest,cost in flights:
            if src==source:
                dist_price[dest] = cost
        
        for times in range(0,K):
            
            temp = [*dist_price]
            
            for srce,dest,cost in flights:
                temp[dest] = min(temp[dest] , cost + dist_price[srce])
            dist_price = temp
        
        if dist_price[dst] == float('inf'):
            return -1
        return dist_price[dst]",0
"class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        l = [abs(ghost[0]-target[0])+abs(ghost[1]-target[1]) for ghost in ghosts]
        return min(l)>abs(target[0])+abs(target[1])",0
"class Solution:
    def numTilings(self, N: int) -> int:
        f0, f1, f2 = 0, 1, 1
        for i in range(N-1): f0, f1, f2 = f1, f2, (2*f2 + f0) % 1_000_000_007
        return f2",1
"class Solution:
    def customSortString(self, S: str, T: str) -> str:
        letter_count = collections.Counter(T)
        other_letters = set(string.ascii_lowercase) - set(S)
        order = S + ''.join(other_letters)
        result = []
        for letter in order:
            result.extend([letter * letter_count[letter]])
        return ''.join(result)",1
"class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        def isSubSeq(s1, s2):
            iter = 0
            
            for index, val in enumerate(s1):
                if val == s2[iter]:
                    iter += 1
                    
                if iter == len(s2):
                    break
            
            return iter == len(s2)
        
        return sum([1 if isSubSeq(s, w) else 0 for w in words])",1
"class Solution:

    def preimageSizeFZF(self, k: int) -> int:
        if k < 5:
            return 5
        elif k == 5:
            return 0
        left, right = 4, 5 * k
        while left < right:
            middle = (left + right) // 2
            zeros = sum(middle // pow(5, p)
                        for p in range(1, int(log(middle, 5)) + 1))
            if zeros < k:
                left = middle + 1
            elif zeros > k:
                right = middle - 1
            else:
                return 5
        return 0",1
"class Solution:
    def validTicTacToe(self, b: List[str]) -> bool:
    	T, w = {'XXX':0, 'OOO':0}, """".join(b).count('X') - """".join(b).count('O')
    	for i in [0,1,2]: T[b[0][i]+b[1][i]+b[2][i]], T[b[i][0]+b[i][1]+b[i][2]], T[b[0][2*i//2]+b[1][1]+b[2][2*(1-i//2)]] = 1, 1, 1
    	return False if (w not in [0,1]) or (T['XXX'] == 1 and w != 1) or (T['OOO'] == 1 and w != 0) else True
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        ans, prev = 0, 0
        i, j = 0, 0
        n = len(nums)
        
        for j in range(n):
            if left <= nums[j] <= right:
                prev = (j-i+1)
                ans += prev
            elif nums[j] < left:
                ans += prev
            else:
                i, prev = j+1, 0
        
        return ans",0
"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) == len(goal):
            x = 2*s
            return goal in x
        return False",1
"class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        total = [[0]]
        ans = []
        target = len(graph) - 1
        while total: # start BFS
            itr = total.pop(0)
            last = itr[-1]
            possible = graph[last]
            if not possible: #not possible means no valid edge stars with the end of this path
                continue
            for i in possible:
                if i == target: #find valid path, concact the target, and append it to answer
                    ans.append(itr + [target])
                    continue
                total.append(itr + [i]) #add all pending path to the end of the queue
        return ans",0
"class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff = [1] * len(nums)
        for i, x in enumerate(nums): 
            diff[(i-x+1) % len(nums)] -= 1
        prefix = list(accumulate(diff))
        return prefix.index(max(prefix))",1
"class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        
        
        dp =[ [0]*row for row in range(1,100+2) ]
        
        
        dp[0][0] = poured
        
        
        for i in range(query_row+1):
            
            for j in range(i+1):# calculating the amount of liquid which will left after completely filling this cup
                
                left = (dp[i][j] -1)/2
                
                if left >0:
                    dp[i+1][j]+=left
                    dp[i+1][j+1]+=left
                    
        return min(1, dp[query_row][query_glass])",1
"class Solution:
    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [[-1]*2 for i in range(len(nums1))]
        
        def solve(prev1, prev2, i, swaped):
            if i >= len(nums1): return 0
            if dp[i][swaped] != -1: return dp[i][swaped]
                        
            ans = 2**31
            
            # No Swap
            if nums1[i] > prev1 and nums2[i] > prev2:
                ans = solve(nums1[i], nums2[i], i+1, 0) 
            
            # Swap
            if nums1[i] > prev2 and nums2[i] > prev1:
                ans = min(ans, 1 + solve(nums2[i], nums1[i], i+1, 1)) 
            
            dp[i][swaped] = ans
            return ans
        
        return solve(-1, -1, 0, 0)",0
"class Solution:
    
    def is_cycle(self, graph: List[List[int]], node: int, is_visited: Set, is_safe: Set) -> bool:
        
        # IF node is already visited, return cycle detected true
        if node in is_visited:
            return True
        
        # IF node is already explored, and no cycle detected, return False
        if node in is_safe:
            return False
        
        # Add node to is_visited set
        is_visited.add(node)
        
        # Try to detect cycle in path of adjacent nodes
        for adj_node in graph[node]:
            if self.is_cycle(graph, adj_node, is_visited, is_safe):
                return True
        
        # Backtrack: Very important, as there can be many paths going through the same node.
        # And we might not have explored all of them. So remove the node from the visited set
        # and mark it as safe
        is_visited.remove(node)
        
        # Mark node as safe, as no cycle detected in its path
        is_safe.add(node)
        
        return False
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        
        # Init
        is_safe = set()
        is_visited = set()
        
        # Try to detect cycle for all the nodes
        for node in range(len(graph)):
            if node not in is_visited:
                self.is_cycle(graph, node, is_visited, is_safe)
                
        # Make sorted array of is_safe set
        is_safe = sorted(list(is_safe))
        
        return is_safe",0
"class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        code=["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
        transformation=set()
        for word in words:
            s=''
            for letter in word:
                s=s+code[ord(letter)-97]
            transformation.add(s)
        return len(transformation)",0
"class Solution:
    def splitArraySameAverage(self, A: List[int]) -> bool:
        A.sort()
        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket
        all_sum=sum(A)
        DP[0]=set([0])
        for item in A:                  #iterate over items in the list
            for count in range(len(DP)-2,-1,-1):          # iterate backwards w.r.t. the bracket size
                if len(DP[count])>0:                             # if DP[i] is not empty, then update DP[i+1] by adding the current item into all sums in DP[i]
                    for a in DP[count]:
                        DP[count+1].add(a+item)
        for size in range(1,len(DP)):
            if all_sum*size/len(A) in DP[size]:
                return True
        return False",0
"class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        letter_w = {chr(97 + i): widths[i] for i in range(26)}
        n_lines = line_len = 0
        for c in s:
            line_len += letter_w[c]
            if line_len > 100:
                n_lines += 1
                line_len = letter_w[c]
        return [n_lines + (line_len > 0), line_len]",1
"class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        # the vertical skyline is the max # of each column
        # the horizontal skyline is the max # of each row
        
        # a building's height should be min(max of that row, max of that column)
        
        size = len(grid)
        
        columns = rows_to_columns(grid)
        
        row_maxs = list(max(row) for row in grid) # horizontal skyline
        
        column_maxs = list(max(column) for column in columns) # vertical skyline
        
        total_increase = 0
        
        for row in range(size):
            row_max = row_maxs[row]
            for column in range(size):
                column_max = column_maxs[column]
                max_height = min(column_max, row_max)
                actual_height = grid[row][column]
                total_increase += max_height - actual_height
                
        return total_increase
                
def rows_to_columns(grid: List[List[int]]):
    columns = []
    for i in range(len(grid)):
        column = []
        for row in grid:
            column.append(row[i])
        columns.append(column)
    return columns",1
"class Solution:
    def soupServings(self, n: int) -> float:
        if n >= 4276: return 1.0

        @lru_cache(None)
        def f(a: int, b: int)->float:
            if a <= 0 and b <= 0: return 0.5
            if a <= 0: return 1
            if b <= 0: return 0
            return (f(a-100,b) + f(a-75,b-25) + f(a-50,b-50) + f(a-25,b-75))*.25
        
        return f(n,n)",0
"class Solution:
    def expressiveWords(self, S: str, W: List[str]) -> int:
        LW, C, n = len(W), [], 0
        for s in [S]+W:
            C.append([[],[]])
            for k,g in itertools.groupby(s): C[-1][0].append(k), C[-1][1].append(len(list(g)))
        LC = len(C[0][0])
        for i in range(1,LW+1):
            if C[0][0] != C[i][0]: continue
            for j in range(LC):
                if C[i][1][j] > C[0][1][j] or (C[i][1][j] < C[0][1][j] and C[0][1][j] == 2): break
            else: n += 1
        return n
                
				
- Junaid Mansuri",0
"class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        return reduce(xor, nums) == 0 or not len(nums)&amp;1",0
"class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d= {}
        for cpdomain in cpdomains:
            page = """"      
            count, full_page = cpdomain.split(' ')
            sub_doms = full_page.split('.')[::-1]
            curr_page =""""
            for dom in  sub_doms:
                curr_page = dom + curr_page
                if curr_page in d:
                    d[curr_page]  += int(count)
                else:
                    d[curr_page]  = int(count)
                curr_page = '.' + curr_page                
        return [  "" "".join([str(count), site]) for site,count in d.items()]",0
"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        def area(x1, y1, x2, y2, x3, y3):
            return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2
        
        n = len(points)
        res = 0
        for i in range(n - 2):
            x1, y1 = points[i]
            for j in range(i + 1, n - 1):
                x2, y2 = points[j]
                for k in range(j + 1, n):
                    x3, y3 = points[k]
                    res = max(res, area(x1, y1, x2, y2, x3, y3))
        
        return res",0
"class Solution:
    def largestSumOfAverages(self, A: List[int], K: int) -> float:
        s=[0]
        for i in A:
            s.append(i+s[-1]);
        n=len(s);
        mini= -200000
        d={};
        def fun(old,new,k):
            temp=(old,new,k);
            if(temp in d.keys()): return d[temp]
            if(new>=n) or (old>=n):
                return mini;
            if(k==1):
                return (s[-1]-s[old])/(n-1-old);
            d[temp]= max(fun(old,new+1,k),fun(new,new+1,k-1)+((s[new]-s[old])/(new-old)) );
            return d[temp]
        return fun(0,1,K);
		```",0
"class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
		# Base case - return None if node does not exist
        if root is None:
            return None
        else:
			# recursively traverse the left and right subtrees 
            root.left = self.pruneTree(root.left)
            root.right = self.pruneTree(root.right)
			
			# Condition to check if subtree doesn't have 1 as node value i.e root.val == 0
            if root.left is None and root.right is None and root.val == 0:
                return None
            else:
                return root",1
"class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == target:
            return 0
        set_routes = [set(route) for route in routes]
        start_buses = [i for i, s in enumerate(set_routes) if source in s]
        state = set()
        for i in start_buses[::-1]:
            state.update(set_routes.pop(i))
        if target in state:
            return 1
        n_buses = 1
        while state:
            new_state = set()
            n_buses += 1
            new_busses = [i for i, s in enumerate(set_routes) if state &amp; s]
            for i in new_busses[::-1]:
                new_state.update(set_routes.pop(i))
            if target in new_state:
                return n_buses
            state = new_state
        return -1",0
"class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        s = s[1:-1]
        sp = [(s[:x], s[x:]) for x in range(1,len(s))]
        o = []
        for left, right in sp:
            la = []
            if left[0] == '0' and len(left) > 1 and set(left) != set([""0""]):
                if left[1:][-1] != '0':                
                    la.append((left[:1] + '.' + left[1:]))
            else:
                if (len(left) > 1 and set(left) != set([""0""])) or len(left) == 1:
                    la.append(left)
                    for y in range(1, len(left)):
                        if int(left[y:]) != 0 and left[y:][-1] != '0':
                            la.append((left[:y] + '.' + left[y:]))
                            
            ra = []
            if right[0] == '0' and len(right) > 1 and set(right) != set([""0""]):
                if right[1:][-1] != '0':
                    o += [""(%s, %s)""%(i, (right[:1] + '.' + right[1:])) for i in la]
            else:
                if (len(right) > 1 and set(right) != set([""0""])) or len(right) == 1:                 
                    o += [""(%s, %s)""%(i, right) for i in la]
                    for y in range(1, len(right)):
                        if int(right[y:]) != 0 and right[y:][-1] != '0':
                            rightside = right[:y] + '.' + right[y:]
                            o += [""(%s, %s)""%(i, rightside) for i in la]
                    
        return o",0
"class Solution:
    def racecar(self, target: int) -> int:
        dq=deque([(0,0,1)])
        while dq:
            move,pos,speed=dq.popleft()
            if pos==target:
                return move
            dq.append((move+1,pos+speed,speed*2))
            if (pos+speed>target and speed>0) or pos+speed<target and speed<0:
                speed=-1 if speed>0 else 1
                dq.append((move+1,pos,speed))
            else:
                continue",0
"class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        result = ''
        word_count = {}
        
        # Replace all puctuations with white spaces
        paragraph = paragraph.lower()\
                             .replace('!', ' ')\
                             .replace('?', ' ')\
                             .replace('\'', ' ')\
                             .replace(',', ' ')\
                             .replace(';', ' ')\
                             .replace('.', ' ')
        
        # Split paragraph by white spaces (irrespective of the nubmer of white spaces)
        for w in paragraph.split():
            if w not in banned: # Optional: can use set() to drop duplicates in banned
                # Increase word count
                word_count[w] = word_count.get(w, 0) + 1
                
                # If new word has a count greater than previous word then replace resulting word
                if word_count[w] > word_count.get(result, 0): 
                    result = w
        
        return result",0
"class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words = sorted(words,key=len)
        #print(words)
        ret = ''
        for w in words[::-1]:
            if (w+'#') not in ret:
                ret = ret + w +'#'
        #print(ret)
        return len(ret)",1
"class Solution:
    def shortestToChar(self, S: str, C: str) -> List[int]:
        l=[]
        x=[]
        for i in range(len(S)):
            if(S[i]==C):
                l.append(i)
        a=l[0]
        b=l[len(l)-1]
        k=0
        for i in range(len(S)):
            if(i<a):
                x.append(a-i)
            elif(i>b):
                x.append(i-b)
            else:
                if(i==l[k]):
                    x.append(0)
                    if(k<len(l)-1):
                        k+=1
                        continue
                else:
                    x.append(min(i-l[k-1],l[k]-i))
        return x",1
"class Solution:
    def flipgame(self, f: List[int], b: List[int]) -> int:
    	return min(set(f+b)-set(f[i] for i in range(len(f)) if f[i] == b[i]), default = 0)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        
        arr.sort()
        
        memo={}
        memo[arr[0]] = 1
        
        for i in range(1, len(arr)):
            count = 1
            for j in range(0, i):
                if arr[i]/arr[j] in memo:
                    count+=memo[arr[j]]*memo[arr[i]/arr[j]]
            memo[arr[i]] = count
        return sum(memo.values()) % (10**9+7)",1
"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        
        #vars
        output = ''
        goatword = ''
        vowles = list(['a', 'e', 'i', 'o', 'u'])

        #enumerate and iterate
        for idx, word in enumerate(sentence.split(' ')):
            goatword = ''
            if word[0:1].lower() in vowles:
                goatword = word+'ma'
            elif word[0:1].lower() not in vowles:
                goatword = word[1:len(word)]+word[0:1]+'ma'

            #add extra a based on word position
            goatword = goatword + 'a'*(idx+1) + ' '

            #update output word
            output = output + goatword

        return(output.rstrip())",1
"class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        requests = 0
        ages_le = [0 for _ in range(121)]
        for age in ages:
            ages_le[age] += 1
        for index in range(1, 121):
            ages_le[index] += ages_le[index-1]
        for age in ages:
            age_lower_bound = int(age//2) + 8
            age_upper_bound = age
            too_young = 0
            if age_lower_bound > age_upper_bound:
                continue
            if age_lower_bound < 0:
                continue
            elif age_lower_bound > 0:
                too_young = ages_le[age_lower_bound-1]
            requests += ages_le[age_upper_bound] - 1 - too_young
        return requests",0
"class Solution:
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        d = defaultdict(int)
        for k,v in zip(difficulty,profit):
            d[k] = max(d[k],v)
        bucket = [0 for _ in range(max(worker)+1)]
        val = 0
        for i in range(len(bucket)):
            if i in d:
                val = max(val,d[i])
            bucket[i] = val
        return sum([bucket[w] for w in worker])",0
"class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        mark = 2
        islands = []
        n = len(grid)
        
        def mark_it(x, y):  # marks island and returns square of that island
            grid[x][y] = mark
            s = 1
            for xn in (x - 1, x + 1):
                if 0 <= xn < n and grid[xn][y] == 1:
                    s += mark_it(xn, y)
            for yn in (y - 1, y + 1):
                if 0 <= yn < n and grid[x][yn] == 1:
                    s += mark_it(x, yn)
            return s
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    islands.append(mark_it(i, j))
                    mark += 1
        
        if not islands: return 1
        
        ret = max(islands)
        
        def check_it(x, y):  # returns sum of adjacent islands to zero cell
            adj = []
            for xn in (x - 1, x + 1):
                if 0 <= xn < n and grid[xn][y] != 0:
                    adj.append(grid[xn][y] - 2)
            for yn in (y - 1, y + 1):
                if 0 <= yn < n and grid[x][yn] != 0:
                    adj.append(grid[x][yn] - 2)
            if not adj: return 0
            return sum([islands[a] for a in set(adj)])
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 0:
                    ret = max(ret, 1 + check_it(i, j))
        return ret",0
"class Solution:
		def uniqueLetterString(self, s: str) -> int:
			res = 0
			n = len(s)
			# dp_keys stores all keys in a substring
			dp_keys = [[set() for _ in range(n)] for _ in range(n)]
			# dp_unqs stores all unique characters in a substring
			dp_unqs = [[set() for _ in range(n)] for _ in range(n)]
			# dp_count stores the number of unique characters in a substring
			dp_count = [[0 for _ in range(n)] for _ in range(n)]
			for i in range(n):
				dp_keys[i][i] = set(s[i])
				dp_unqs[i][i] = set(s[i])
				dp_count[i][i] = 1
				res += 1

			for end_i in range(n):
				for start_i in range(end_i - 1, -1, -1):
					if s[start_i] not in dp_keys[start_i + 1][end_i]:
						tmp = copy.deepcopy(dp_keys[start_i + 1][end_i])
						tmp.add(s[start_i])
						dp_keys[start_i][end_i] = tmp
                
						tmp = copy.deepcopy(dp_unqs[start_i + 1][end_i])
						tmp.add(s[start_i])
						dp_unqs[start_i][end_i] = tmp
                
						dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] + 1
						res += dp_count[start_i][end_i] 
					else:
						dp_keys[start_i][end_i] = dp_keys[start_i + 1][end_i]
						if s[start_i] in dp_unqs[start_i + 1][end_i]:
							tmp = copy.deepcopy(dp_unqs[start_i + 1][end_i])
							tmp.remove(s[start_i])   
							dp_unqs[start_i][end_i] = tmp
							dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] - 1
							res += dp_count[start_i][end_i] 
						else:
							dp_unqs[start_i][end_i] = dp_unqs[start_i + 1][end_i]
							dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] 
							res += dp_count[start_i][end_i]
			return res",0
"class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        ans = 0
        for x in range(1, int(sqrt(2*n))+1): 
            if (n - x*(x+1)//2) % x == 0: ans += 1
        return ans",1
"class Solution:
    def maskPII(self, S: str) -> str:
        if ""@"" in S: # email address
            name, domain = S.lower().split(""@"")
            return f""{name[0]}*****{name[-1]}@{domain}""
        else: # phone number 
            d = """".join(c for c in S if c.isdigit())
            ans = f""***-***-{d[-4:]}""
            return ans if len(d) == 10 else f""+{'*'*(len(d)-10)}-"" + ans",1
"class Solution:
    def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:
        for i, s, t in sorted(zip(indexes, sources, targets), reverse=True): 
            if S[i:i+len(s)] == s: S = S[:i] + t + S[i+len(s):]
        return S",0
"class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        count = [1]*n
        res = [0]*n
                
        g = defaultdict(list)
        
        for s,e in edges:
            g[s].append(e)
            g[e].append(s)
            
        visited = set()
        
        def dfs_count_up_to_0(node):
            visited.add(node)
            
            for c in g[node]:
                if c not in visited:
                    count[node] += dfs_count_up_to_0(c)
                    res[node] += res[c] + count[c]
            return count[node]
        
        
        def dfs_fill_up_rest(node):
            visited.add(node)
            for c in g[node]:
                if c not in visited:
                    res[c] =  res[node] - count[c] + n - count[c]
                    dfs_fill_up_rest(c)
            
        dfs_count_up_to_0(0)
        
        visited.clear()
        
        dfs_fill_up_rest(0)
        
        return res",1
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        reduce_list = lambda lst: sum([1 << i for i,a in enumerate(lst) if a == 1])
        img1, img2 = list(map(reduce_list, img1)), list(map(reduce_list, img2))
        count_bits = lambda num: sum((num>>i)&amp;1 for i in range(n))   
        overlap = lambda lst1, lst2, sx1, sx2, sy1, sy2: sum(count_bits((row1>>sx1) &amp; (row2>>sx2)) for row1,row2 in zip(lst1[sy1:], lst2[sy2:]))
        overlap_xy = lambda lst1, lst2, dx, dy: overlap(lst1, lst2, dx if dx > 0 else 0, 0 if dx > 0 else -dx, dy if dy > 0 else 0, 0 if dy > 0 else -dy )
        return max(overlap_xy(img1, img2, dx, dy) for dx in range(-n+1, n) for dy in range(-n+1, n))",0
"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        if (rec1[0] == rec1[2] or rec1[1] == rec1[3] or rec2[0] == rec2[2] or rec2[1] == rec2[3]):
            return False

        return not (rec1[2] <= rec2[0] or rec1[3] <= rec2[1] or rec1[0] >= rec2[2] or rec1[1] >= rec2[3])",0
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = collections.deque([float(i <= n) for i in range(k, k + maxPts)])
        s = sum(dp)
        for i in range(k):
            dp.appendleft(s / maxPts)
            s += dp[0] - dp.pop()
        
        return dp[0]",1
"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        mp = [0]*len(dominoes)
        ii = len(dominoes)
        for i in reversed(range(len(dominoes))): 
            if dominoes[i] != ""."": ii = i 
            mp[i] = ii 
            
        ans = []
        ii = -1 
        for i, x in enumerate(dominoes): 
            if dominoes[i] in ""LR"": 
                ans.append(dominoes[i])
                ii = i 
            else: 
                ll = ""L"" if ii == -1 else dominoes[ii]
                rr = ""R"" if mp[i] == len(dominoes) else dominoes[mp[i]]
                if ll == rr: ans.append(ll)
                elif ll == ""L"": ans.append(""."")
                else: 
                    if i - ii < mp[i] - i: ans.append(""R"")
                    elif i - ii > mp[i] - i: ans.append(""L"")
                    else: ans.append(""."")
        return """".join(ans)",0
"class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        def similar(word1, word2):
            diff = []
            for a,b in zip(word1, word2):
                if a != b:
                    diff.append((a,b))
                    if diff and len(diff) > 2:
                        return False
            if diff and sorted(diff[0]) != sorted(diff[1]):
                return False
            return True
        
        graph = {}
        for i in range(len(strs)):
            graph[strs[i]] = []
            for j in range(len(strs)):
                if i != j and similar(strs[i], strs[j]):
                    graph[strs[i]].append(strs[j])
        # print(graph)
        
        visited = set()
        q = deque()
        group_count = 0
        for i in range(len(strs)):
            if strs[i] not in visited:
                group = []
                q.append(strs[i])
                while q:
                    node = q.popleft()
                    visited.add(node)
                    group.append(node)
                    for sim in graph[node]:
                        if sim not in visited:
                            q.append(sim)
                # print(group, visited)
                group_count += 1
        return group_count",0
"class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        
        def fn(i, j): 
            """"""Return True if grid[i-1:i+2][j-1:j+2] is a magic squre.""""""
            seen = set()
            row, col = [0]*3, [0]*3 # row sum &amp; column sum 
            diag = anti = 0
            for ii in range(i-1, i+2):
                for jj in range(j-1, j+2):
                    if not 0 <= grid[ii][jj] < 10 or grid[ii][jj] in seen: return False 
                    seen.add(grid[ii][jj])
                    row[ii-i+1] += grid[ii][jj]
                    col[jj-j+1] += grid[ii][jj]
                    if ii-jj == i-j: diag += grid[ii][jj]
                    if ii+jj == i+j: anti += grid[ii][jj]
            return len(set(row)) == 1 and len(set(col)) == 1 and row[0] == col[0] == diag == anti
        
        ans = 0
        for i in range(1, m-1):
            for j in range(1, n-1): 
                if grid[i][j] == 5 and fn(i, j): ans += 1
        return ans",0
"class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        A, B = [0], []
        visited_room_set = set()
        while A:
            B = set([k for r in A for k in rooms[r] if k not in visited_room_set])
            visited_room_set.update(A)
            A, B = B, []
            
        return len(visited_room_set) == len(rooms)",1
"class Solution:
    def splitIntoFibonacci(self, S: str) -> List[int]:
        L, T, t = len(S), """", []
        for i in range(1,L-2):
        	for j in range(1,L-i-1):
        		if (i > 1 and S[0] == '0') or (j > 1 and S[i] == '0'): continue
        		a, b = int(S[:i]), int(S[i:i+j])
        		T, t = S[:i+j], [a,b]
        		while len(T) < L:
        			c = a + b
        			T += str(c)
        			t += [c]
        			a, b = b, c
        		if len(T) == L and T == S and len(t) > 2 and t[-1] < 2**31 - 1: return t
        return []
		
		
- Junaid Mansuri
(Leet Code ID)@hotmail.com",0
"class Solution:
    def findSecretWord(self, wordlist: List[str], master: 'Master') -> None:
        master.guess(master._Master__secret)",0
"class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        stack1 = [] # taking empty stack
        stack2 = [] # taking another empty stack
        
        for i in range(len(s)): # traversing through string s.
            if s[i] is not ""#"": # if the elem is not #
                stack1.append(s[i]) # will push it to the stack1
            else: # if it is ""#"" and there is some elem in stack1 then we`ll pop it else we`ll pass.
                if len(stack1)>0: 
                    stack1.pop()
                else:
                    pass
                
        for i in range(len(t)): # traversing through string t.       
            if t[i] is not ""#"": # if the elem is not #
                stack2.append(t[i]) # will push it to the stack2
            else: # if it is ""#"" and there is some elem in stack2 then we`ll pop it else we`ll pass.
                if len(stack2)>0:
                    stack2.pop()
                else:
                    pass
                
        return stack1 == stack2 # returning if they are equal when both are typed into empty text editors",0
"class Solution:
""""""
192ms 40.16% time
14.7MB 86.68% space
""""""
    def longestMountain(self, A: List[int]) -> int:
        if len(A)<3:return 0
        curr=-1
        itr=1
        while itr+1<len(A):
            if A[itr-1]<A[itr] and A[itr]>A[itr+1]:
                j,k=itr-1,itr+1
                temp=3
                while j-1>=0:
                    if A[j-1]<A[j]:
                        temp+=1
                        j-=1
                    else:break
                while k+1<len(A):
                    if A[k+1]<A[k]:
                        temp+=1
                        k+=1
                    else:break
                curr=max(curr,temp)
            itr+=1
        return curr if curr!=-1 else 0



Java Solution: 2ms beat 96.71%, 40.2MB beats 92.82%

class Solution {
    public int longestMountain(int[] A) {
        if(A.length<3){return 0;}
        int curr=-1;
        int itr=1;
        while(itr+1<A.length){
            if(A[itr]>A[itr+1]&amp;&amp;A[itr]>A[itr-1]){
                int j=itr-1;
                int k=itr+1;
                int temp=3;
                while(j-1>=0){
                    if(A[j-1]<A[j]){
                        temp+=1;
                        j-=1;
                    }
                    else{break;}
                }
                while(k+1<A.length){
                    if(A[k+1]<A[k]){
                        temp+=1;
                        k+=1;
                    }
                    else{break;}
                }
                curr=(curr<temp)?temp:curr;
            }
            itr+=1;
        }
        return (curr!=-1)?curr:0;
    }
}",0
"class Solution:
    def isNStraightHand(self, hand, W):
        """"""
        :type hand: List[int]
        :type W: int
        :rtype: bool
        """"""
        cnt=collections.Counter(hand)
        _h=[]
        for h in hand:
            heapq.heappush(_h,h)
        
        while _h:
            curEle=heapq.heappop(_h)
            if cnt[curEle]==0:
                continue            
            for i in range(W):
                if cnt[curEle+i]<=0:
                    return False   
                else:
                    cnt[curEle+i]-=1
        return True",1
"class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        q = []
        n = len(graph)
        for i in range(n):
            visit = set()
            visit.add(i)
            q.append([i, visit])
        
        steps = 0
        while q:
            num = len(q)
            for i in range(num):
                node, visit = q.pop(0)
                #print(node, visit)
                if len(visit) == n:
                    return steps
                for nei in graph[node]:
                    temp = visit.copy()
                    temp.add(nei)
                    q.append([nei, temp])
            if q:steps += 1",1
"class Solution:
    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        for i in range(len(shifts)-2, -1, -1):
            shifts[i] += shifts[i+1]
        return ''.join(chr((ord(c) - ord('a') + shift) % 26 + ord('a'))
                       for c, shift in zip(S, shifts))",0
"class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        line = []
        for x1, y1, x2, y2 in rectangles: 
            line.append((y1, x1, x2, 1))
            line.append((y2, x1, x2, 0))
        
        ans = yy = val = 0
        seg = []
        for y, x1, x2, tf in sorted(line): 
            ans += val * (y - yy)
            yy = y 
            if tf: insort(seg, (x1, x2))
            else: seg.remove((x1, x2))
            val = 0 
            prev = -inf 
            for x1, x2 in seg: 
                val += max(0, x2 - max(x1, prev))
                prev = max(prev, x2)
        return ans % 1_000_000_007",0
"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output",0
"class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        s,e=0,len(arr)-1
        while s<e:
            m=s+(e-s)//2
            if arr[m]<arr[m+1]:
                s=m+1
            else:
                e=m
        return s",1
"class Solution:  # O(NlogN)
    
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        stack = [] # no. of fleet
        
        # pair of distance and speed to sort it
        pair = [(p,s) for p,s in zip(position,speed) ]
        
        # sort the pair based on positions and travesing from reverse order
        for p,s in sorted(pair)[::-1]:
            
            # find the time
            t = (target - p) /s
            
            stack.append(t)
            
            if len(stack) >= 2 and stack[-1] <= stack[-2]:  #  fleet
                stack.pop()
        
        return len(stack)
		```
		feel free to ask Q...
		#happytohelpu",1
"class Solution:
    def kSimilarity(self, A: str, B: str) -> int:
        la = []
        lb = []
        for a, b in zip(A, B):
            if a != b:
                la.append(a)
                lb.append(b)
        queue = {''.join(la): 0}
        while lb:
            q = {}
            for pre, swap in queue.items():
                if pre[-1] != lb[-1]:
                    eq = []
                    for i, ch in enumerate(pre[:-1]):
                        if ch == lb[-1] and lb[i] != ch:
                            eq.append(i)
                            if lb[i] == pre[-1]:
                                eq = [i]
                                break
                    for i in eq:
                        tmp = pre[:i] + pre[-1] + pre[i + 1:-1]
                        q[tmp] = min(swap + 1, q.get(tmp, float('inf')))
                else:
                    q[pre[:-1]] = min(swap, q.get(pre[:-1], float('inf')))
            lb.pop()
            queue = q
        return list(queue.values())[0]",0
"class Solution:
    def scoreOfParentheses(self, S: str) -> int:
        left_parenthesis_count = 0
        score = 0
        score_flag = False
        for c in S:
            if c == '(':
                left_parenthesis_count += 1
                score_flag = True
            else:
                left_parenthesis_count -= 1
                if score_flag:
                    score += pow(2, left_parenthesis_count)
                    
                score_flag = False
        
        return score",1
"class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:
        
        
        workers=[]
        for w,q in zip(wage, quality):
            workers.append([float(w) / q, q] )
        workers.sort()
        print(workers)                   
        res = float('inf')
        qsum = 0
        heap = []
        for r, q in workers:
            
            heapq.heappush(heap, -q)
            #print(heap)
            qsum += q
            if len(heap) > K:
                qsum += heapq.heappop(heap)
            if len(heap) == K:
                res = min(res, qsum * r)
        print(heap)
        return res",0
"class Solution:
    def mirrorReflection(self, p: int, q: int) -> int:
    	g = math.gcd(p,q)
    	return 2 if not p//g % 2 else q//g % 2
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        l = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                l.append(i)
        return (len(l) == 2 and s[l[0]] == goal[l[1]] and s[l[1]] == goal[l[0]]) or (len(l) == 0 and max(Counter(s).values()) > 1)",0
"class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        # meet 20 , give 10 prior to 5.
        bill_5, bill_10, bill_20 = 0, 0, 0
        for bill in bills:
            if bill == 5:
                bill_5 += 1
            elif bill == 10:
                bill_10 += 1
                bill_5 -= 1
            elif bill == 20:
                if bill_10:
                    bill_10 -= 1
                    bill_5 -= 1
                else:
                    bill_5 -= 3
            if bill_5 < 0:
                return False
        return True",0
"class Solution:
    def matrixScore(self, G: List[List[int]]) -> int:
        G, M, N = list(zip(*[[b^g[0]^1 for b in g] for g in G])), len(G), len(G[0])
        return sum(max(sum(g),M-sum(g))*2**(N-i-1) for i,g in enumerate(G))

		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def shortestSubarray(self, A: List[int], K: int) -> int:
    	C, m, a = [0]+list(itertools.accumulate(A)), float('inf'), collections.deque()
    	for i, c in enumerate(C):
    		while a and C[a[-1]] >= c: a.pop()
    		while a and c - C[a[0]] >= K: m = min(m, i - a.popleft())
    		a.append(i)
    	return -1 if m == float('inf') else m
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # dfs1: generate parent hashmap { node : prnt }
        # this lets us traverse up as well as down
        # then dfs2 starting from target
        # add seen nodes to set to avoid looping, otherwise take K steps away
        # O(N) time, O(N + H) space including recursive calls to tree height

        # helper function to get parents
        def get_prnts(node, parent):
            if not node: return
            d[node] = parent
            get_prnts(node.left, node)
            get_prnts(node.right, node)

        d = {}
        get_prnts(root, None)

        # helper function to step from target
        def rcrs(node, dist):
            if (not node) or (node in seen): return
            seen.add(node)

            if dist == K:
                res.append(node.val)
            else:
                rcrs(node.left, dist+1)
                rcrs(node.right, dist+1)
                rcrs(d[node], dist+1)

        res = []
        seen = set()
        rcrs(target, 0)
        return res

    def distanceK1(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # recursive dfs only: find target, update distance, re-traverse branches
        # dist initially inf until target found
        # O(N) ish time, O(H) recursive call space

        def rcrs(node, dist):
            if node is target:
                dist = 0

            # check distance of kids to target
            lt, rt = float(""inf""), float(""inf"")
            if node.left:  lt = rcrs(node.left, dist+1)
            if node.right: rt = rcrs(node.right, dist+1)

            # update node distance from children if not yet updated
            if dist == float(""inf""): dist = min(lt, rt)

            # add node.val to result list if K steps from target
            if dist == K: self.res.append(node.val)

            # if target found, one branch hasn't seen it, redo said branch
            if dist < float(""inf""):
                if node.left and lt == float(""inf""):  rcrs(node.left, dist+1)
                if node.right and rt == float(""inf""): rcrs(node.right, dist+1)
            return dist+1

        # setup &amp; recursive call
        self.res = []
        rcrs(root, float(""inf""))
        return self.res",0
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        dir = [[1,0], [-1,0], [0,1], [0,-1]]
        m = len(grid)
        n = len(grid[0])
        
        q = []
        k = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '@': q.append([i, j, ''])
                elif grid[i][j].islower(): k += 1

        visited = set()
        moves = 0
        while q:
            new_q = []
            for row, col, keys in q:
                if len(keys) == k: return moves
                if ((row, col, keys) in visited): continue
                visited.add((row, col, keys))
                for r, c in dir:
                    nr, nc = row + r, col + c
                    if nr < 0 or nr == m or nc < 0 or nc == n: continue 
                    val = grid[nr][nc]
                    if val == '#': continue
                    if val == '.' or val == '@' or val in keys: new_q.append([nr, nc, keys])
                    elif val.islower(): new_q.append([nr, nc, keys + val])
                    elif val.lower() in keys: new_q.append([nr, nc, keys])
            moves += 1
            q = new_q
        return -1",0
"class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        # recursive dfs approach
        # helper function: pass ""level"" when descending, return (node, max_depth)
        # if left depth == right_depth, return yourself
        # else return the side with greater depth
        # O(N) time, O(H) stack calls

        def rcrs(node, level):
            if not node: return (None, level-1)

            lt_node, lt_depth = rcrs(node.left, level+1)
            rt_node, rt_depth = rcrs(node.right, level+1)

            if not lt_node and not rt_node:
                return (node, level)

            if lt_depth == rt_depth:
                return (node, lt_depth)
            else:
                if lt_depth > rt_depth:
                    return (lt_node, lt_depth)
                else:
                    return (rt_node, rt_depth)

        # setup &amp; recursive call
        return rcrs(root, 0)[0]",0
"class Solution:
    def primePalindrome(self, k: int) -> int:
        def is_prime(num):
            if num % 2 is 0: return False
            return all(num%i for i in range(3, int(num**0.5)+1, 2))
        
        if k < 12:
            return next(x for x in [2,3,5,7,11] if x >= k)
        else:
            string_k = str(k)
            string_length = len(string_k)
            
            if string_length % 2:
                starting_root = int(string_k[:string_length-string_length//2])
                for root in range(starting_root, 10**6):
                    root = str(root)
                    palindrome_gen = int(root + root[-2::-1])
                    if is_prime(palindrome_gen) and palindrome_gen >= k:
                        return palindrome_gen
            else:
                starting_root = str(10**(string_length-string_length//2))
                starting_reverse = starting_root[-2::-1]
                for root in range(int(starting_root), 10**6):
                    palindrome_gen = int(str(root) + starting_reverse)
                    if is_prime(palindrome_gen) and palindrome_gen >= k:
                        return palindrome_gen",0
"class Solution:
    def transpose(self, A: List[List[int]]) -> List[List[int]]:
        A = list(map(list, zip(*A)))
        return A",1
"class Solution:
    def binaryGap(self, n: int) -> int:
        return max((lambda x: [x[i+1]-x[i] for i in range(len(x)-1)])([i for i,j in enumerate(bin(n)) if j == '1']), default = 0)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def reorderedPowerOf2(self, N: int) -> bool:
        def str2dict(s):
            d = {}
            for i, e in enumerate(s):
                if e in d:
                    d[e] = d[e] + 1
                else:
                    d[e] = 1
            return d
        
        s = str(N)
        l = len(s)
        d = str2dict(s)
        
        i = 0
        result = False
        while not result:
            two_power = 2**i
            s_two_power = str(two_power)
            if len(s_two_power) == l:
                result = str2dict(s_two_power) == d
            elif len(s_two_power) > l:
                break
            i += 1
        return result",1
"class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        A.sort()
        mp = {}
        for x in sorted(B, reverse=True): 
            if x < A[-1]: mp.setdefault(x, []).append(A.pop())
        
        ans = []
        for x in B: 
            if x in mp and mp[x]: 
                ans.append(mp[x].pop())
            else: 
                ans.append(A.pop())
        return ans",1
"class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        ans = k = 0 
        total = startFuel 
        pq = [] 
        while total < target: 
            while k < len(stations) and stations[k][0] <= total: 
                heappush(pq, -stations[k][1]) 
                k += 1
            if not pq: return -1 
            total -= heappop(pq)
            ans += 1
        return ans",1
"class Solution:
	def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
		return self.helper(root1)==self.helper(root2)       
	def helper(self,root):
		res=[]
		if not root:
			return []
		if not root.left and not root.right:
			res.append(root.val)
		res+=self.helper(root.left)
		res+=self.helper(root.right)
		return res",1
"class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
    	L, M, AA = len(A), 0, {i for i in A}
    	for i in range(L-1):
    		for j in range(i+1,L):
    			a, b, s = A[i], A[j], 0
    			while a in AA: a, b, s = b, a + b, s + 1
    			if s > M: M = s
    			if a > A[-1]:
    				if j == i + 1:
    					return 0 if M == 2 else M
    				break
					
					
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        # 0) Keep obstacke in set for future reference
        obstacle_set = set()
        for o in obstacles:
            obstacle_set.add((o[0], o[1]))

        # 1) Define movement functions and way to turn direction
        up = lambda pos: (pos[0], pos[1]+1)
        down = lambda pos: (pos[0], pos[1]-1)
        left = lambda pos: (pos[0]-1, pos[1])
        right = lambda pos: ((pos[0]+1, pos[1]))
        moves = [up, right, down, left]
        cpos = (0, 0)
        mi = 0
        def turn(mi, v):
            return (mi + 1) % 4 if v == -1 else (mi - 1 + 4) % 4

        move = lambda pos: moves[mi](cpos)
        
        # 2) Execute the command(s)
        max_dist = 0
        for cmd in commands:
            if cmd < 0:
                mi = turn(mi, cmd)                
            else:
                for _ in range(cmd):
                    next_pos = move(cpos)
                    if next_pos in obstacle_set:
                        break

                    cpos = next_pos
        
            max_dist = max(max_dist, pow(cpos[0], 2) + pow(cpos[1], 2))
            
        # 3) Return the result
        return max_dist",0
"class Solution:
    def minEatingSpeed(self, piles: List[int], hour: int) -> int:
        l=1
        h=max(piles)
        def fun(speed):
            ans=0
            for i in piles:
                ans+=ceil(i/speed)
            #print(ans)
            if ans>hour:
                return False
            return True
        ans=h
        while(l<=h):
            
            mid=(l+h)//2
           
            if fun(mid):
                ans=min(ans,mid)
                h=mid-1
            else:
                l=mid+1
        return ans",1
"class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pos=0
        curr=head
        while(curr!=None):
            pos+=1
            curr=curr.next
        curr=head
        for i in range(pos//2):
            curr=curr.next
        return curr",1
"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @functools.cache
        def doIWin(l,r):
            if l > r: return 0
            
            left = piles[l] - doIWin(l+1,r) # `-` because my opponent!
            
            right= piles[r] - doIWin(l,r-1)
            
            return max(left, right)
        
        return (doIWin(0,len(piles)-1) + sum(piles) )//2",1
"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x,y):
            if(x==0):
                return y
            return gcd(y%x,x)
        lcm=(a*b)//gcd(a,b)
        s=set()
        x=a
        while(x<=lcm):
            s.add(x)
            x+=a
        x=b
        while(x<=lcm):
            s.add(x)
            x+=b
        
        le=0
        l=[]
   
        for i in s:
            l.append(i)
            le+=1
        l.sort()    #sort all multiples of a and b which are less than their lcm.
        
        #below approach is based on pattern observation. Try to take some example and observer the pattern(e.g n=4,8,9,16,18,41 #a=3, b=7)
        r=n%le
        q=n//(le+1)
      
        if(q==0):
            return l[n-1]
        else:
            q=n//le
            res=  ((q*l[-1])%1000000007)
            if(r>0):
                  res=(res+ l[r-1]) %1000000007
            return res",0
"class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        MOD = 1_000_000_007
        
        @cache
        def fn(i, n, p): 
            """"""Return count at i with n people remaining and p profit to make.""""""
            if n < 0: return 0
            if i == len(group): return p <= 0 
            return (fn(i+1, n, p) + fn(i+1, n-group[i], p-profit[i])) % MOD

        return fn(0, n, minProfit)",0
"class Solution:
    def decodeAtIndex(self, S: str, K: int) -> str:
		# e.g. S == 'ab2c3d'
		# ls_len: list of lengths of new patterns [2, 5] (ab, ababc)
		# ls_total_len: list of lengths of times * new pattern [4, 15] (abab, ababcababcababc)
		# ls_pattern: list of new additional pattern ['ab', 'c']
        ls_len = []
        ls_total_len = []
        ls_pattern = []
        tmp = ''
        length = 0
        # flag for string without integer
		prev_num = -1
		
        for i in range(len(S)): 
            value = S[i]
            if i == 0: 
				# first char is letter only
                tmp = value
                length = 1
                continue
            if 50 <= ord(value) <= 57: 
                if tmp: 
					# if not more than one integer appearing together
                    ls_pattern.append(tmp)
                    ls_len.append(length)
                    ls_total_len.append(length * int(value))
                else: 
					# e.g. S = 'a23', here ls_total_len will change from [2] (aa) to [6] (aaaaaa). 
					# The other two lists unchanged.
                    ls_total_len[-1] = length * int(value)
                length = length * int(value)
                tmp = ''
                prev_num = i
            else: 
                tmp += value
                length += 1       
        
		# residual is the last part left with no multiplier, e.g. S = 'ab2c3d', then the last 'd' is the residual
        residual = tmp
		if prev_num < 0: 
			# if no integer is in S, return the (K - 1)th element. 
            return S[K - 1]
       
        if K > ls_total_len[-1]: 
			# if K is within the first pattern
            return residual[K - ls_total_len[-1] - 1]
        if K <= ls_total_len[0]: 
			# if K is in the residual
            ptn = ls_pattern[0]
            len_ptn = ls_len[0]
            return ptn[(K - 1) % len_ptn]
        
        def bs(k, lb, ub, ls): 
			# binary search of K's location in the two lists: ls_len &amp; ls_total_len
            if k <= ls[lb]: 
                return lb - 1
            if k > ls[ub]: 
                return ub
            if ub == lb + 1: 
                return lb
            mid = (lb + ub) // 2
            if k == ls[mid]: 
                return mid - 1
            elif k < ls[mid]:
                return bs(k, lb, mid, ls)
            else: 
                return bs(k, mid + 1, ub, ls)
         
		# due to the nature of the two lists, idx1 >= idx2
        idx1 = bs(K, 0, len(ls_pattern) - 1, ls_len)
        idx2 = bs(K, 0, len(ls_pattern) - 1, ls_total_len)

        while idx1 != idx2 and idx2 != -1: 
			# if idx1 ==  idx2, (K - 1)th element is in the new additional pattern
			# if idx2 == -1, (K - 1)th element is in the first pattern
            K %= ls_len[idx1]
            if not K: 
                K = ls_len[idx1]
            idx1 = bs(K, 0, idx1, ls_len)
            idx2 = bs(K, 0, idx2, ls_total_len)
        if idx2 == -1: 
            return ls_pattern[0][K % ls_len[0] - 1]
        if idx1 == idx2: 
            return ls_pattern[idx1 + 1][K - ls_total_len[idx1] - 1]",0
"class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort() # ascending 
        
        ans, lo, hi = 0, 0, len(people)-1
        while lo <= hi: 
            ans += 1
            if lo < hi and people[lo] + people[hi] <= limit: lo += 1
            hi -= 1
        return ans",1
"class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = defaultdict(dict)
        dp = defaultdict(dict)
        
        for v1, v2, wt in edges:
            graph[v1][v2] = wt + 1
            graph[v2][v1] = wt + 1
            dp[v1][v2] = 0
            dp[v2][v1] = 0
        
        #print(graph)
        
        def dijkstra(graph, dp):
            
            myheap = [(0, 0)]
            distances = [float(inf)] * n
            distances[0] = 0
            
            while myheap:
                cost, node = heappop(myheap)
                if cost > maxMoves or cost > distances[node]:
                    continue
                    
                for nxtNode, nxtCost in graph[node].items():
                    totalCost = nxtCost + cost
                    remainingMoves = maxMoves - cost
					# nxtCost is the distance bw node and nxtNode so there are nxtCost - 1 new nodes in bw them
					# If remainingMoves are greater than number of new nodes bw them -> it mean we can reach all nodes between the current pair of nodes
                    dp[node][nxtNode] = max(dp[node][nxtNode], min(remainingMoves, nxtCost - 1))
                    
                    if totalCost > distances[nxtNode] or totalCost > maxMoves:
                        continue
                    
                    distances[nxtNode] = totalCost
                    heappush(myheap, (totalCost, nxtNode))
                    #print(nxtNode, distances)
            
            return dp, distances
        
        dp, dist = dijkstra(graph, dp)
        #print(dist)
        #print(dp)
        ans = 0
        for key in dp:
            for node, num in dp[key].items():
                total = dp[node][key] + num
                ans += min(total, graph[key][node] - 1)
		# each pair is counted twice so we need to divide by 2
        ans = ans // 2
        
		# count how many old nodes are reachable
        for elem in dist:
            if elem != float(inf):
                ans += 1
        
        return ans",0
"class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
    	S = [collections.Counter(A.split()),collections.Counter(B.split())]
    	return [j for i in range(2) for j in S[i] if S[i][j] == 1 and j not in S[1-i]]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def spiralMatrixIII(self, M: int, N: int, x: int, y: int) -> List[List[int]]:
        A, d = [[x,y]], 0
        while len(A) < M*N:
            for s in 1,-1:
                d += 1
                for y in range(y+s,y+s*(d+1),s):
                    if 0<=x<M and 0<=y<N: A.append([x,y])
                for x in range(x+s,x+s*(d+1),s):
                    if 0<=x<M and 0<=y<N: A.append([x,y])
        return A
        
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
        
        d = deque([])
        colors = {}
        
        graph = {i: [] for i in range(1, N+1)}
        
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
            
        for i in graph.keys():
            
            if i not in colors:
                colors[i] = 1
                d.append(i)
                
                while d:
                    
                    item = d.popleft()
                    for ch in graph[item]:
                        
                        if ch in colors:
                            if colors[ch] == colors[item]:
                                return False
                        else:
                            colors[ch] = 1 - colors[item]
                            d.append(ch)
        return True",0
"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        return self.solve(k,n)
    
    def solve(self,e,f):
        if f == 0 or f == 1:
            return f
        if e == 1:
            return f
        
        ans = float('inf')
        
        for k in range(1,f):
            temp = 1 + max(self.solve(e-1,k-1), self.solve(e,f-k))
            ans = min(ans,temp)
            
        return ans",1
"class Solution:
    def fairCandySwap(self, A, B):
        Sa = sum(A)
        Sb = sum(B)
        setB = set(B)
        for x in A:
            if x + (Sb - Sa) / 2 in setB:
                return [x, x + (Sb - Sa) / 2]",1
"class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        pre_index, post_index  = 0, 0
        def dfs(prev_val):
            nonlocal pre_index
            nonlocal post_index

            if prev_val == postorder[post_index]:
                return None
            
            node = TreeNode(preorder[pre_index])
            pre_index += 1

            node.left = dfs(node.val)
            node.right = dfs(node.val)

            post_index += 1

            return node
        return dfs(-1)",1
"class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        
        
        
        ans=[]
        
        for j in words:
            
            if len(j)==len(pattern):
                if len(set(j)) == len(set(pattern)):
                    
                    pe={}
                    we={}
                    
                    h=0
                    for i in range(1,len(pattern)):
                        
                        if pattern[i]==pattern[i-1]:
                            if j[i-1]!=j[i]:
                                h+=1
                                break
                        elif pattern[i]!=pattern[i-1]:
                            if j[i-1]==j[i]:
                                h+=1
                                break
                        
                        if pattern[i] not in pe:
                            pe[pattern[i]]=1
                            if j[i] in we:
                                h+=1
                                break
                            else:
                                we[j[i]]=1
                        
                        if pattern[i] in pe:
                            pe[pattern[i]]+=1
                            
                            if j[i] not in we:
                                h+=1
                                break
                            else:
                                we[j[i]]+=1
                                
                    
                        
                    if h==0 and sorted(list(we.values()))==sorted(list(pe.values())):
                        ans.append(j)
                        
        return ans",0
"class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        MOD = 1_000_000_007
        ans = 0 
        for i, x in enumerate(sorted(nums)): 
            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))
        return ans % MOD",1
"class Solution:
    def surfaceArea(self, G: List[List[int]]) -> int:
        N, C = len(G), [(1,0),(0,-1),(-1,0),(0,1)]
        G, S = [[0]*(N+2)] + [[0]+g+[0] for g in G] + [[0]*(N+2)], 2*N**2 - 2*sum(G,[]).count(0)
        for i,j in itertools.product(range(1,N+1),range(1,N+1)): S += sum(max(0,G[i][j]-G[i+x][j+y]) for x,y in C)
        return S
		
		
- Junaid Mansuri",0
"class Solution:        
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        return len(set(''.join(sorted(stri[i] for i in range(len(stri)) if i%2==0)) + ''.join(sorted(stri[i] for i in range(len(stri)) if i%2!=0)) for stri in A))",0
"class Solution:
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
        #impossible to satisfy the conditions
        if N % 2 == 0:
            return []
        
        full_list = {}
        
        #base cases
        full_list[1] = [TreeNode(0)]
        temp = TreeNode(0)
        temp.left = full_list[1][0]
        temp.right = full_list[1][0]
        full_list[3] = [temp]
        
        for x in range(5, N+1, 2):
            full_list[x] = []
            n_left = 1
            n_right = (x - 1) - n_left  # x-1 to exclude the root node
            
            #go through all combinations of children trees that add to x-1
            while n_right >= 1:
                for l_tree in full_list[n_left]:
                    for r_tree in full_list[n_right]:
                        temp = TreeNode(0)
                        temp.left = l_tree
                        temp.right = r_tree
                        #print(temp)
                        full_list[x].append(temp)
                
                n_left += 2
                n_right -= 2
        
        #print(len(full_list[N]))
        return full_list[N]",0
"class Solution:
    
    def is_increasing(self, items):
        start_value = items[0]
        for value in items: 
            if value > start_value:
                return True
            if value < start_value:
                return False
            
    def get_comparison_function(self, is_increasing):
        def is_asscending(a, b):
            return a <= b
        
        def is_decending(a, b):
            return a >= b
        
        if is_increasing: 
            return is_asscending
        return is_decending
    
    def isMonotonic(self, A: List[int]) -> bool:
        is_increasing = self.is_increasing(A)
        is_monotonic = self.get_comparison_function(is_increasing)
        
        for index in range(1, len(A)):
            previous_item = A[index - 1]
            item = A[index]
            if not is_monotonic(previous_item, item):
                return False
            
        return True",1
"class Solution(object):
    def increasingBST(self, root):
        """"""
        :type root: TreeNode
        :rtype: TreeNode
        """"""
        self.all_nodes = []

        def find_all_nodes(root):
            if root:
                self.all_nodes.append(root.val)
                find_all_nodes(root.left)
                find_all_nodes(root.right)

        find_all_nodes(root)
        self.all_nodes.sort()

        tree = TreeNode(self.all_nodes.pop())
        while len(self.all_nodes) > 0:
            t = TreeNode(self.all_nodes.pop())
            t.left = None
            t.right = tree
            tree = t

        return tree",1
"class Solution:
    def subarrayBitwiseORs(self, A: List[int]) -> int:
        ans, vals = set(), set()
        for x in A: 
            vals = {x | xx for xx in vals} | {x}
            ans |= vals
        return len(ans)",1
"class Solution:
    def calcS(self,s):
        res = 0
        for x in s:
            res *= 26
            res += (ord(x)-96)

        return res

    def orderlyQueue(self, s: str, k: int) -> str:

        if k == 1:
            least = inf
            indx = 0
            ss = s*2
            d = len(s)
            for l in range(d):
                if least>self.calcS(ss[l:l+d]):
                    least = self.calcS(ss[l:l+d])
                    indx = l
            return ss[indx:indx+d]
                 
        else:
            D = defaultdict(int)
        
            for x in s:
                D[x] += 1
            
            abc = ""abcdefghijklmnopqrstuvwxyz""
            res = """"

            for x in abc:
                res += x*D[x]

            return res",0
"class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        limit = str(n)
        limit_len = len(limit)
        digits_len = len(digits)
        res = 0
        
        for idx in range(1, limit_len):
            res += pow(digits_len, idx)
        
        for idx in range(limit_len):
            is_start_eq_digit = False
            for digit in digits:
                if digit < limit[idx]:
                    res += pow(digits_len, limit_len - idx - 1)
                elif digit == limit[idx]:
                    is_start_eq_digit = True
            
            if not is_start_eq_digit:
                return res
        
        return res + 1",0
"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        myStore = [1]
        
        for index, val in enumerate(s):
            if val == 0:
                continue
            temp = []
            for i in range(index + 2):
                if val == ""I"":
                    curr = sum(myStore[i:])
                else:
                    curr = sum(myStore[:i])
                temp.append(curr)
            myStore = temp
        return sum(myStore) % (10**9+7)",1
"class Solution:
    def totalFruit(self, tree: List[int]) -> int:
        ans = ii = 0
        freq = {}
        for i, x in enumerate(tree): 
            freq[x] = 1 + freq.get(x, 0)
            while len(freq) > 2: 
                freq[tree[ii]] -= 1
                if freq[tree[ii]] == 0: freq.pop(tree[ii])
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans",1
"class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        even = 0                                                    # The index currently contain odd, waiting for accepting a even num
        
        for odd in range(len(nums)):
            if nums[odd] % 2 == 0:                                  # if index-odd encounter a even num, swap it with index-even.
                nums[even], nums[odd] = nums[odd], nums[even]       # Indices at and before index-even are even num now,
                even += 1                                           # so even-index should go 1 step further 
                                                                    # ready to accept next even num
        return nums",0
"class Solution:
    def superpalindromesInRange(self, left: str, right: str) -> int:
        '''
        1. For each number in the range [floor(square root of integer value of left), floor(square root of integer value of right)], 
                - need to check if the number is palindrome and (number^2) is palindrome
        2. One possible way to do this quicker is 
                - to generate all the palindromes within the range [floor(square root of integer value of left), floor(square root of integer value of right)]
                - and check whether the square of this palindrome is also a palindrome
        3. If [floor(square root of integer value of left)] is of x digits and [floor(square root of integer value of right)] is of y digits, then
                - if x>1: start generating palindrome from the lowest number of x digits that is divisible by 10, else: start generating palindrome from 1
                - generate palindrome upto the highest number of y digits that is 999...9 (y 9's) 
        4. To generate palindromes of x and y digits, we need to check only the first ceil(x/2) digits and ceil(y/2) digits 
                of [floor(square root of integer value of left)] and [floor(square root of integer value of right)] respectively
        '''
        
        cnt = 0
        lft = str(int(int(left)**0.5))
        rght = str(int(int(right)**0.5))
        
        lft_1 = lft
        rght_1 = rght
        
        if len(lft)%2:
            lft = ""1""+""0""*((len(lft)//2))
        else:
            lft = ""1""+""0""*((len(lft)//2)-1)                                                 #getting the value from where palindromes are started to be generated
            
        if len(rght)%2:
            rght = ""9""*((len(rght)//2)+1)
        else:
            rght = ""9""*(len(rght)//2)                                                       #getting the value upto which palindromes are generated
        
        for num in range(int(lft),int(rght)+1):
            num=str(num)
            len_string=len(num)
            
            if (len_string*2)-1 >= len(lft_1):                                              #length of palindrome must be greater than or equal the given 'left' string parameter
                str_N_1 = num[0:len_string-1]+num[len_string-1]+num[0:len_string-1][::-1]   #generate an odd length palindrome by appending the num string in two opposite orders, and keep the middle character fixed 
                sq_1 = str(int(str_N_1)**2)                                                 #generate the string representation of the square of the palindrome integer
                if int(left) <= int(sq_1) <= int(right) and sq_1==sq_1[::-1]:               #square is palindrome and within the given left and right parameters
                    cnt+=1                                                                  #increment the result by 1
            
            if len_string*2 <= len(rght_1):                                                 #length of palindrome must be less than or equal the given 'right' string parameter 
                str_N_2 = num+num[::-1]                                                     #generate an even length palindrome by appending the num string in two opposite orders
                sq_2 = str(int(str_N_2)**2)
                if int(left) <= int(sq_2) <= int(right) and sq_2==sq_2[::-1]:
                    cnt+=1
                
        return cnt",0
"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:

        # get the index of the first previous value that is less than the current one. 
        # if there is no value less than the current one in the previous array
        # set the index as -1 which means all previous values are larger than 
        # the current one so we can include all the previous array in the subarray
        # with current index as the minimun.
        prev_less_index = [-1] * len(arr)
        stack = []
        for i, val in enumerate(arr):
            while stack and arr[stack[-1]] > val:
                stack.pop()
            prev_less_index[i] = stack[-1] if stack else - 1
            stack.append(i)

        # with similar logtic, get the first index of following values that is less than
        # the current one.
        next_less_index = [len(arr)] * len(arr)
        stack = []
        for i, val in enumerate(arr):
            while stack and arr[stack[-1]] > val:
                next_less_index[stack.pop()] = i
            stack.append(i)
        res = 0
        for i, val in enumerate(arr):
            res = (res + val * (i - prev_less_index[i]) * (next_less_index[i] - i)) % 1_000_000_007

        return res",0
"class Solution:
    def smallestRangeI(self, A: List[int], K: int) -> int:
        return max(0,max(A)-min(A)-2*K)",1
"class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)
        ans = 0
        queue = [1]
        seen = {1}
        while queue: 
            newq = []
            for x in queue: 
                if x == n*n: return ans 
                for xx in range(x+1, x+7): 
                    if xx <= n*n:
                        i, j = divmod(xx-1, n)
                        if board[~i][~j if i&amp;1 else j] != -1: xx = board[~i][~j if i&amp;1 else j]
                        if xx not in seen: 
                            newq.append(xx)
                            seen.add(xx)
            ans += 1
            queue = newq 
        return -1",0
"class Solution:
    def smallestRangeII(self, nums: List[int], k: int) -> int:
        
        # Remove duplicates and sort
        arr = sorted(list(set(nums)))
        
        res = arr[-1] - arr[0]
        for i in range(len(arr) - 1):
            res = min(res, max(arr[i] + k, arr[-1] - k) - min(arr[0] + k, arr[i + 1] - k))
        
        return res",1
"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

	
        return sorted(nums)   #1
		```
		```
		#2
import heapq
class Solution:
def sortArray(self, nums: List[int]) -> List[int]:
        heapq.heapify(nums)
        l=[]
        while(nums):
            l.append(heapq.heappop(nums))
        return l
 
		```",1
"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp;1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)",0
"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        C=Counter(deck).values()
        for i in range(2,len(deck)+1):
            if all([c%i==0 for c in C]): return True
        return False",1
"class Solution:
    def partitionDisjoint(self, A: List[int]) -> int:
        n = len(A)
        large, small = [0] * n, [0] * n
        l, s = -sys.maxsize, sys.maxsize
        for i in range(n):
            large[i], small[n-1-i] = (l:=max(l, A[i])), (s:=min(s, A[n-1-i]))
        for i in range(n):   
            if large[i] <= small[i+1]: return i+1
        return -1",0
"class Solution:
    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
   
        ans=[]
        maind={}
        
        for i in B:
            d={}
            for j in i:
                if j in d:
                    d[j]+=1
                else:
                    d[j]=1
            for j in i:
                if j not in maind:
                    maind[j]=d[j]
                if j not in d:
                    d[j]=0
                maind[j]=max(maind[j],d[j])
        # print(maind)
        
        for i in A:
            d1={}
            f=True
            for j in i:
                if j in d1:
                    d1[j]+=1
                else:
                    d1[j]=1
            # print(d1)
            for j in maind:
                
                if j not in d1:
                    d1[j]=-1
                # print( maind[j],d1[j])
                if maind[j]>d1[j]:
                    f=False
                    break
            if  f:
                ans.append(i)
                
        return ans",0
"class Solution:
    def kadane_max(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
        return max(nums)
    
    def kadane_min(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] < 0:
                nums[i] += nums[i-1]
        return min(nums)
    
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        x = self.kadane_max(nums[::])
        y = sum(nums) - self.kadane_min(nums[::])
        if y == 0:
            y = max(nums)
        return max(x, y)",0
"class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        
        @cache
        def fn(i, x): 
            """"""Return number starting from ith position with x songs already appeared.""""""
            if i == goal: return x == n 
            ans = 0 
            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song
            if k < x: ans += (x-k) * fn(i+1, x) # an old song
            return ans % 1_000_000_007
        
        return fn(0, 0)",0
"class Solution:
    def minAddToMakeValid(self, S: str) -> int:
        op = cl = 0 # open and closed parenthesis needed 
        for c in S: 
            cl += 1 if c == ""("" else -1 # need ) to balance extra (
            if cl < 0: 
                cl = 0
                op += 1 # need ( to balance extra )
        return op + cl",1
"class Solution:
    def sortArrayByParityII(self, A: List[int]) -> List[int]:
        ev, od = 0, 1
        sol = [0] * len(A)
        for el in A:
            if el % 2 == 0: 
                sol[ev] = el
                ev += 2
            else:
                sol[od] = el
                od += 2
        return sol",1
"class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        freq = {}
        for x in arr: 
            freq[x] = 1 + freq.get(x, 0)
        
        ans = 0
        vals = list(freq)
        
        for i in range(len(vals)):
            for ii in range(i+1): 
                x = target - vals[i] - vals[ii]
                if x in freq: 
                    if vals[i] == vals[ii] == x: 
                        ans += comb(freq[x], 3)
                    elif vals[i] == vals[ii] != x: 
                        ans += comb(freq[vals[i]], 2) * freq[x]
                    elif vals[i] < x and vals[ii] < x: 
                        ans += freq[vals[i]] * freq[vals[ii]] * freq[x]
        return ans % 1_000_000_007",0
"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            nodes.add(i)
            for j, conn in enumerate(graph[i]):
                if conn and j not in nodes:
                    dfs(j)
        
        maxRemoval, minNode = -1, float('inf')
        for node in initial:
            nodes = set()
            dfs(node)
            
            if nodes &amp; initial == {node}:
                l = len(nodes)
                if l > maxRemoval or (l == maxRemoval and node < minNode):
                    minNode = node
                    maxRemoval = l
                    
        return minNode if maxRemoval > -1 else min(initial)",0
"class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
    	name, typed, c, N = name+'0', typed+'0', 1, []
    	for s in [name,typed]:
    		for i in range(len(s)-1):
    			if s[i] == s[i+1]:
    				c += 1
    			else:
    				N.append([s[i],c])
    				c = 1
    	return all([N[i][0] == N[i+len(N)//2][0] and N[i][1] <= N[i+len(N)//2][1] for i in range(len(N)//2)])

		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
    	return min(2*j-i for i,j in enumerate([0]+list(itertools.accumulate([int(i) for i in S]))))+len(S)-S.count('1')
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        ones = [i for i, x in enumerate(arr) if x]
        n, r = divmod(len(ones), 3)
        if r: return -1, -1
        if not n: return 0, 2
        a, b, c = ones[0], ones[n], ones[2*n]
        r = len(arr) - c
        if r > max(b-a, c-b) or not arr[a+1:a+r] == arr[b+1:b+r] == arr[c+1:]:
            return -1, -1
        return a + r - 1, b + r",0
"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            for j, conn in enumerate(graph[i]):
                if conn and j not in initial and j not in nodes:
                    nodes.add(j)
                    dfs(j)
        
        sourceDict = defaultdict(list)
        for node in initial:
            nodes = set()
            dfs(node)
            
            for i in nodes:
                sourceDict[i].append(node)
        
        counter = defaultdict(int)
        maxVal, minNode = -1, float('inf')
        for infected, sources in sourceDict.items():
            if len(sources) == 1:
                src = sources[0]
                counter[src] += 1
                if counter[src] > maxVal or (counter[src] == maxVal and src < minNode):
                    minNode = src
                    maxVal = counter[src]
                    
        return minNode if maxVal > -1 else min(initial)",0
"class Solution(object):
    def numUniqueEmails(self, emails):
        """"""
        :type emails: List[str]
        :rtype: int
        """"""

        results = set()
        for email in emails:
            local, domain = email.split(""@"")
            local = local[:local.index(""+"")].replace(""."", """") if ""+"" in local else local.replace(""."", """")
            results.add(local + ""@"" + domain)

        return len(results)",1
"class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        zgaps,gap = [],0
        for v in A:
            if v:
                zgaps+=[gap]
                gap=0
            else:
                gap+=1
        zgaps+=[gap]
        if S==0:
            return sum([(g*(g+1))//2 for g in zgaps])
        return sum([(zgaps[i]+1)*(zgaps[i+S]+1) for i in range(len(zgaps)-S)])",1
"class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
    	L, A, m = len(A), [[math.inf] + i + [math.inf] for i in A], math.inf
    	for i,j in itertools.product(range(1,L),range(1,L+1)): A[i][j] += min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])
    	return min(A[-1])
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        return (
            [1, 2][:n]
            if n < 3
            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]
            + [x * 2 for x in self.beautifulArray(n // 2)]
        )",1
"class Solution:
	def shortestBridge(self, grid: List[List[int]]) -> int:       
		rows, cols = len(grid), len(grid[0])

  # Mark the first island with '#'s
    def dfs(row, col):
        if row not in range(rows) or col not in range(cols) or grid[row][col] != 1:
            return False
        
        grid[row][col] = '#'
        dfs(row+1, col)
        dfs(row-1, col)
        dfs(row, col+1)
        dfs(row, col-1)
             

# If the inner loop does not break, the outer loop will not either. 
# The for-else clause only happens if the inner loop does not break. Then continue avoids the outer break too. 
    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 1:
                dfs(row,col)
                break
        else:
            continue # only executed if the inner loop did NOT break
        break  # only executed if the inner loop DID break
    
	
	# Now let's expand from the first island we just marked and return the second we see the second island
    shortest_bridge_distance = 0
    q = deque([(r,c,shortest_bridge_distance) for r in range(rows) for c in range(cols) if grid[r][c] == '#'])     

    visited = set()
    while q:
        row, col, shortest_bridge_distance  = q.popleft()
        directions = ((row+1,col),(row-1,col),(row,col+1),(row,col-1))
		
        for new_row, new_col in directions:
            if new_row in range(rows) and new_col in range(cols) and (new_row,new_col) not in visited:
                if grid[new_row][new_col] == 1:
                    return shortest_bridge_distance
					
                q.append((new_row, new_col, shortest_bridge_distance+1))
                visited.add((new_row,new_col))",0
"class Solution:
    NEIGHBORS_MAP = {
            1: (6, 8),
            2: (7, 9),
            3: (4, 8),
            4: (3, 9, 0),
            5: tuple(),
            6: (1, 7, 0),
            7: (2, 6),
            8: (1, 3),
            9: (2, 4),
            0: (4, 6),
        }
        
    def getNeighbors(self, position):
        return self.NEIGHBORS_MAP[position]

    def knightDialer(self, N: int, memo={}) -> int:
        return sum(self.helper(neigh, N-1, memo) for neigh in self.NEIGHBORS_MAP.keys()) % (10**9 + 7)
    
    def helper(self, current, hops, memo):
        if (current, hops) in memo:
            return memo[(current, hops)]
        if hops == 0:
            return 1
        res = sum(self.helper(neigh, hops - 1, memo) for neigh in self.getNeighbors(current))
        memo[(current, hops)] = res
        return res",0
"class Solution:
    # O(n(n-m) * m) time,
    # O(n-m) space,
    # Approach: sliding window, 
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        n = len(target)
        m = len(stamp)
        target = list(target)
        ans = []
        vstd_indexes = set()
        
        
        def isStamped(subarray):
            for index,ch in enumerate(subarray):
                if not (ch == '?' or ch == stamp[index]):
                    return False
                
            return True
        
        
        def replaceToPlaceholder(start):
            non_questionmark = 0
            for i in range(m):
                if target[start+i] != '?':
                    non_questionmark += 1
                    target[start+i] = '?'
                
            return non_questionmark
        
        
        reversed = 0     # number of reversed characters back to '?' 
        l, r = 0, m
        stampExists = False     # if stamp exists in one traversal of target
        
        while reversed != n:
            while r <= n:
                if l not in vstd_indexes and isStamped(target[l:r]):
                    stampExists = True
                    ans.append(l)
                    vstd_indexes.add(l)
                    break
                l +=1
                r +=1
            if stampExists:
                reversed +=replaceToPlaceholder(ans[-1])
                stampExists = False
                l, r = 0, m
            else:
                return []
            
        ans.reverse()
        return ans",0
"class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        res=[]
        digi=[]
        letter=[]
        for i in logs:
            k=i.split()
            if k[1].isdigit():
                digi.append(i)
            else:
                letter.append(i)
        d={}
        for i in letter:
            k=i.split()
            m=d.get(tuple(k[1:]),[])
            m.append(k[0])
            d[tuple(k[1:])]=m
        for i in sorted(list(d.keys())):
            x=[x for x in i]
            s=''
            for j in x:
                s+=j+' '
            s=s.strip()
            for j in sorted(d[i]):
                res.append(j+' '+s)
        return(res+digi)",1
"class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        cursum = 0
        if root.val != None:
            cursum = root.val if low <= root.val <= high else 0
        if root.left and root.val >= low:
            cursum += self.rangeSumBST(root.left, low, high)
        if root.right and root.val <= high:
            cursum += self.rangeSumBST(root.right, low, high)

        return cursum",0
"class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        ans = inf
        seen = {(x, y) for x, y in points}
        for x, y in points: 
            for xx, yy in points: 
                if x != xx and y != yy and (x, yy) in seen and (xx, y) in seen: 
                    ans = min(ans, abs((xx-x)*(yy-y)))
        return ans if ans < inf else 0",0
"class Solution:
    def distinctSubseqII(self, s: str) -> int:
        freq = [0]*26 
        for i in reversed(range(len(s))): freq[ord(s[i])-97] = (1 + sum(freq)) % 1_000_000_007
        return sum(freq) % 1_000_000_007",1
"class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        increased = decreased = False
        
        for i in range(1, len(arr)):
            if arr[i] > arr[i-1]:
                if decreased:
                    return False
                increased = True
            elif arr[i] < arr[i-1]:
                if not increased:
                    return False
                decreased = True
            else:
                return False
            
        return decreased",1
"class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        
        a=0
        b=len(s)
        
        ans=[]
        for j in s:
            
            if j=='I':
                ans.append(a)
                a+=1
            else:
                ans.append(b)
                b-=1
                
        ans.append(a)
        return ans",1
"class Solution:
    def shortestSuperstring(self, words: List[str]) -> str:
        n = len(words)
        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix 
        
        for i in range(n):
            for j in range(n): 
                if i != j: 
                    for k in range(len(words[j])): 
                        if words[i].endswith(words[j][:k]): 
                            graph[i][j] = len(words[j]) - k 
                            
        @cache
        def fn(prev, mask): 
            """"""Return length of shortest superstring &amp; current choice of word.""""""
            if mask == 0: return 0, None
            vv, kk = inf, None
            for k in range(n): 
                if mask &amp; 1<<k: 
                    v, _ = fn(k, mask ^ 1<<k)
                    offset = len(words[k]) if prev == -1 else graph[prev][k]
                    if v + offset < vv: vv, kk = v + offset, k
            return vv, kk
        
        ans = []
        prev = -1 
        mask = (1<<n) - 1
        while mask: 
            _, k = fn(prev, mask)
            if ans: ans.append(words[k][-graph[prev][k]:])
            else: ans.append(words[k])
            prev = k
            mask ^= 1<<k 
        return """".join(ans)",0
"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        
        deletionIndices=[]
        x=[]
        
        length=len(A[0])
        counter=-1
        for i in range(length):
            check=[]
            acheck=[]
            for j in range(len(A)):
                check.append(A[j][i])
                acheck=sorted(check)
                if check!=acheck:
                    deletionIndices.append(i)
                    break
              
        return len(deletionIndices)",1
"class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        m, c, _ = -math.inf, 0, A.sort()
        for a in A: (c, m) = (c + (1 + m - a), m + 1) if a <= m else (c, a)
        return c
		
		
- Junaid Mansuri",1
"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        i = 0
        stack = []
        for x in pushed: 
            stack.append(x)
            while stack and stack[-1] == popped[i]: 
                stack.pop()
                i += 1
        return not stack",1
"class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        root = set()
        parent = {}
        rank = {}
        for x, y in stones:
            self.set_param(x, parent, rank)
            self.set_param(~y, parent, rank)
            self.union(x, ~y, parent, rank)
        # get parent for all nodes
        for p in parent:
            root.add(self.find(parent[p], parent))
        # Answer is: no. of stones - no. of components
        # Since we can't remove all stones from a components, there we be number of components number of stones left
        return len(stones) - len(root)
        
    def set_param(self, x, parent, rank):
        if(x not in parent):
            parent[x] = x
            rank[x] = 0

    def find(self, x, parent):
        if(x != parent[x]):
            parent[x] = self.find(parent[x], parent)
        return parent[x]
    
    def union(self, x, y, parent, rank):
        parent_x = self.find(x, parent)
        parent_y = self.find(y, parent)
        
        if(parent_x == parent_y):
            return
        rank_x = rank[parent_x]
        rank_y = rank[parent_y]
        
        if(rank_x > rank_y):
            parent[parent_y] = parent_x
        elif(rank_x < rank_y):
            parent[parent_x] = parent_y
        else:
            parent[parent_y] = parent_x
            rank[parent_x] += 1",0
"class Solution:
    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:
        tokens.sort()
        score = 0
        while len(tokens) > 0:
            if P >= tokens[0]:
                P -= tokens[0]
                score += 1
                tokens.pop(0)
            elif len(tokens) > 2 and score > 0:
                score -= 1
                P += tokens[-1]
                tokens.pop()
            else:
                break
        return score",1
"class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        
            return ''.join(result[-1]) if (result := sorted([[*p[:2]]+[':']+[*p[2:]] for p in itertools.permutations([str(n) for n in A]) if int(''.join(p[:2])) < 24 and int(''.join(p[2:])) < 60], key=lambda p: int(''.join(p[:2]))*100 + int(''.join(p[3:])))) else """"",0
"class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        ans = [0]*len(deck)
        idx = deque(range(len(deck)))
        for x in sorted(deck): 
            ans[idx.popleft()] = x
            if idx: idx.append(idx.popleft())
        return ans",1
"class Solution:
    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        
        def fn(n1, n2):
            """"""Return True if n1 is a flip of n2.""""""
            if not n1 or not n2: return n1 is n2
            return n1.val == n2.val and (fn(n1.left, n2.right) and fn(n1.right, n2.left) or fn(n1.left, n2.left) and fn(n1.right, n2.right))
        
        return fn(root1, root2)",0
"class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        
        def find(node):
            if parent[node] == -1: return node
            else:
                parent[node] = find(parent[node])
                return parent[node]
        
        def union(idx1,idx2):
            par1,par2 = find(idx1),find(idx2)
            if par1!=par2:
                if rank[par1] > rank[par2]:
                    parent[par2] = par1
                elif rank[par2] > rank[par1]:
                    parent[par1] = par2
                else:
                    parent[par2] = par1
                    rank[par1] += 1
        
        n = len(nums)
        parent = defaultdict(lambda:-1)
        rank = defaultdict(lambda:0)
        for i in range(n):
            limit = int(nums[i]**0.5)
            for j in range(2,limit+1):
                if nums[i] % j == 0:
                    union(nums[i],j)
                    union(nums[i],nums[i]//j)
        count = defaultdict(lambda:0)
        best = -1
        for num in nums:
            par = find(num)
            tmp = count[par] + 1
            if tmp > best: best = tmp
            count[par] = tmp
        return best",0
"class Solution:
    
    def compare(self, cache, word1, word2):
        i, j = 0,0
        while i < len(word1) and j < len(word2):
            if cache[word1[i]] < cache[word2[j]]:
                return True
            elif cache[word1[i]] > cache[word2[j]]:
                return False
            else: #letters equal case
                i += 1
                j += 1

        if i < len(word1):
            return False
        """"""
            why false?
            In some cases word1 can be aaa, word2 can be aa
            here we must return false becoz they are not in lexicographic order
            becoz word2 appears first than word1
        """"""
        
        return True #same words case and shorter words case like aa, aaa i will definitely reach end 
    
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        """"""
            Main Idea behind this is,
            How we see our Oxford or Some english Dictionary (So called lexicographic order)
            
            Eg:
            Case 1:
                Assume we have words like ad, af, ag, ba, bba, bbaaaag in our oxford Dictionary
                at diff page numbers Now compare the page numbers of these words once it is for sure
                pageNumber(ad) < pageNumber(af) < pageNumber(ag) < ... pageNumber(bbaaag)
            Case 2:
                if we go in depth
                if two 2 words are in same page, say x, xy
                it is for sure LineNumber(x) < lineNumber(xy) (Note < operator is Strictly lesser)
            Case 3:
                Words like a, aa, aaa, aaaa are in our dictionary
                definitly appearance(a) < appearance(aa) < appearance(aaa) < appearance(aaaa)
                appearance may be a line number or page number
        """"""
        
        """"""
            In our Question there are asking for a different alphabetical order and asking us to check 
            whether appearance(word1) < appearance(word2) < appearance(word3) < ... < appearance(wordn) or not
            Just compare 
                word1 with word2 
                word2 with word3
                word3 with word4
                ....
                wordn-1 with wordn
            Reason: if word1 < word2 it is for sure lesser than word3 and so on
        """"""
        cache = {}
        for i in range(len(order)):
            cache[order[i]] = i
        
        for i in range(1, len(words)):
            if not self.compare(cache, words[i-1], words[i]):
                return False
        return True",0
"class Solution:
    def canReorderDoubled(self, A: List[int]) -> bool:
        A = sorted([-i if i < 0 else i for i in A], reverse=True)
        n, c, cnt = len(A), collections.Counter(A), 0
        for i in range(n):
            if c[2*A[i]] > 0:
                c[2*A[i]] -= 1
                c[A[i]] -= 1
                cnt += 1
        return cnt >= n // 2",0
"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions 
        ans, grp = 0, [0]*m
        for j in range(n): 
            for i in range(1, m): 
                if grp[i-1] == grp[i] and strs[i-1][j] > strs[i][j]: 
                    ans += 1
                    break
            else: 
                for i in range(1, m): 
                    grp[i] = max(grp[i-1], grp[i])
                    if grp[i-1] == grp[i] and strs[i-1][j] < strs[i][j]: grp[i] = i
        return ans",0
"class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        
        def fn(arr): 
            """"""Possible a mapping from diff to length""""""
            mp = defaultdict(int)
            for t in range(1, len(arr)+1): 
                for total in combinations(arr, t): 
                    tt = sum(total)
                    for p in range(0, t+1): 
                        for part in combinations(total, p): 
                            pp = sum(part)
                            mp[pp*2 - tt] = max(mp[pp*2 - tt], pp)
            return mp 
        
        left = rods[:len(rods)//2]
        right = rods[len(rods)//2:]
        
        mp = fn(left)
        keys = sorted(mp.keys())
        
        ans = 0 
        for diff, v in fn(right).items(): 
            k = bisect_left(keys, -diff)
            if k < len(keys) and keys[k] == -diff: 
                ans = max(ans, mp[-diff] + v)
        return ans",0
"class Solution:
    def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:
        counter = 0
        bitmap = 0
		# cells to bitmap
        for b in cells:
            bitmap = (bitmap<<1)|b
		# memory table
        idToCount = {bitmap:counter}
        countToCells = {counter:bitmap}
        for j in range(n):
			# bin(126) = 1111110
            bitmap = ~((bitmap<<1)^(bitmap>>1))&amp;126
            counter += 1
            if bitmap in idToCount:
                dis = idToCount[bitmap]
				# mod
                bitmap = countToCells[(n-dis)%(counter-dis)+dis]
                break
            else:
                idToCount[bitmap] = counter
                countToCells[counter] = bitmap
		# bitmap to cells
        for i in range(8):
            cells[7-i] = (bitmap>>i)&amp;1
        return cells",0
"class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
        queue = [root]
        while queue[0]:
            node = queue[0]
            queue = queue[1:]
            queue.append(node.left)
            queue.append(node.right)
        return not any(queue)",1
"class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
	'''
	--------
	| \ 0 / |
	| 3\ /  |
	|  /\ 1 |
	|/  2 \ |
	|-------|

	'''
        self.N = len(grid)
        # m_ = [i for i in range(self.N * self.N * 4)]
        m_ = list(range(self.N * self.N * 4))
        self.count = self.N * self.N * 4
        for r in range(self.N):
            line = grid[r]
            for c in range(self.N):
                w = line[c]
                if r > 0:  # no horizontal line '-'
                    self.u(m_, self.g(r - 1, c, 2), self.g(r, c, 0))
                if c > 0:  # no vertical line '|'
                    self.u(m_, self.g(r, c - 1, 1), self.g(r, c, 3))
                if w != '/':  # if not '/', then region 0 and 1 will be in the same region(set)
                    self.u(m_, self.g(r, c, 0), self.g(r, c, 1))
                    self.u(m_, self.g(r, c, 3), self.g(r, c, 2))
                if w != '\\': # if not '\\', then region 1 and 2 will be in the same region(set)
                    self.u(m_, self.g(r, c, 0), self.g(r, c, 3))
                    self.u(m_, self.g(r, c, 1), self.g(r, c, 2))
        return self.count

    def f(self, m_, a):  # find set
        if m_[a] == a:   # if parent found, return, else continue finding
            return a
        return self.f(m_, m_[a])
    
    def u(self, m_, a, b):  # union sets
        pa = self.f(m_, a)
        pb = self.f(m_, b)
        if (pa == pb):
            return
        m_[pa] = pb
        self.count -= 1
    
    def g(self, r, c, i):  # find exact region(set) for every element in grid
        return (r * self.N + c) * 4 + i",0
"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions
        
        @cache 
        def fn(k, prev):
            """"""Return min deleted columns to make sorted.""""""
            if k == n: return 0 
            ans = 1 + fn(k+1, prev) # delete kth column
            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(m)): 
                ans = min(ans, fn(k+1, k)) # retain kth column
            return ans 
        
        return fn(0, -1)",0
"class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        length = len(A)
        for i in A:
            if A.count(i)>1:
                return i",1
"class Solution:
    def maxWidthRamp(self, nums: List[int]) -> int:
        if not nums: return 0
        
        max_vals = self.create_max_vals(nums)
        max_width = 0
        i = 0
        
        while i + max_width < len(nums):
            j = i + max_width
            
            while j < len(nums) and nums[i] <= max_vals[j]:
                j += 1
            
            max_width = max(max_width, j - i - 1)
            i += 1
        
        return max_width
        
    def create_max_vals(self, nums: List[int]) -> List[int]:
        max_val = 0
        max_vals = [0] * len(nums)
        
        for i in range(len(nums)-1, -1, -1):
            max_val = max(max_val, nums[i])
            max_vals[i] = max_val
        
        return max_vals",1
"class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        N = len(points)
        
        seen = set()
        for point in points:
            seen.add(tuple(point))

        # length^2
        def length2(a, b):
            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])
        
        best = 1e30
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                
                lij = length2(points[i], points[j])
                for k in range(N):
                    if i == k or j == k:
                        continue
                    
                    # given i->j line, add to k to find l
                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]
                    
                    pl = (points[k][0] + dx, points[k][1] + dy)
                    if pl not in seen:
                        continue
                    
                    lik = length2(points[i], points[k])
                    ljk = length2(points[j], points[k])

                    lil = length2(points[i], pl)
                    ljl = length2(points[j], pl)
                    lkl = length2(points[k], pl)
                    
                    if lij == lkl and lik == ljl and lil == ljk:
                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))
                    
        if best >= 1e29:
            return 0
        return best",0
"class Solution:
    def solve(self,x,target):
        if target in self.dp : return self.dp[target]
        
        # when target == 1 we can solve just by doing x/x  
        if target == 1: return 1
        
         # current value = x and operations performed  = 0
        cur = x
        op = 0
       
        # if cur < target : the best decision is to multiply
        while cur < target:    
            cur *= x
            op += 1
        
        # if cur == target : we reached using minimum possible operations 
        if cur == target :
            return op
        
        if op == 0:
            # cur is already larger than target
            # x/x + make(target-1) : make 2 operations + solve(target-1)
            ans = 2 + self.solve(x,target - 1)
        else:
            # we try to reach nearest val via multiply less than target
            # and find ans for remaining i.e. target - cur/x 
            # here op becomes op - 1 so op - 1 + 1 becomes op
            ans = op + self.solve(x,target-(cur//x))
            
        if cur - target < target :
            # diff between cur and target is less than target
            # i.e. we can make cur and remove cur - target
            tmp = op + 1 + self.solve(x,cur - target)
            if tmp < ans : ans = tmp
        
        # finally use dp for memoization
        self.dp[target] = ans
        return ans",0
"class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        if root is None:
            return True
        self.cons=root.val
        def dfs(node):
            if node:
                if node.val!=self.cons:
                    return False
                dfs(node.left)
                dfs(node.right)
        
        dfs(root)
        return True",1
"class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        original_hash, lowercase_hash, ignore_vowel_hash = {}, {}, {}
        for index, word in enumerate(wordlist):
            original_hash[word] = index
            lowercase_word = word.lower()
            if lowercase_word not in lowercase_hash:
                lowercase_hash[lowercase_word] = index
            trans_vowel_word = self.trans_vowel(lowercase_word)
            if trans_vowel_word not in ignore_vowel_hash:
                ignore_vowel_hash[trans_vowel_word] = index
        check_result = []
        for query in queries:
            if query in original_hash:
                check_result.append(query)
            elif query.lower() in lowercase_hash:
                check_result.append(wordlist[lowercase_hash[query.lower()]])
            else:
                trans = self.trans_vowel(query.lower())
                if trans in ignore_vowel_hash:
                    check_result.append(wordlist[ignore_vowel_hash[trans]])
                else:
                    check_result.append("""")
        return check_result

    @classmethod
    def trans_vowel(cls, word):
        list_word = list(word)
        for i, c in enumerate(word):
            if c in ('a', 'e', 'i', 'o', 'u'):
                list_word[i] = 0
        return str(list_word)",0
"class Solution:
    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:
        
        def fn(i, x):
            """"""Return numbers with same consecutive differences.""""""
            if i == n-1: return [str(x)]
            ans = []
            if x+k < 10: ans += [str(x) + xx for xx in fn(i+1, x+k)]
            if k and 0 <= x-k: ans += [str(x) + xx for xx in fn(i+1, x-k)] 
            return ans 
        
        return sum((fn(0, x) for x in range(1, 10)), [])",0
"class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        # Post order traversal to make sure we transit left, right and root so that camera's can be assigned in the right order.
        def postorder(root, parent):
            if not root:
                return 0
            
            L = postorder(root.left, root)
            R = postorder(root.right, root)
            
            # check if something is a tail node. 
            tail_node = (not root.left and not root.right)
            
            # Camera coverage is there if either a camera exists or if a camera cover node
            # however, if we discovered coverage to children or camera with children, 
            # we dont want to assign camera too root but to its parent. 
            # Only case need covering in the root node. 
            left_camera = (not root.left) or (root.left and root.left.val >= 1)
            right_camera = (not root.right) or (root.right and root.right.val >= 1)
            iscovered = left_camera and right_camera 

            # check if either children is not having coverage == 0 
            # usecase : root has left chld covered by its children but on right side its not covered the the root needs to have a camera. 
            either_zero = False
            
            if root.left and root.left.val == 0:
                either_zero = True
            if root.right and root.right.val == 0:
                either_zero = True
                
            if not parent and (root.val == 2 or root.val == 0):
                return L + R + (1 if (either_zero or not root.val) else 0)
            elif not tail_node and not iscovered:
                root.val = 1
                # if root needs camera, then propagate coverate to its parent and children.
                if parent:
                    parent.val = 2 if parent.val == 0 else parent.val
                
                if root.left:
                    root.left.val = 2 if root.left.val == 0 else root.left.val
                    
                if root.right:
                    root.right.val = 2 if root.right.val == 0 else root.right.val
                
                L += 1                
                            
            return L + R 
                        
        mc = postorder(root, None)

        return mc",0
"class Solution:
    def pancakeSort(self, A: List[int]) -> List[int]:
        sort_k_list = []
        ''' sorting k used for pancake flip '''
        for i in range(len(A), 0, -1):
            v = A[i-1]
            if v != i:
                # Start pancake sorting
                # 0) Look for value as `v`
                vi = A.index(i)

                # 1) Performing pancake flip twice to move value `v` into
                #    destined position `i`
                if vi >= 1:
                    sort_k_list.append(vi+1)    # 1.1 Move value `v` to first position
                    A[:vi+1] = A[:vi+1][::-1]
                    sort_k_list.append(i)       # 1.2 Move value `v` from first position to target position `i`
                    A[:i] = A[:i][::-1]                    
                else:
                    # value `v` is already at first position
                    # so swap it to the destined position
                    sort_k_list.append(i)
                    A[:i] = A[:i][::-1]                    
            
        return sort_k_list",0
"class Solution:
    def powerfulIntegers(self, x, y, bound):
        answer = []
        cnt1 = 0
        cnt2 = 0
        while x**(cnt1+1) <= bound:
            if x == 1:
                break
            cnt1 += 1
        while y**(cnt2+1) <= bound:
            if y == 1:
                break
            cnt2 += 1
        for i in range(cnt1+1):
            for j in range(cnt2+1):
                if x**(i) +y**(j) <= bound:
                    answer.append((x**(i) +y**(j)))
        answer = set(answer)
        answer = list(answer)
        return (answer)



x = 1
y = 2
bound = 100
Solution().powerfulIntegers(x,y, bound)",0
"class Solution:
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        ans = []
        stack = [root]
        i = 0 
        while stack: 
            node = stack.pop()
            if node: 
                if node.val != voyage[i]: return [-1]
                i += 1
                if node.left and node.right and voyage[i] == node.right.val: 
                    ans.append(node.val)
                    node.left, node.right = node.right, node.left 
                stack.extend([node.right, node.left])
        return ans",0
"class Solution:

    def to_float(self, n: str) -> float:
        if ""."" not in n:
            return float(n)
        whole, dec = n.split(""."")
        if dec:
            if ""("" in dec:
                idx_bracket = dec.index(""("")
                return float(f""{whole}.{dec[:idx_bracket]}{dec[idx_bracket + 1: -1] * 17}"")
            return float(f""{whole}.{dec}"")
        return float(f""{whole}."")

    def isRationalEqual(self, s: str, t: str) -> bool:
        return abs(self.to_float(s) - self.to_float(t)) < 1e-16",1
"class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key = lambda x: x[0] ** 2 + x[1] ** 2)[:k]",0
"class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
    	D, s = {0:1}, 0
    	for a in A:
    		s = (s + a) % K
    		if s in D: D[s] += 1
    		else: D[s] = 1
    	return sum(i*(i-1)//2 for i in D.values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def oddEvenJumps(self, arr: List[int]) -> int:
        large = [-1] * len(arr)
        small = [-1] * len(arr)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (x[1], x[0])): 
            while stack and stack[-1] < i: large[stack.pop()] = i 
            stack.append(i)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (-x[1], x[0])): 
            while stack and stack[-1] < i: small[stack.pop()] = i
            stack.append(i)
        
        odd = [0] * len(arr)
        even = [0] * len(arr)
        odd[-1] = even[-1] = 1
        for i in reversed(range(len(arr))): 
            if 0 <= large[i]: odd[i] = even[large[i]]
            if 0 <= small[i]: even[i] = odd[small[i]]
        return sum(odd)",0
"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        # Condition of a triangle a<(b+c) and a>=b>=c
        nums=sorted(nums,reverse=True)
        for i in range(len(nums)-2):
            if nums[i]<nums[i+1]+nums[i+2]:
                return nums[i] + nums[i+1] + nums[i+2]
        return 0",1
"class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            nums[i] = nums[i]**2
        nums.sort()
        return nums",1
"class Solution:
    def maxTurbulenceSize(self, A: List[int]) -> int:
        index = 0
        A_len = len(A)
        A_len_ = A_len - 1
        current_length = 1
        max_length = 1
        
        
        while (A_len - index > max_length):
            while (index < A_len_ and A[index + 1] == A[index]):
                index += 1
             
            
            if (A_len - index > max_length):    
                faktor = 1 if A[index] > A[index + 1] else -1
                index += 1
                current_length = 2


                while (index < A_len_ and faktor * A[index] < faktor * A[index + 1]):
                    faktor = -faktor
                    current_length += 1
                    index += 1


                if (current_length > max_length):
                    max_length = current_length
                    
        return max_length",0
"class Solution:
    def distributeCoins(self, root: TreeNode) -> int:
        
        def fn(node):
            """"""Return flux (surplus/deficit) of node.""""""
            nonlocal ans 
            if not node: return 0
            left, right = fn(node.left), fn(node.right)
            ans += abs(left) + abs(right)
            return node.val - 1 + left + right # surplus/deficit 
        
        ans = 0
        fn(root)
        return ans",1
"class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        moves = ((1, 0), (-1, 0), (0, 1), (0, -1))
        ans = 0

        # ----------------------------------------------
        def dfs(grid, r, c, vertexSet):
            nonlocal ans, moves

            vertexSet.remove((r, c))
            if grid[r][c] == 2:
                if len(vertexSet) == 0:
                    ans += 1
                return

            for x, y in moves:
                x, y = r + x, c + y
                if (x, y) in vertexSet:
                    dfs(grid, x, y, vertexSet.copy())
        # -----------------------------------------------
        
        vertexSet = set()
        r1, r2 = 0, 0
        for r in range(len(grid)):                  # Add (row, col) in set if it is not onstacle
            for c in range(len(grid[0])):
                if grid[r][c] != -1:
                    if grid[r][c] == 1:
                        r1, c1 = r, c
                    vertexSet.add((r, c))
                    
        dfs(grid, r1, c1, vertexSet)                # Start DFS from start - (row, col) 
        return ans",0
"class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        ans = 0
        mem = [0] * (1 << 16)
        size = len(nums)

        for i in range(size):
            for j in range(i, size):
                mem[nums[i]&amp;nums[j]] += 2 if i != j else 1
        
        for ij in range(1 << 16):
            if mem[ij] > 0:
                for k in nums:
                    if k &amp; ij == 0:
                        ans += mem[ij]
        return ans",1
"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        dp = [0]*(days[-1]+1)
        for i in range(len(dp)):
            if i in days:
                dp[i] = min(dp[max(0, i-1)]+costs[0],
                            dp[max(0, i-7)]+costs[1], dp[max(0, i-30)]+costs[2])
            else:
                dp[i] = dp[i-1]
        return dp[-1]",1
"class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
		# n = current # of consecutive chracters in res that are the same
		# positive if it's consecutive as, negative if it's bs
        n = 0
        res = ''
        while a and b:
            if n == -2 or (n != 2 and a >= b):
                res += 'a'
                a -= 1
                n = max(1, n + 1)
            else:
                res += 'b'
                b -= 1
                n = min(-1, n - 1)
        return res + (a * 'a') + (b * 'b')",0
"class Solution:
    def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:
        s=0
        a=[0]*len(queries)
        for i in A:
            if i%2==0:
                s+=i
                
        for i in range(len(queries)):
            indx=queries[i][1]
            val=queries[i][0]
            
            if val%2==0:
                if A[indx]%2==0:
                    s+=val


            else:
                if A[indx]%2==0:
                    s-=A[indx]
                   

                else:
                    s+=A[indx]+val
                
            A[indx]+=val
            a[i]=s
                
            
        return a",0
"class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        LA, LB, I, i, j = len(A), len(B), [], 0, 0
        while i < LA and j < LB:
            a, b, i = A[i], B[j], i + 1
            if a[1] > b[1]: a, b, i, j = b, a, i - 1, j + 1
            if b[0] <= a[1]: I.append([max(a[0],b[0]),a[1]])
        return I
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        cols_hash_map = collections.defaultdict(lambda : collections.defaultdict(list))
        min_col = math.inf
        max_col = -math.inf
        max_row = -math.inf
        def traverse(root, row, col):
            nonlocal min_col, max_col, max_row
            if not root:
                return
            min_col = min(min_col, col)
            max_col = max(max_col, col)
            max_row = max(max_row, row)
            bisect.insort(cols_hash_map[col][row], root.val)
            
            traverse(root.left, row + 1, col - 1)
            traverse(root.right, row + 1, col + 1)
            
        traverse(root, 0, 0)
        res = []
        for i in range(min_col, max_col + 1):
            tmp = []
            for j in range(max_row + 1):
                tmp.extend(cols_hash_map[i][j])
            res.append(tmp)
        return res",0
"class Solution:
    stack = []
    best = None
    
    def lexorder(s1,s2):
        if s1 == None:
            return s2
        for i in range(min(len(s1),len(s2))):
            if s1[i] < s2[i]:
                return s1
            elif s1[i] > s2[i]:
                return s2
        if len(s1) < len(s2):
            return s1
        return s2
    
    def dfs(self, root):
        Solution.stack.append(root.val)
        if root.left:
            self.dfs(root.left)
        if root.right:
            self.dfs(root.right)
        if root.left == None and root.right == None:
            Solution.best = Solution.lexorder(Solution.best, Solution.stack[::-1])
        Solution.stack.pop()
        
    def smallestFromLeaf(self, root: TreeNode) -> str:
        self.dfs(root)
        return """".join([chr(x+97) for x in Solution.best])",0
"class Solution(object):
    def addToArrayForm(self, A, K):
        """"""
        :type A: List[int]
        :type K: int
        :rtype: List[int]
        """"""
        A = int(''.join(map(str, A)))
        B = A + K
        C = list(map(int, str(B)))
        return C",1
"class Solution:
    def __init__(self):
        self.id_ = [i for i in range(26)]
    
    def find(self,x):
        while x != self.id_[x]:
            self.id_[x] = self.id_[self.id_[x]]
            x = self.id_[x]
        return x
    
    def union(self,x,y):
        x = self.find(x)
        y = self.find(y)
        self.id_[x] = self.id_[y]
    
    def equationsPossible(self, equations: List[str]) -> bool:
        for a,sign,_,b in equations:
            if sign == '=':
                self.union(ord(a)-97,ord(b)-97)
        for a,sign,_,b in equations:
            if sign == '!':
                if self.find(ord(a)-97) == self.find(ord(b)-97):
                    return False
        return True",0
"class Solution:
    def brokenCalc(self, X: int, Y: int) -> int:
        c = 0
        while Y>X:
            if Y%2: Y += 1
            else: Y //= 2     
            c += 1
        return c + (X - Y)",1
"class Solution:
    def atMostK(self, nums, k):
        good_count = 0
        counter = collections.Counter()
        
        begin = 0
        for end in range(len(nums)):
            if counter[nums[end]] == 0:
                k -= 1
            counter[nums[end]] += 1
            
            while k < 0:
                counter[nums[begin]] -= 1
                if counter[nums[begin]] == 0:
                    k += 1
                
                begin += 1
            
            good_count += end - begin + 1
        
        return good_count
            
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        return self.atMostK(nums, k) - self.atMostK(nums, k - 1)",0
"class Solution(object):
    def isCousins(self, root, x, y):
        """"""
        :type root: TreeNode
        :type x: int
        :type y: int
        :rtype: bool
        """"""
        def f(root, v, p):
            if root.val == v:
                _d = 1
                _p = p
                return _d, _p
            
            if root.left!=None:
                l_d, l_p = f(root.left, v, root.val)
                if l_d!=None:
                    return l_d+1, l_p
                
            if root.right!=None:
                r_d, r_p = f(root.right, v, root.val)
                if r_d!=None:
                    return r_d+1, r_p             
            return None, p
			
        _x = f(root, x, None)
        _y = f(root, y, None)
        return (_x[0] == _y[0]) and (_x[1] != _y[1])",0
"class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        # 0  =  means empty
        # 1  =  fresh orange
        # 2  =  rotten orange
        # every minute any every rotten orange infects its adjacent fresh orange
        # min no of minutes to make all rotten else -1
            
        fresh_oranges = 0
        rotten_oranges = []
        rows = len(grid)
        cols = len(grid[0])
        steps = 0
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    fresh_oranges += 1
                elif grid[r][c] == 2:
                    rotten_oranges.append((r,c))
        if fresh_oranges == 0: return 0            
        while rotten_oranges:
            tmp = []
            while rotten_oranges:
                r,c = rotten_oranges.pop(0)
                paths = ((r+1,c),(r-1,c),(r,c+1),(r,c-1))
                for x,y in paths:
                    if 0<=x<rows and 0<=y<cols and grid[x][y] == 1:
                        grid[x][y] = 2
                        fresh_oranges -=1
                        if fresh_oranges == 0: return steps + 1
                        tmp.append((x,y))
            steps += 1
            rotten_oranges = tmp
        
        return -1",0
"class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = flip = 0 
        queue = deque()
        for i, x in enumerate(nums):
            if queue and i == queue[0]: 
                flip ^= 1
                queue.popleft()
            if x == flip: 
                if len(nums) - i < k: return -1
                ans += 1
                flip ^= 1
                queue.append(i+k)
        return ans",1
"class Solution:
def numSquarefulPerms(self, A: List[int]) -> int:
     
    res = []
    visited = [0] * len(A)
    A.sort()
    def helper(nums,out, res):
        if len(out) == len(nums):
            res.append(out[:])
            return
        else:
             
            for i in range(len(A)):
                if visited[i]:
                    continue
                if i > 0 and A[i] == A[i-1] and visited[i -1]:
                    continue
                if len(out) >= 2 and (out[-1] +out[-2])**0.5 != int((out[-1] +out[-2])**0.5):
                    continue
                if len(out) >= 1 and (out[-1] +A[i])**0.5 != int((out[-1] +A[i])**0.5):
                    continue
                visited[i] = 1
                out.append(A[i])
                helper(nums,out, res)
                out.pop()
                visited[i] = 0
    helper(A,[], res)
    #print(res)
    return len(res)",0
"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        if n == 1:
            return 1
        
        d = {}
        trusted = set()
        
        for t in trust:
            if t[1] not in d:
                d[t[1]] = []
            d[t[1]].append(t[0])
            trusted.add(t[0])
        
        for key in d:
            if len(d[key]) == n - 1 and key not in trusted:
                return key
        
        return -1

class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        count = [0] * (n + 1)
        
        for t in trust:
            count[t[0]] -= 1
            count[t[1]] += 1
        
        for i in range(1, n + 1):
            if count[i] == n - 1:
                return i
        
        return -1",0
"class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        prev, node = None, root
        while node and val < node.val: prev, node = node, node.right
        
        temp = TreeNode(val, left=node)
        if prev: prev.right = temp 
        else: root = temp 
        return root",1
"class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        # At first find position of rook and save in 'iR' and 'jR' variables
        for i in range(len(board)):
            for j in range(len(board[i])):
                if board[i][j] == 'R':
                    iR = i
                    jR = j
        # find all first figures on line and row
        res = []
        for j in range(jR + 1, len(board)):
            if board[iR][j] != '.':
                res.append(board[iR][j])
                break
        for j in range(jR - 1, -1, -1):
            if board[iR][j] != '.':
                res.append(board[iR][j])
                break
        for i in range(iR + 1, len(board)):
            if board[i][jR] != '.':
                res.append(board[i][jR])
                break
        for i in range(iR - 1, -1, -1):
            if board[i][jR] != '.':
                res.append(board[i][jR])
                break
        # calculate how many pawns
        resCount = 0
        for i in range(len(res)):
            if res[i] == 'p':
                resCount += 1
        return resCount",0
"class Solution:
    @cache
    def dp(self, l, r, piles) -> int:
        if r - l < piles:
            return inf
        if r - l == piles:
            return 0
        if piles == 1:
            return self.dp(l, r, self.k) + self.prefix_sum[r] - self.prefix_sum[l]
        return min(self.dp(l, m, i) + self.dp(m, r, piles - i) for i in range(1, piles) for m in range(l+i, r-i+1))
            
    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones) - k) % (k - 1) != 0:
            return -1
        self.k = k
        self.prefix_sum = [0]
        for i in range(0, len(stones)):
            self.prefix_sum.append(self.prefix_sum[-1] + stones[i])
        return self.dp(0, len(stones), 1)",0
"class Solution:
def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
    
    row,col,dig1,dig2 = defaultdict(int),defaultdict(int),defaultdict(int),defaultdict(int)
    
    def switch(i,j,isOn):
        val = 1 if isOn else -1
        row[i] += val
        col[j] += val
        dig1[i+j]+=val
        dig2[i-j]+=val
    
    def check(x,y):
        return 1 if row[x] or col[y] or dig1[x+y] or dig2[x-y] else 0
    
    seen = set()
    for x,y in set([tuple(lamp) for lamp in lamps]):
        seen.add((x,y))
        switch(x,y,1)
    
    res = []
    for x,y in queries:
        res.append(check(x,y))
        for dx,dy in [(0,0),(0,1),(0,-1),(1,0),(-1,0),(1,1),(-1,-1),(1,-1),(-1,1)]:
            if (x+dx,y+dy) in seen:
                seen.remove((x+dx,y+dy))
                switch(x+dx,y+dy,0)
    return res",0
"class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        n = len(A)
        if n == 0:
            return []
        master = None
        
        for word in A:
            freq = get_freq(word)
            if master is None:
                master = freq
            else:
                master = get_new_master(master, freq)
        output = []
        for char in master:
            output = output + [char]*master[char]
        return output
                
def get_new_master(m, s):
    dict = {}
    for char in m:
        if char in s:
            if s[char] >= m[char]:
                dict[char] = m[char]
            else:
                dict[char] = s[char]
    return dict
        
def get_freq(word):
    dict = {}
    for char in word:
        if char in dict:
            dict[char]+=1
        else:
            dict[char] = 1
    return dict",0
"class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s: 
            if c == ""c"" and stack[-2:] == [""a"", ""b""]:
                stack.pop()
                stack.pop()
            else: stack.append(c)
        return not stack",1
"class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        ans = ii = cnt = 0
        for i, x in enumerate(A):
            if not x: cnt += 1
            while ii <= i and cnt > K: 
                if not A[ii]: cnt -= 1
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans",1
"class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        heapq.heapify(A)
        for i in range(K):
            heapq.heappush(A,-1 * heapq.heappop(A))
        return sum(A)",1
"class Solution:
    def clumsy(self, n: int) -> int:
        if n == 1 or n == 2:
            return n
        if n >= 3:
            fact = n * (n - 1) // (n - 2)
            n -= 3
        while n - 4 >= 0:
            fact = fact + n - (n - 1) * (n - 2) // (n - 3)
            n -= 4
        if n > 0:
            fact += n
            n = n - 1
            if n > 0:
                fact -= n
                n = n- 1
        return fact",1
"class Solution(object):
    def minDominoRotations(self, A, B):
        """"""
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """"""
        for x in range(1, 7):
            ca = cb = 0
            for i in range(len(A)):
                if A[i] != x and B[i] != x:
                    break
            else:
                for i in range(len(A)):
                    if A[i] != x:
                        ca += 1
                    if B[i] != x:
                        cb += 1
                return min(ca, cb)
        return -1",1
"class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        root = None
        for i in range(len(preorder)):
            node = preorder[i]
            root = self.handle(root, node)
        return root
        
    def handle(self, root, x):
        if not root:
            return TreeNode(x)
        if x < root.val:
            root.left = self.handle(root.left, x)
        else:
            root.right = self.handle(root.right, x)
        return root",1
"class Solution:
    def bitwiseComplement(self, N: int) -> int:
        position_value = 1
        ret = 0
        
        
        if (N == 0):
            return 1
        
        
        while (N > 0):
            if (not N &amp; 1):
                ret += position_value
            
            N //= 2
            position_value *= 2
                     
        return ret",1
"class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        count=0
        d={}
        for i in time:
            k=i%60
            if k in d:
                d[k]+=[i]
            else:
                d[k]=[i]
        for i in d:
            if i==30 or i==0 :count+=int(((len(d[i])**2)-len(d[i]))//2)
            elif 60-i in d:
                count+=len(d[i])*len(d[60-i])
                d[i]=[]
                d[60-i]=[]
        return count",1
"class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        
        def canShip(capacity: int) -> bool:
            nonlocal D
            count = 1
            loaded = 0 
            for w in weights:
                if loaded + w <= capacity:
                    loaded += w
                else:
                    count += 1
                    loaded = w
            return count <= D
            
        
        maxWeight = max(weights)
        lo = sum(weights) // D
        hi = maxWeight * len(weights) // D + 1
        while lo < hi:
            mid = (lo + hi) // 2
            if mid < maxWeight or not canShip(mid):
                lo = mid + 1
            else:
                hi = mid
        return lo",0
"class Solution:
    def numDupDigitsAtMostN(self, N: int) -> int:
    	T = [9,261,4725,67509,831429,9287109,97654149,994388229]
    	t = [99,999,9999,99999,999999,9999999,99999999,999999999]
    	if N < 10:
    		return 0
    	L = len(str(N))
    	m, n = [1], []
    	g = 11-L
    	for i in range(L):
    		n.append(int(str(N)[i]))
    		m.append(g)
    		g = g*(12-L+i)
    	S = 0
    	for i in range(L):
    		if len(set(n[:L-i-1])) != len(n)-i-1:
    			continue
    		k = 0
    		for j in range(10):
    			if j not in n[:L-i-1] and j > n[L-i-1]:
    				k += 1
    		S += k*m[i]
    	return(T[L-2]-(t[L-2]-N-S))
	
- Python 3
- Junaid Mansuri",0
"class Solution:
    def canThreePartsEqualSum(self, A):
        A += [0]
        sa = sum(A)
        saby3 = sa // 3
        sdum = 0
        count = 0
        x = 0
        for x in range(len(A)):
            sdum += A[x]
            if sdum == saby3:
                count += 1
                sdum = 0
            if count == 3:
                break
        if count == 3 and sum(A[x:1]) == 0:
            return True
        else:
            return False",1
"class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        prev, res = values[0], 0
        
        for i in range(1, len(values)):
            res = max(res, prev + values[i] - i)
            prev = max(prev, values[i] + i)
        
        return res",1
"class Solution:
    def smallestRepunitDivByK(self, K: int) -> int:
    	if K % 2 == 0 or K % 5 == 0: return -1
    	i = n = 1
    	while n % K != 0: n, i = (10*n + 1) % K, i + 1
    	return i
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def queryString(self, S: str, N: int) -> bool:
        
        for i in range(1,N+1):
            x=str(bin(i).replace(""0b"", """"))
            
            if S.find(x)==-1:
                return False
            
        return True",1
"class Solution:
    def baseNeg2(self, N: int) -> str:
        ans = []
        while N: 
            ans.append(N &amp; 1)
            N = -(N >> 1)
        return """".join(map(str, ans[::-1] or [0]))",1
"class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        
        state = 0
        answer = []
        for a in A:
            if a == 0:
                state = ( 2*state ) % 5
            else:
                state = ( 2*state+1 ) % 5
            answer.append(state==0)
        return answer",1
"class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        prev, node = None, head
        while node: node.next, node, prev = prev, node.next, node
        
        node = prev 
        ans, stack = [], []
        while node: 
            while stack and stack[-1] <= node.val: stack.pop()
            ans.append(stack[-1] if stack else 0)
            stack.append(node.val)
            node = node.next 
        return ans[::-1]",0
"class Solution:
    
    # Generates all coordinates on boundaries
    def boundary_coordinates(self, grid):
        rows = len(grid)
        cols = len(grid[0])
        for row_index in range(rows):
            yield (row_index, 0) 
            yield (row_index, cols - 1)
        for col_index in range(1, cols - 1):
            yield (0, col_index)
            yield (rows - 1, col_index)
    
    # Returns a set of all 1's on boundaries.
    def ones_on_boundaries(self, grid):
        coordinates = self.boundary_coordinates(grid)
        return {(row, col) for row, col in coordinates if grid[row][col] == 1} 
    
    # Generates the neighbours of a given cell
    def get_neighbours(self, row, col, grid):
        if row > 0:
            yield (row - 1, col)
        if col > 0:
            yield (row, col - 1)
        if row < len(grid) - 1:
            yield (row + 1, col)
        if col < len(grid[0]) - 1:
            yield (row, col + 1)
    
    # Counts the number of enclaves.
    def numEnclaves(self, A: List[List[int]]) -> int:
        total_ones = sum([sum(row) for row in A])
        reachable_ones = 0
        visited = self.ones_on_boundaries(A)
        ones_reachable_on_boundary = list(visited)
        while ones_reachable_on_boundary:
            row, col = ones_reachable_on_boundary.pop()
            reachable_ones += 1
            for adj_row, adj_col in self.get_neighbours(row, col, A):
                if (adj_row, adj_col) not in visited and A[adj_row][adj_col] == 1:
                    visited.add((adj_row, adj_col))
                    ones_reachable_on_boundary.append((adj_row, adj_col))
        return total_ones - reachable_ones",0
"class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        if not S:
            return ''
        # find the outmost Paretheses index
        opened = 0
        result = []
        left = 0
        for index,item in enumerate(S):
            opened += 1 if item == '(' else -1
            if opened == 0:
                result.append(S[left+1:index])
                left = index +1
                
        return """".join(result)",1
"class Solution:
    def sumRootToLeaf(self, root: TreeNode) -> int:
        binaryNumbers = self.pathFinder(root)
        s = 0
        for num in binaryNumbers:
            s += int(num, 2)
        return s
    
    def pathFinder(self, root):
        if root is None:
            return []
        if root.left is None and root.right is None:
            return [str(root.val)]
        lp = self.pathFinder(root.left)
        rp = self.pathFinder(root.right)
        left = [str(root.val) + str(p) for p in lp]
        right = [str(root.val) + str(p) for p in rp]
        return left + right",1
"class Solution:
    def camelMatch(self, queries, pattern):
        return [Solution.match(q, pattern) for q in queries]

    @staticmethod
    def match(query, pattern):
        hit = []
        idx_start = 0

        for p in pattern:
            idx_find = query.find(p, idx_start)
            if idx_find == -1: return False

            for letter in query[idx_start:idx_find]:
                if letter.isupper(): return False

            hit.append(idx_find)
            idx_start = idx_find + 1

        for letter in query[idx_start:]:
            if letter.isupper(): return False

        return True",1
"class Solution:
    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        if not T: return 0 # edge case 
        
        ans = yy = mx = 0
        for x, y in sorted(clips):
            if mx < x: return -1 # gap 
            if yy < x <= mx: ans, yy = ans+1, mx
            mx = max(mx, y)
            if T <= mx: return ans + 1
        return -1 # not reaching T",0
"class Solution:
    winnums = []
    losenums = [1]
    
    def divisorGame(self, N: int) -> bool:
        if self.calcGame(N) >=0 :
            return True
        else:
            return False

    def calcGame(self, N):
        divisors = []
        
        if N in self.winnums:
            return 1
        if N in self.losenums:
            return -1

        for num in range(1,N):
            if N % num == 0:
                divisors.append(num)
        if len(divisors)==0:
            self.losenums.append(N)
            return -1

        
        for divisor in divisors:
            newNum = N-divisor
            profit = - self.calcGame(newNum)
            
            if profit == 0:
                continue
            if profit >= 0:
                self.winnums.append(N)
                return 1
       
        self.losenums.append(N)
        return -1",1
"class Solution:
    def maxAncestorDiff(self, root: TreeNode) -> int:
        return self._max_ancestor_diff(root, root.val, root.val)

    def _max_ancestor_diff(self, root: TreeNode, max_ancestor_val: int, min_ancestor_val: int) -> int:
        if root is None:
            return 0
        return max(
            abs(max_ancestor_val - root.val),
            abs(min_ancestor_val - root.val),
            self._max_ancestor_diff(
                root.left, max(max_ancestor_val, root.val), min(min_ancestor_val, root.val)),
            self._max_ancestor_diff(
                root.right, max(max_ancestor_val, root.val), min(min_ancestor_val, root.val))
        )",0
"class Solution(object):
  def longestArithSeqLength(self, A):
    idx = collections.defaultdict(list)
    for i, v in enumerate(A):
      idx[v].append(i)
    c = {}
    ans = 0
    for k in range(len(A)):   # last
      for j in range(k):      # middle
        v = 2 * A[j] - A[k]   
        if v in idx:
          for i in idx[v]:    # list of first
            if i >= j: 
              break
            r = 1
            if (i, j) in c:
              r = max(r, c[i, j] + 1)
            ans = max(ans, r)
            c[j, k] = r
    return ans + 2",1
"class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        i = 0
        stack = []
        
        fake = TreeNode(0)
        stack.append(fake)
        
        while i < len(traversal):
            lvl = 0
            while i < len(traversal) and traversal[i] == '-':
                lvl += 1
                i += 1
            
            beg = i
            while i < len(traversal) and traversal[i] != '-':
                i += 1
            
            val = int(traversal[beg:i])
            
            while len(stack)  - 1 > lvl:
                stack.pop()
                
            children = TreeNode(val)
            node = stack[-1]
            
            if node.left == None:
                node.left = children
            else:
                node.right = children
            
            stack.append(children)
        
        return stack[0].left",0
"class Solution:
	def twoCitySchedCost(self, costs: List[List[int]]) -> int:
		res=0
		size=len(costs)/2
		CityA=0
		CityB=0
		costs=sorted(costs, key=lambda x:abs(x[0]-x[1]),reverse=True)
		for i in costs:
			if CityB<size and i[0]>=i[1]:
				res+=i[1]
				CityB+=1
			elif CityA<size and i[1]>=i[0]:
				res+=i[0]
				CityA+=1
			elif CityA==size:
				res+=i[1]
			elif CityB==size:
				res+=i[0]       
		return res",0
"class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        res = []
        for r in range(0, R):
            for c in range(0, C):
                res.append([r,c])
        return sorted(res, key=lambda x: abs(x[0] - r0) + abs(x[1] - c0))",0
"class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        if L<M:
            L,M=M,L
        res=-float('inf')
        for i in range(len(A)-L+1):
            temp1=sum(A[i:i+L])
            #if left
            if i>=M:
                for j in range(i-M+1):
                    t2=sum(A[j:j+M])
                    res=max(res,temp1+t2)
            #if right
            if len(A)-i-L>=M:
                for j in range(i+L,len(A)):
                    t2=sum(A[j:j+M])
                    res=max(res,temp1+t2)
        return res",0
"class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        a,b,c = sorted([a,b,c])
        d1 = abs(b-a)-1 
        d2 = abs(c-b)-1
        mi = 2
        if d1 == 0 and d2 == 0: mi = 0
        elif d1 <= 1 or d2 <= 1: mi =1    
        ma = c - a - 2
        return [mi,ma]",0
"class Solution:
    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        orig = grid[r0][c0]
        seen = {(r0, c0)}
        stack = [(r0, c0)]
        while stack: 
            i, j = stack.pop()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if (ii, jj) not in seen:
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == orig: 
                        stack.append((ii, jj))
                        seen.add((ii, jj))
                    else: grid[i][j] = color 
        return grid",0
"class Solution:
    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:
        ans = [0]*(1 + len(B))
        for i in reversed(range(len(A))): 
            tmp = ans.copy()
            for j in reversed(range(len(B))): 
                if A[i] == B[j]: ans[j] = 1 + tmp[j+1]
                else: ans[j] = max(tmp[j], ans[j+1])
        return ans[0]",0
"class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))
        
        def dfs(sx, sy, tx, ty): 
            """"""Return True if (x, y) is not looped from (tx, ty).""""""
            seen = {(sx, sy)}
            stack = [(sx, sy)]
            while stack: 
                x, y = stack.pop()
                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True 
                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): 
                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: 
                        seen.add((xx, yy))
                        stack.append((xx, yy))
            return False 
        
        return dfs(*source, *target) and dfs(*target, *source)",0
"class Solution:
    def isBoomerang(self, p: List[List[int]]) -> bool:
        return (p[2][1]-p[1][1])*(p[1][0]-p[0][0]) != (p[2][0]-p[1][0])*(p[1][1]-p[0][1])
		
		
- Junaid Mansuri",1
"class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        
        def fn(node, val):
            """"""Return updated node's value.""""""
            if node.right: val = fn(node.right, val)
            node.val = val = node.val + val
            if node.left: val = fn(node.left, val)
            return val 
            
        fn(root, 0)
        return root",1
"class Solution:
    def recursion(self,start,end):
        if start >= end :
            return 0
        
        if self.dp[start][end] != -1 : return self.dp[start][end]

        best = float('inf')
        
        for mid in range(start,end):
            tmp = self.recursion(start,mid) + self.recursion(mid+1,end) + \
            self.values[start-1]*self.values[mid]*self.values[end]
            if tmp < best: best = tmp
        
        self.dp[start][end] = best
        return best
    
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        self.dp = [[-1 for i in range(n)] for j in range(n)]
        self.values = values
        return self.recursion(1,n-1)",1
"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        high = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (len(stones) - 2)
        
        ii, low = 0, inf
        for i in range(len(stones)): 
            while stones[i] - stones[ii] >= len(stones): ii += 1
            if i - ii + 1 == stones[i] - stones[ii] + 1 == len(stones) - 1: low = min(low, 2)
            else: low = min(low, len(stones) - (i - ii + 1))
        return [low, high]",0
"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
       
        # Dictionary, which outputs change in direction
        # given the current direction and instruction
        directions = {0: {""G"": 0, ""L"": 3, ""R"": 1}, # North
                      1: {""G"": 1, ""L"": 0, ""R"": 2}, # East
                      2: {""G"": 2, ""L"": 1, ""R"": 3}, # South
                      3: {""G"": 3, ""L"": 2, ""R"": 0}} # West
        
        # Start position
        start = (0,0) # (x,y)
        
        # Function which will run robot once
        def moveRobot(curr, direction):
            
            # Loop for each instruction
            for instruction in instructions:
                
                # Set position
                if instruction == ""G"":
                    if direction == 0: # North
                        curr = (curr[0],curr[1]+1)
                    elif direction == 1: # East
                        curr = (curr[0]+1,curr[1])
                    elif direction == 2: # South
                        curr = (curr[0],curr[1]-1)
                    elif direction == 3: # West
                        curr = (curr[0]-1,curr[1])
                    else:
                        pass

                # Set direction
                direction = directions[direction][instruction]
                
            return (curr, direction)
        
		# Move robot from start position and pointing to North
        curr, direction = moveRobot(start,0)
        
        # Case 1:
        # If robot return to start then it won't leave a cetrain area
        if (curr == start):
            return True
        
        # Case 2:
        # If robot is not pointing towards north, it means it has changed
        # direction, so in next iteration it will change direction again,
        # and in next iteration again, and so on, so it will remain it
        # a certain bounded area no matter what.
        if (direction != 0):
            return True
        
        return False",0
"class Solution:
    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        # n gardens 1 to n
        # paths [x,y] bidirectional path between garden x and y
        # in each garden plant one of 4 types of flowers
        # at most 3 paths coming into or leaving it
        # choose flower type -> any two gardens connected by path have different flowers
        # return any choice of answers : answer[i] = flower in (i+1)th garden
        
        nodes = [x for x in range(n)]
        colour = [None]*n
        edges = {x:{} for x in range(n)}
        for x,y in paths:
            edges[x-1][y-1] = True
            edges[y-1][x-1] = True
        for node in range(n):
            adj = edges[node]
            blocked = [False]*n
            size = 4
            for x in adj:
                if colour[x] != None:blocked[colour[x]-1] = True
            if blocked[0] == False:
                colour[node] = 1
            elif blocked[1] == False:
                colour[node] = 2
            elif blocked[2] == False:
                colour[node] = 3
            elif blocked[3] == False:
                 colour[node] = 4
        return colour",0
"class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        
        @lru_cache(None)
        def fn(i):
            """"""Return maximum sum of arr[:i].""""""
            if i == 0: return 0 # boundary condition 
            ans = 0
            for kk in range(1, min(i, k)+1): 
                ans = max(ans, fn(i-kk) + max(arr[ii] for ii in range(i-kk, i)) * kk)
            return ans 
        
        return fn(len(arr))",1
"class Solution:
    def longestDupSubstring(self, s: str) -> str:
        results = set()
        window = len(s)//2
        largest = """"
        while window > len(largest):
            for right in range(window, len(s)+1):
                substr = s[right-window:right]
                if substr in results:
                    if len(substr) > len(largest):
                        largest = substr
                        window += (len(s)-window)//2+1
                        results.clear()
                        continue
                else:
                    results.add(substr)
            else:
                if window == len(largest) + 1:
                    break
                window = max(window//2, len(largest)+1)
        return largest",0
"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        for i, stone in enumerate(stones):
            stones[i] = -stone
        heapq.heapify(stones)

        while len(stones) > 1:
            y, x = heapq.heappop(stones), heapq.heappop(stones)
            if x != y:
                heapq.heappush(stones, y - x)
        
        return -stones[0] if stones else 0",1
"class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for char in s:
            if stack:
                # check if last element in stack
                # equals current char
                if char == stack[-1]:
                    stack.pop()
                    continue
                else:
                    stack.append(char)
            else:
                stack.append(char)

        return """".join(stack)",1
"class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        words.sort(key = lambda x : len(x))
        dis_map = collections.defaultdict(int)
        for w in words:
            maybe = [w[:i] + w[i + 1:] for i in range(len(w))]
            for m in maybe:
                dis_map[w] = max(dis_map[m] + 1, dis_map[w])
        return max(dis_map.values())",1
"class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        if len(stones) == 1:
            return stones[0]
        
        S = sum(stones)
        half = sum(stones) // 2
        
        mat = [False for _ in range(half+1)]
        
        for i in stones:
            arr = []
            for j in range(len(mat)):
                if j == i:
                    arr.append(i)
                elif i < j and not mat[j] and mat[j-i]:
                    arr.append(j)
            for x in arr: # simultaneous update
                mat[x] = True
        
        s2 = max([i for i in range(len(mat)) if mat[i]])
        return abs(S-2*s2)",1
"class Solution(object):
    def heightChecker(self, heights):
        """"""
        :type heights: List[int]
        :rtype: int
        """"""
        count =0
        k =heights[:]
        heights.sort()
        for i in range(len(heights)):
            if heights[i] != k[i]:
                count +=1
        return count",1
"class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
        accC = [0]
        n = len(customers)
        for x in customers:
            accC.append(x + accC[-1])
        for i, x in enumerate(grumpy):
            if x == 1: customers[i] = 0
        accCG = [0]   
        for x in customers:
            accCG.append(x + accCG[-1])
        return max(accC[min(i+X-1, n)]-accC[i-1] + accCG[-1] - (accCG[min(i+X-1, n)]-accCG[i-1]) for i in range(1, n+1))",0
"class Solution:
    def prevPermOpt1(self, arr: List[int]) -> List[int]:
        for i in reversed(range(len(arr)-1)):
            if arr[i] > arr[i+1]: break 
        else: return arr 
        
        ii, val = i, 0
        for k in range(i+1, len(arr)): 
            if val < arr[k] < arr[i]: ii, val = k, arr[k]
        
        arr[i], arr[ii] = arr[ii], arr[i]
        return arr",1
"class Solution:
    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        # Get the counts of all of our barcode elements.
        cnts = collections.Counter(barcodes)
		# Put the -'ve counts along with themselves into a min heap.
		# For those new to this we use -'ve because this is a min heap, so largest cnt pop'd first.
        heap = [(-v, k) for k,v in cnts.items()]
        heapq.heapify(heap)
        res = []
        # While we have elements on our heap.
        while heap:
		    # pop the top element.
            cnt1, num1 = heapq.heappop(heap)
			# If the top element was the last we used, we need something different.
            if res and res[-1] == num1:
			    # pop the next highest cnt element. 
                cnt, num = heapq.heappop(heap)
                res.append(num)
                cnt += 1
				# If there's still elements left we put them back on the heap.
                if cnt != 0:
                    heapq.heappush(heap, (cnt, num))
				# We can also add the first that we popped, and push it back on the heap as well.
                res.append(num1)
                cnt1 += 1
                if cnt1 != 0:
                    heapq.heappush(heap, (cnt1, num1))
			# else we just add the highest cnt element and put the remaining back on.
            else:
                res.append(num1)
                cnt1 += 1
                if cnt1 != 0:
                    heapq.heappush(heap, (cnt1, num1))
            
        return res",0
"class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        strings = [str1, str2] if len(str1) > len(str2) else [str2, str1]
        
        
        for length in range(len(strings[1]), 0, -1):
            if (not len(strings[0]) % length and not len(strings[1]) % length):
                substring = strings[1][:length]
                number_substrings_1 = len(strings[0]) // length
                number_substrings_2 = len(strings[1]) // length
                
                
                if (number_substrings_1 == strings[0].count(substring) and
                   number_substrings_2 == strings[1].count(substring)):
                    return substring
                
        return """"",0
"class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        d = collections.defaultdict(int)                # hashmap for counting
        m, n = len(matrix), len(matrix[0])
        for i in range(m):
            reverse = not matrix[i][0]                  # decide whether need to reverse bit
            cur = ''                                    # expanded version of above 1 liner
            for j in range(n):
                if reverse:
                    cur += '0' if matrix[i][j] else '1'
                else:    
                    cur += '1' if matrix[i][j] else '0'
            d[cur] += 1                                 # count frequency
        return max(d.values())",0
"class Solution:
    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        x = reduce(lambda x, y: x*(-2) + y, arr1)
        x += reduce(lambda x, y: x*(-2) + y, arr2)
        ans = []
        while x: 
            ans.append(x &amp; 1)
            x = -(x >> 1)
        return ans[::-1] or [0]",1
"class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        if not matrix:
            return 0
        
        def num_for_one_row(nums):
            prev = {}
            prev[0] = 1
            cur_sum = 0
            ans = 0
            for num in nums:
                cur_sum += num
                if cur_sum - target in prev:
                    ans += prev[cur_sum - target]
                if cur_sum not in prev:
                    prev[cur_sum] = 1
                else:
                    prev[cur_sum] += 1
            return ans 
        
        res = 0
        m = len(matrix)
        n = len(matrix[0])
        
        for i in range(m):
            nums = [0]*n
            for j in range(i,m):
                for k in range(n):
                    nums[k]+=matrix[j][k]
                res += num_for_one_row(nums)
                
        return res",0
"class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        res=[]
        def rec(t,now,k):
            nonlocal res
            if k==1:
                for i in t:
                    res.append(now+i)
                return
            for i in range(len(t)):
                rec(t[:i]+t[i+1:],now+t[i],k-1)
        for i in range(1,len(tiles)+1):
            rec(tiles,'',i)
        return(len(set(res)))",1
"class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:
        cands = set()
        def dfs(node, s):
            if node.left is None and node.right is None:
                if (s + node.val) < limit:
                    return True
                else:
                    return False
            else:
                if node.left:
                    left = dfs(node.left, s + node.val)
                    if left:
                        node.left = None
                else:
                    left = True
                if node.right:
                    right = dfs(node.right, s + node.val)
                    if right:
                        node.right = None
                else:
                    right = True
                return left and right
        if dfs(root, 0):
            return None
        return root",0
"class Solution:
    def smallestSubsequence(self, s: str) -> str:
        stack = []
        for i, c in enumerate(s):
            if c in stack:
                continue
            while stack and stack[-1] in s[i:] and c < stack[-1]:
                stack.pop()
            if c not in stack:
                stack.append(c)
        return ''.join(stack)",1
"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        temp = []
        for i in arr:
            if i == 0:
                temp.append(0)
                temp.append(0)
            else:
                temp.append(i)
        for i in range(len(arr)):
            arr[i] = temp[i]",1
"class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        N, M = len(grid), len(grid[0])
        directions = ((1,1),(1,0),(0,1),(1,-1),(-1,1),(0,-1),(-1,0),(-1,-1))
        
        Coordinate = namedtuple('Coordinate', ['x', 'y'])
        start = Coordinate(0,0)
        goal = Coordinate(N-1, M-1)
        
        if grid[start.x][start.y] != 0:
            return -1
        
        def withinBounds(curr):
            return 0 <= curr.x < N and 0 <= curr.y < M
        
        queue = deque([(start)])
        grid[start.x][start.y] = 1
        pathLength = 1
        
        while queue:
            for _ in range(len(queue)):
                curr = queue.popleft()

                if curr == goal:
                    return pathLength

                for r, c in directions:
                    neigh = Coordinate(curr.x + r, curr.y + c)
                    if withinBounds(neigh) and grid[neigh.x][neigh.y] == 0:
                        grid[neigh.x][neigh.y] = 1
                        queue.append(neigh)
            
            pathLength += 1

        return -1",0
"class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        
        @lru_cache(None)
        def fn(i, j): 
            """"""Return min length of common supersequence of str1[i:] and str2[j:].""""""
            if i == len(str1): return len(str2)-j
            if j == len(str2): return len(str1)-i
            if str1[i] == str2[j]: return 1 + fn(i+1, j+1)
            return 1 + min(fn(i+1, j), fn(i, j+1))
        
        ans = []
        i = j = 0 
        while i < len(str1) and j < len(str2): 
            if str1[i] == str2[j]: 
                ans.append(str1[i])
                i += 1
                j += 1
            elif fn(i+1, j) < fn(i, j+1): 
                ans.append(str1[i])
                i += 1
            else: 
                ans.append(str2[j])
                j += 1
        return """".join(ans) + str1[i:] + str2[j:]",0
"class Solution:
    def sampleStats(self, count: List[int]) -> List[float]:
        total = sum(count)
        mn = med0 = med1 = -1 
        psm = cnt = mode = 0
        for i, x in enumerate(count): 
            if x: 
                if mn < 0: mn = i
                mx = i
                psm += i * x
                cnt += x
                if cnt >= (total+1)//2 and med0 < 0: med0 = i
                if cnt >= (total+2)//2 and med1 < 0: med1 = i
                if x > count[mode]: mode = i
        return [mn, mx, psm/total, (med0+med1)/2, mode]",0
"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips = sorted(trips, key = lambda a: a[1])
        # print(trips)
        i = 0
        j = trips[0][1]
        se = collections.defaultdict(int)
        while i< len(trips):
            capacity+=se[j]
            del se[j]
            if j == trips[i][1]:
                se[trips[i][2]] += trips[i][0]
                capacity-= trips[i][0]
                i+=1
                if capacity<0:
                    return False
            
            else:
                j+=1
        return True",1
"class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        low = 0
        high = mountain_arr.length()
        peak = -1
        
        while (low < high - 1):
            mid = (low + high) // 2
            midVal = mountain_arr.get(mid)
            leftMid = mountain_arr.get(mid - 1)
            rightMid = mountain_arr.get(mid + 1)

            if (midVal > leftMid and midVal > rightMid):
                peak = mid
                break
            elif (midVal > leftMid and midVal < rightMid):
                low = mid 
            else:
                high = mid
        
        low = 0
        high = peak
        while (low <= high):
            mid = (low + high) // 2
            midVal = mountain_arr.get(mid)
            
            if midVal == target:
                return mid
            elif midVal < target:
                low = mid + 1
            else:
                high = mid - 1
                
        low = peak
        high = mountain_arr.length() - 1
        while (low <= high):
            mid = (low + high) // 2
            print(low, mid, high)
            midVal = mountain_arr.get(mid)
            
            if midVal == target:
                return mid
            elif midVal < target:
                high = mid - 1
            else:
                low = mid + 1
        
        return -1",0
"class Solution:
    def braceExpansionII(self, s: str) -> List[str]:
        def getWord():
            nonlocal i
            word = """"
            while i < len(s) and s[i].isalpha():
                word += s[i]
                i += 1
            return word
        
        
        def dfs():
            nonlocal i
            res = set()
            if s[i] == '{':
                i += 1
                res.update(dfs())
                while i < len(s) and s[i] == ',':
                    i += 1
                    res.update(dfs())
                i += 1
            elif s[i].isalpha():
                res.add(getWord())

            while i < len(s) and (s[i] == '{' or s[i].isalpha()): 
                res = {w + a for a in dfs() for w in res}
            return res

        i = 0
        return sorted(dfs())",0
"class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        cycle_offset = num_people * (num_people + 1) // 2
        cycles = 0
        n_2 = num_people ** 2
        required_candies = cycle_offset
        ret = []
        
        
        while (candies >= required_candies):
            cycles += 1
            candies -= required_candies
            required_candies = cycles * n_2 + cycle_offset

        
        if (cycles > 0):
            fixed_candy_size = cycles * (cycles - 1) // 2 * num_people


            for person in range(1, num_people + 1):
                ret.append(fixed_candy_size + cycles * person)
                
            fixed_candy_size = cycles * num_people


            for person in range(num_people):
                person_candies = fixed_candy_size + person + 1


                if (person_candies > candies):
                    ret[person] += candies
                    return ret
                else:
                    ret[person] += person_candies
                    candies -= person_candies
        else:
            skip = False
            
            
            for person in range(1, num_people + 1):
                if (skip):
                    ret.append(0)
                elif (candies < person):
                    ret.append(candies)
                    skip = True
                else:
                    ret.append(person)
                    candies -= person
                    
            return ret",0
"class Solution:
    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:
        if not books:
            return 0
        
        # dynamic programming
        # key = (extra_width at the last level, last layer height)
        # value = min_height
        best = dict()
        best[(shelf_width, 0)] = 0
        for width, height in books:
            new_best = dict()
            for (width_left, level_height), total_height in best.items():
                # start new level
                key = (shelf_width - width, height)
                val = total_height + height
                if key in new_best:
                    new_best[key] = min(new_best[key], val)
                else:
                    new_best[key] = val
                # use current level
                if width <= width_left:
                    key = (width_left - width, max(height, level_height))
                    val = total_height + max(height, level_height) - level_height
                    if key in new_best:
                        new_best[key] = min(new_best[key], val)
                    else:
                        new_best[key] = val
            best = new_best
        return min(best.values())",0
"class Solution:
    def parseBoolExpr(self, expression: str) -> bool:     
        # 0b0000 - ' '
        # 0b0100 - '!'
        # 0b1000 - '&amp;'
        # 0b1100 - '|'
        # 0b0010 (2) - if t in expression
        # 0b0001 (1) - if f in expression
        
        d = { 0b0110:1, 0b0101:2,
               0b1010:2, 0b1001:1, 0b1011:1,
               0b1110:2, 0b1101:1, 0b1111:2,
               0b0010:True, 0b0001:False }        

            
        levels = [0]
        for x in expression:                             
            if x == ',' or x == ""("":
                continue
            elif x == 't':
                levels[-1] |= 2
            elif x == 'f':
                levels[-1] |= 1
            elif x == ')':     
                level = levels.pop()
                levels[-1] |= d[level]
            elif x =='!':
                levels.append(0b0100)
            elif x =='&amp;':
                levels.append(0b1000)
            elif x =='|':
                levels.append(0b1100)                            
                
        return d[levels[0]]",0
"class Solution:
    def defangIPaddr(self, address: str) -> str:
        return (""[.]"".join(address.split(""."")))",1
"class Solution:
    def corpFlightBookings(self, b: List[List[int]], n: int) -> List[int]:
        res=[0]*n
        for i,j,k in b:
            for m in range(i-1,j):
                res[m]+=k
        return res",1
"class Solution:
    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        trees = []
        targets = set(to_delete)
        def dfs(root):
            if (not root): return root
            root.left = dfs(root.left)
            root.right = dfs(root.right)
            if (root.val not in targets): return root
            if (root.left): trees.append(root.left)
            if (root.right): trees.append(root.right)
            return None
        dummy = TreeNode(to_delete[0], left=root)
        dfs(dummy)
        return trees",1
"class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        depths = [0, 0] #depths[0]: A, depths[1]: B
        answer = []
        
        
        for char in seq:
            if (char == '('):
                if (depths[0] < depths[1]):
                    answer.append(0)
                    depths[0] += 1
                else:
                    answer.append(1)
                    depths[1] += 1
            else:
                if (depths[0] > depths[1]):
                    depths[0] -= 1 
                    answer.append(0)
                else:
                    depths[1] -= 1
                    answer.append(1)
            
        return answer",1
"class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        return sorted(arr1, key=lambda x: (arr2.index(x) if x in arr2 else math.inf, x))",0
"class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        
        @lru_cache(None)
        def fn(node):
            """"""Return height of tree rooted at node.""""""
            if not node: return 0 
            return 1 + max(fn(node.left), fn(node.right))
        
        node = root
        while node: 
            left, right = fn(node.left), fn(node.right)
            if left == right: return node
            elif left > right: node = node.left
            else: node = node.right",1
"class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        prefixSum=0
        hmap=defaultdict(int)
        ans=0
        for length,hour in enumerate(hours):
            prefixSum+=1 if hour>8 else -1
            if prefixSum>0:ans=max(ans,length+1)
            if prefixSum not in hmap:
                hmap[prefixSum]=length
            if prefixSum-1 in hmap:
                ans=max(ans,length-hmap[prefixSum-1])
        return ans",1
"class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        
        n_skills = len(req_skills)
        n_people = len(people)
        
        # index skills
        skill_map = {x: i for i, x in enumerate(req_skills)}
        
        # descending sort by length of skills per person
        people = sorted([(i, x) for i, x in enumerate(people)], key=lambda x: -len(x[1]))
        
        # bit people skill
        people_bit = {}
        for i, p in people:
            tmp = 0
            for s in p:
                tmp |= 1 << skill_map[s]
            # if a person skill cannot be covered from pervious people then added
            if all(x | tmp != x for x in people_bit): people_bit[tmp] = i 
        
        # reverse skill set and id
        people_bit = {v: k for k, v in people_bit.items()}
        cands = [*people_bit.keys()]

        # final answer and size for recording minimum team size
        self.ans = None
        self.size = float('inf')

        @lru_cache(None)
        def dp(i, mask, team):
            if mask == (1 << n_skills) - 1 and self.size > len(team):
                self.size = len(team)
                self.ans = team
                return
            if i == len(cands):
                return
            # if current person has skill not covered by previous included skills
            if mask | people_bit[cands[i]] != mask:
                dp(i + 1, mask | people_bit[cands[i]], tuple(set(team)|{cands[i]}))
            dp(i + 1, mask, team)


        dp(0, 0, tuple())
        return self.ans",0
"class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
    	s, D = 0, {}
    	for d in dominoes:
    		x = tuple(sorted(d))
    		if x in D:
    			D[x] += 1
    		else:
    			D[x] = 0
    	return sum([i*(i+1)//2 for i in list(D.values())])
		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    
    def __init__(self):
        self.m={}
    
    def mctFromLeafValues(self, arr: List[int]) -> int:
        
        def find_max(st,end,arr):
            if arr[st:end+1]==[]:
                return 0
            return max(arr[st:end+1])
        
        def helper(st,en,arr):
            
            if st==en:
                self.m[str(st)+"" ""+str(en)]=0
                return 0
            
            if (en-st)==1:
                self.m[str(st)+"" ""+str(en)]=arr[st]*arr[en]
                return arr[st]*arr[en]
            
            if str(st)+"" ""+str(en) in self.m:
                return self.m[str(st)+"" ""+str(en)] 
            
            ans=float(""inf"")
            
            for i in range(st,en):
                
                a=find_max(st,i,arr)
                b=find_max(i+1,en,arr)
                temp=helper(st,i,arr)+helper(i+1,en,arr)
                
                ans=min(ans,temp+(a*b))
                
            self.m[str(st)+"" ""+str(en)]=ans
            return ans
                
            
        
        
        return helper(0,len(arr)-1,arr)",0
"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
    	M = 0
    	for c in [[1,1],[1,-1],[-1,1],[-1,-1]]:
    		m = float('inf')
    		for i in [arr1[i]*c[0]+arr2[i]*c[1]+i for i in range(len(arr1))]:
    			if i < m: m = i
    			if i - m > M: M = i - m
    	return M
		
		
- Python 3
- Junaid Mansuri",1
"class Solution:
    def tribonacci(self, n: int) -> int:
        
        if n < 3:
            if n == 0:
                return 0
            if n == 1 or n == 2:
                return 1
        
        t0, t1, t2 = 0, 1, 1

        for i in range(3, n + 1):
            t = t0 + t1 + t2
            t0 = t1
            t1 = t2
            t2 = t

        return t",1
"class Solution:
    def alphabetBoardPath(self, target):
        hashTable = [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [5, 0]]
        OFFSET, current = 97, 0
        res = """"
        
        for t in target:
            v_move = hashTable[current][0] - hashTable[ord(t)-OFFSET][0]
            h_move = hashTable[current][1] - hashTable[ord(t)-OFFSET][1]
            
            while v_move != 0 or h_move != 0:
                #Go vertical direction
                while v_move != 0:
                    if v_move < 0 and current < 21:
                        res += 'D'
                        v_move += 1
                        current += 5
                    elif v_move > 0:
                        res += 'U'
                        v_move -= 1
                        current -= 5
                    else:
                        break
                
                #Go horizontal direction     
                current -= h_move
                while h_move != 0:
                    if h_move < 0:
                        res += 'R'
                        h_move += 1
                    else:
                        res += 'L'
                        h_move -= 1
            res += '!'
        return res",0
"class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions 
        
        hori = deepcopy(grid)
        vert = deepcopy(grid)
        for i in range(m):
            for j in range(n): 
                if grid[i][j]: 
                    if j: hori[i][j] += hori[i][j-1] # horizontal precipitation
                    if i: vert[i][j] += vert[i-1][j] # vertical precipitation 
        
        ans = 0
        for i in reversed(range(m)):
            for j in reversed(range(n)): 
                val = min(hori[i][j], vert[i][j])
                while val > ans: 
                    if vert[i][j-val+1] >= val and hori[i-val+1][j] >= val: 
                        ans = val 
                    val -= 1
        return ans*ans",0
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        @functools.cache
        def dp(l, m, i_am_alice): # lets return alice count
            if l == len(piles): return 0
            
            left = []
            taking_now = 0

            for x in range(2*m):
                if l+x == len(piles): break
                
                if i_am_alice:
                    taking_now += piles[l+x]
                taking_later = dp(l+x+1, max(m,x+1), not i_am_alice)
                
                left.append(taking_now + taking_later)
        
            if i_am_alice: # i want to maximize alice
                return max(left)
            
            else: # i am bob, want to minimize alice
                return min(left)
        
        return dp(0,1,True)",1
"class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text1)+1) for _ in range(len(text2)+1)]
        for i in range(1, len(text2)+1):
            for j in range(1, len(text1)+1):
                if text1[j-1] == text2[i-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[len(text2)][len(text1)]",0
"class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
    	L, m, M = len(nums), 0, 0
    	for i in range(1,L-1,2):
    		t = min(nums[i-1],nums[i+1])
    		if nums[i] >= t: m += nums[i] - t + 1
    	if i == L - 3 and nums[-1] >= nums[-2]: m += nums[-1] - nums[-2] + 1
    	for i in range(2,L-1,2):
    		t = min(nums[i-1],nums[i+1])
    		if nums[i] >= t: M += nums[i] - t + 1
    	if nums[0] >= nums[1]: M += nums[0] - nums[1] + 1
    	if (i == L - 3 or i == 1) and nums[-1] >= nums[-2]: M += nums[-1] - nums[-2] + 1
    	return min(m,M)
		
		
- Junaid Mansuri",0
"class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        # solution below doesn't use all the info provided
        # namely, total number of nodes
        # do a simple dfs to capture left, right nodes from target x
        # this gives you p1, p2 and p3
        # O(N) time and O(H) tree height call space

        def rcrs(node) -> int:
            if not node: return 0
            lt = rcrs(node.left)
            rt = rcrs(node.right)
            if node.val == x: self.cnts.extend([lt,rt])
            return lt + rt + 1

        self.cnts = []
        rcrs(root)
        self.cnts.append( n - 1 - sum(self.cnts) )
        return (2*max(self.cnts) - sum(self.cnts)) > 1

    def btreeGameWinningMove1(self, root: TreeNode, n: int, x: int) -> bool:
        # draw tree diagrams to find the pattern
        # for any given node, there are three potential paths away
        # Pa, Pb, Pc == (up, left, right)
        # start from chosen X node, find length of path in directions A,B,C
        # if there exists a value P1 > (P2 + P3 + 1), then guaranteed win
        # or P1 - P2 - P3 > 1
        #    max(all) - (sum(all) - max(all)) > 1
        #    2*max(all) - sum(all) > 1

        # traverse tree from root, create parent dict to allow upward travel
        # then start from chosen X and find P_up, P_left, P_right
        # take the max value from paths, if > other two + 1, return true else false
        # recursive dfs helper function
        # repeat three times with each of x.left, x.right, x.prnt
        # O(N) time and space

        d, self.start = {}, None
        def rcrs_dn(node, prnt) -> None:
            if not node: return
            if node.val == x:
                self.start = node
            d[node] = prnt
            rcrs_dn(node.left, node)
            rcrs_dn(node.right, node)
        rcrs_dn(root, None)

        def dfs_away(node, last) -> int:
            if not node: return 0
            cnt = 1
            if node.left and (node.left is not last):
                cnt += dfs_away(node.left, node)
            if node.right and (node.right is not last):
                cnt += dfs_away(node.right, node)
            if d[node] and (d[node] is not last):
                cnt += dfs_away(d[node], node)
            return cnt

        p1 = dfs_away(self.start.left, self.start)
        p2 = dfs_away(self.start.right, self.start)
        p3 = dfs_away(d[self.start], self.start)

        return ( 2*max(p1, p2, p3) - (p1 + p2 + p3) ) > 1",0
"class Solution:
    def longestDecomposition(self, text: str) -> int:
        import re
        groups = 0
        while True:
            match = re.fullmatch(r'(\w+?).*\1', text)
            if match:
                groups += 2
                subend = match.end(1)
                text = text[subend:-subend]
            else:
                return groups + 1 if text else groups",1
"class Solution:
    
    di = {1:0, 2:31, 3:59, 4:90, 5:120, 6:151, 7:181, 8:212, 9:243, 10:273, 11:304, 12:334}
    
    def dayOfYear(self, date: str) -> int:
        y, m, d = [int(i) for i in date.split(""-"")]
        a = self.di[m] + int(d) 
        if (m > 2) and ((not y % 4) and (y % 100 or not y % 400)): a += 1
        return a",0
"class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        if n == 1:
            if target > k: return 0
            else: return 1
        memo = [0 for t in range(target+1)]
        # Note that we do not use memo[0]
        for i in range(1, target+1):
            if i <= k:
                memo[i] = 1
            else:
                break
                
        for _ in range(1, n):
            tmp = [i for i in memo]
            for t in range(1, target+1):
                memo[t] = 0
                for dice in range(1, k+1):
                    if t - dice > 0:
                        memo[t] += tmp[t-dice]
                memo[t] = int(memo[t] % (1e9+7))
        return int(memo[-1] % (1e9+7))",0
"class Solution:
    def maxRepOpt1(self, text: str) -> int:
        inuse = collections.defaultdict(int)  # chars used in the repeated substring
        left = collections.defaultdict(int)  # not used chars
        MOVE_TO_THE_NEXT_CHAR = 1
        REPLACE = 0
        LEAVE_AS_IT_IS = -1
        res, i, n = 1, 0, 0

        # initially no chars are used yet
        for ch in text:
            left[ch] += 1
        
        for j, ch in enumerate(text):
            inuse[ch] += 1  # since we use this char
            left[ch] -= 1  # subtract its count from left dict
            n = max(inuse[ch], n)
        
            # this defines action we are going to take
            action = j - i - n
        
            char_exists = False
            if action >= MOVE_TO_THE_NEXT_CHAR:
                inuse[text[i]] -= 1
                left[text[i]] += 1  # add it to the left dict back, since it is no longer in use
                i += 1

            # we can replace only if we have unused char in the left dict    
            elif action == REPLACE:
                char_exists = left[ch] > 0 
                
            elif action == LEAVE_AS_IT_IS:
                char_exists = True
        
            if char_exists and j - i >= res:
                res = j - i + 1
        
        return res",0
"class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        
        #vars to hold values
        wordlen = 0
        runningsum = 0
        charedits = chars

        #evaluate words individually
        for word in words:
            wordlen = 0
            charedits = chars

            #Evaluate letters in words
            for letter in word:

                #check the letter in the updating list
                if letter in charedits:
                    wordlen +=1
                    charedits = charedits.replace(letter,' ',1)

            #check word char match
            if len(word) == wordlen:
                runningsum += len(word)

        return(runningsum)",1
"class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        from collections import deque
        if not root: return []
        queue, res = deque([root]), []
        
        while queue:
            cur_level, size = [], len(queue)
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                cur_level.append(node.val)
            res.append(cur_level)
        res = [sum(i) for i in res]
        return res.index(max(res))+1",1
"class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        
        q = collections.deque()
        zeros = 0
        # Get our number of zeros and our 1 starting locations.
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 0:
                    zeros += 1
                if grid[row][col] == 1:
                    q.append((row, col, 0))
        # Two edge cases where we will want to return -1.
        if not q or not zeros:
            return -1
        # Our manhattan distance based movements (d, u, r, l)
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
		# Keep record of the largest encountered distance.
        dist = 0
		# while there are 0's left to move to.
        while zeros and q:
            r, c, d = q.popleft()
			# Try to move in all of our possible directions.
            for y, x in directions:
                nr = y + r
                nc = x + c
				# Make sure the new location is in the grid and is a 0.
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
				    # record the new disr, mark the location as visited and put back into the queue.
                    dist = max(d + 1, dist)
                    zeros -= 1
                    grid[nr][nc] = '#'
                    q.append((nr, nc, d + 1))
                    
        return dist",0
"class Solution:
    def lastSubstring(self, s: str) -> str:
        max_substring = """"
        max_char = """"
        for i in range(len(s)):
            if s[i] >= max_char:
                max_char = s[i]
                max_substring = max(max_substring, s[i : ])
        return max_substring",1
"class Solution:
    def invalidTransactions(self, ts: List[str]) -> List[str]:
        nts = [t.split(',') for t in ts]
        nts = sorted([[a, int(b), int(c), d] for a, b, c, d in nts])
        res = set()
        for a in nts:
            if a[2] > 1000: res.add(','.join(map(str,a)))
        for i in range(len(nts)):
            for j in range(i + 1, len(nts)):
                a, b = nts[i], nts[j]
                if a[0] != b[0] or abs(a[1] - b[1]) > 60: break
                if a[3] != b[3]: 
                    res.add(','.join(map(str,a)))
                    res.add(','.join(map(str,b)))
        return list(res)",0
"class Solution:
    def numreturn(self , inputlist):
        a = sorted(inputlist)
        res = sum([1 for i in a if i==a[0]])
        return res
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        q = [self.numreturn(iq) for iq in queries]
        w = [self.numreturn(iw) for iw in words]
        res = []
        for i in range(len(q)):
            temp = sum([1 for one in w if one>q[i]])
            res.append(temp)
        return res",1
"class Solution:
    def removeZeroSumSublists(self, H: ListNode) -> ListNode:
        A, b = ListNode(0), 1; A.next = H
        while b:
            s, b, D, C = 0, 0, {0:A}, A.next
            while C != None:
                s += C.val
                if s in D:
                    D[s].next, b = C.next, 1
                    break
                else: D[s], C = C, C.next
        return A.next
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        
        def simplesieve(n):
            prime=[]
            mark=[True]*(n+1)
            p=2
            while (p**2 <=n):
                if mark[p]:
                    for i in range(p*p,n+1,p):
                        mark[i]=False
                p+=1
            for i in range(2,n+1):
                if mark[i]:
                    prime.append(i)
            return prime
        
        def segementedsieve(n):
            result=[]
            limit=math.floor(math.sqrt(n))+1
            primes=simplesieve(limit)
            result.extend(primes)
            low=limit
            high=low+limit
            while low<=n:
                if high>=n:
                    high=n
                mark=[True]*(limit+1)
                
                for i in primes:
                    lowlimit=int(math.floor(low/i)*i)
                    if lowlimit<low:
                        lowlimit+=i
                    for j in range(lowlimit,high+1,i):
                        mark[j-low]=False
                for i in range(low,high):
                    if mark[i-low]:
                        result.append(i)
                
                low+=limit
                high+=limit
                
            return result
        
        #print(segementedsieve(n+1))
        number_of_primes_less_than_n=len(segementedsieve(n+1))
        non_prime_number_count=n-number_of_primes_less_than_n
        prime_permutations=math.factorial(number_of_primes_less_than_n)
        non_prime_permutations=math.factorial(non_prime_number_count)
        return (prime_permutations*non_prime_permutations)%(10**9+7)",0
"class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        runningCount = [[0]*26]
        countSnapshot = [0]*26
        a = ord(""a"")
        for c in s:
            countSnapshot[ord(c)-a] += 1
            runningCount.append([*countSnapshot]) # the * is necessary to deep copy the list
        
        for left,right,k in queries:
            if k>=13:
                yield True
                continue
            odds = 0
            for i in range(26):
                odds += (runningCount[right+1][i] - runningCount[left][i])%2
            yield k>=odds//2",0
"class Solution:
    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        freq = defaultdict(int)
        for word in words: 
            mask = 0
            for c in word: mask |= 1 << (ord(c) - 97)
            freq[mask] += 1
            
        ans = []
        for puzzle in puzzles: 
            mask = val = 0 
            for c in puzzle: mask |= 1 << (ord(c) - 97)
            mask0 = mask # loop through sub-masks
            while mask: 
                if mask &amp; (1 << ord(puzzle[0])-97): val += freq[mask]
                mask = mask0 &amp; (mask - 1)
            ans.append(val)
        return ans",0
"class Solution:
    def distanceBetweenBusStops(self, D: List[int], s: int, d: int) -> int:
    	return min(sum(D[min(s,d):max(s,d)]), sum(D)-sum(D[min(s,d):max(s,d)]))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        # The first day of 1971 was Thursday
        week_day = [ ""Thursday"", ""Friday"", ""Saturday"",""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday""]
        no_of_days = 0
        for i in range(1971, year):
            if (i % 400 == 0) or (i % 4 == 0 and i % 100 != 0):
                no_of_days += 366
            else:
                no_of_days += 365

        # If current year is leap year and month is more than February then extra 1 day needs to be added
        if ((year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)):
            if (month > 2):
                no_of_days += 1

        for i in range(1, month):
            no_of_days += months[i]

        no_of_days += day

        return (week_day[(no_of_days % 7)])",0
"class Solution:
    def maximumSum(self, arr: List[int]) -> int:
	    # noDeletions, oneDeletion, max
        nodel = onedel = mx = arr[0]
        
        for i in range(1, len(arr)):
            nodel2 = nodel
            nodel = max(arr[i], arr[i] + nodel)
            onedel = max(arr[i], arr[i] + onedel, max(0, arr[i]) + nodel2)
            mx = max(mx, nodel, onedel)
            
        return mx",1
"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        n1 , n2, dp = len(arr1) , len(arr2) , {}
        arr2.sort()
        
        def solve(i , j , prev):
            
            if i == n1:return 0
            
            if (i,j,prev) in dp: return dp[(i,j,prev)]
            
            k = bisect.bisect_right(arr2[j:],prev) + j
        
            ans = float('inf') if k == n2 else solve(i+1,k+1,arr2[k]) + 1
            
            if arr1[i] > prev:ans = min(ans,solve(i+1 , j ,arr1[i]))
            
            dp[(i,j,prev)] = ans
            
            return ans
        
        
        ans = solve(0,0,-float('inf'))
        
        return ans if ans != float('inf') else -1",0
"class Solution:
    def maxNumberOfBalloons(self, t: str) -> int:
        	return (lambda x: min(x[i]//(1 + (i in 'lo')) for i in 'balon'))(collections.Counter(t))
			
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []
        i = 0
        while i < len(s):
            while i < len(s) and s[i] != "")"":
                stack.append(s[i])
                i += 1
            temp = """"
            if i < len(s) and s[i] == "")"":
                while stack[-1] != ""("":
                    temp += stack.pop()
                i += 1
                stack.pop()
            if temp != """":
                for letter in temp:
                    stack.append(letter)
        return """".join(stack)",0
"class Solution:
    def kConcatenationMaxSum(self, a: List[int], k: int) -> int:
    	L, M, j, m = len(a), 10**9 + 7, 0, 0
    	if min(a) >= 0: return sum(a)*k % M
    	if max(a) <= 0: return 0
    	while j < 2*L:
    		n, i = 0, j
    		for j in range(i,2*L):
    			n, j = n + a[j%L], j + 1
    			if n < 0: break
    			if n > m: m = n
    	return max(m,sum(a)*(k-2)+m) % M
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        graph = [[] for _ in range(n)]
        group = [None] * n

        for n1, n2 in connections:
            graph[n1].append(n2)
            graph[n2].append(n1)

        def dfs(node, parent):
            group[node] = node
            for neighbor in graph[node]:
                if neighbor == parent:
                    continue
                elif group[neighbor] is None:
                    dfs(neighbor, node)
                    if group[neighbor] != neighbor:
                        group[node] = group[neighbor]
                else:
                    if group[neighbor] < group[node]:
                        group[group[node]] = group[neighbor]
                    else:
                        group[group[neighbor]] = group[node]

        def get_root_parent(node):
            if group[node] == node:
                return node
            group[node] = get_root_parent(group[node])
            return group[node]

        dfs(0, 0)

        for i in range(n):
            group[i] = get_root_parent(i)

        return [conn for conn in connections if group[conn[0]] != group[conn[1]]]",0
"class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        
        arr.sort()
        temp = arr[1] - arr[0]
        for i in range(len(arr) - 1):
            temp = min(temp ,arr[i+1] - arr[i] )
        
        res = [[arr[i] , arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == temp]

        return res",1
"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        [a,b,c] = sorted([a,b,c])
        if a == 1: return n
        def lcm(x,y): return x*y//math.gcd(x,y)
        AB, BC, AC, ABC, r, s = lcm(a,b), lcm(b,c), lcm(a,c), lcm(lcm(a,b),c), n*a//3, n*a+1
        def unc(x): return x//a + x//b + x//c - x//AB - x//BC - x//AC + x//ABC
        while unc(s-1) - n > 0:
            m = (r+s)//2
            if unc(m) - n > 0: s = m
            else: r = m
        return max(i*((s-1)//i) for i in [a,b,c])
				
				
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        class UF:
            def __init__(self, n): self.p = list(range(n))
            def union(self, x, y): self.p[self.find(x)] = self.find(y)
            def find(self, x):
                if x != self.p[x]: self.p[x] = self.find(self.p[x])
                return self.p[x]
        uf, res, m = UF(len(s)), [], defaultdict(list)
        for x,y in pairs: 
            uf.union(x,y)
        for i in range(len(s)): 
            m[uf.find(i)].append(s[i])
        for comp_id in m.keys(): 
            m[comp_id].sort(reverse=True)
        for i in range(len(s)): 
            res.append(m[uf.find(i)].pop())
        return ''.join(res)",0
"class Solution:
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        for i in range(n): 
            if group[i] == -1: group[i] = i + m # re-group 
        
        graph0 = {} # digraph of groups 
        indeg0 = [0]*(m+n) # indegree of groups 
        
        graph1 = {} # digrpah of items 
        indeg1 = [0]*n # indegree of items
        
        for i, x in enumerate(beforeItems): 
            for xx in x: 
                if group[xx] != group[i]: 
                    graph0.setdefault(group[xx], []).append(group[i])
                    indeg0[group[i]] += 1
                graph1.setdefault(xx, []).append(i)
                indeg1[i] += 1
        
        def fn(graph, indeg): 
            """"""Return topological sort of graph using Kahn's algo.""""""
            ans = []
            stack = [k for k in range(len(indeg)) if indeg[k] == 0]
            while stack: 
                n = stack.pop()
                ans.append(n)
                for nn in graph.get(n, []):
                    indeg[nn] -= 1
                    if indeg[nn] == 0: stack.append(nn)
            return ans 
        
        tp0 = fn(graph0, indeg0) 
        if len(tp0) != len(indeg0): return [] 
        
        tp1 = fn(graph1, indeg1)
        if len(tp1) != len(indeg1): return []
        
        mp0 = {x: i for i, x in enumerate(tp0)}
        mp1 = {x: i for i, x in enumerate(tp1)}
        
        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))",0
"class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        freq = {}
        for x in arr: 
            freq[x] = 1 + freq.get(x, 0)
        return len(freq) == len(set(freq.values()))",1
"class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        
        window = collections.deque([])
        best = 0
        i = 0
        
        while i < len(s):
            
            cost = abs(ord(s[i]) - ord(t[i]))
            
            if maxCost - cost >= 0:
                window.append(cost)
                maxCost -= cost
                best = max(best, len(window))
                i += 1
                continue
            
            if len(window) > 0:
                maxCost += window.popleft()
                continue
                
            i += 1
                
        return best",1
"class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for c in s: 
            if stack and stack[-1][0] == c: 
                stack[-1][1] += 1
            else: stack.append([c, 1])
            if stack[-1][1] == k: stack.pop()
        return """".join(x*c for x, c in stack)",1
"class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        def findNeighbors(head, state):
            actual = []
            x, y = head
            if state == 'H':
                # go right when horizontal
                if y + 1 <= n - 1 and grid[x][y + 1] == 0:
                    actual.append((x, y + 1, 'H'))
                    
                # go down when horizontal
                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:
                    actual.append((x + 1, y, 'H'))
                    
                    # can rotate clkwise here
                    actual.append((x + 1, y - 1, 'V'))
                    
            else:
                # go down when vertical
                if x + 1 <= n - 1 and grid[x + 1][y] == 0:
                    actual.append((x + 1, y, 'V'))
                    
                # go right when vertical
                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:
                    actual.append((x, y + 1, 'V'))
                    
                    # can rotate anti clkwise here
                    actual.append((x - 1, y + 1, 'H'))
                    
            return actual
        
        visited = set()
        q = deque()
        q.append((0, 1, 'H', 0))
        
        while q:
            x, y, state, dist = q.popleft()
            if (x, y, state) == (n - 1, n - 1, 'H'):
                return dist
            
            if (x, y, state) in visited:
                continue
                
            visited.add((x, y, state))
            
            for nx, ny, ndir in findNeighbors((x, y), state):
                q.append((nx, ny, ndir, dist + 1))
                
        return -1",0
"class Solution:
    def minCostToMoveChips(self, C: List[int]) -> int:
        return min(sum(c % 2 for c in C), len(C) - sum(c % 2 for c in C))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def longestSubsequence(self, A: List[int], k: int) -> int:
        D, C = {}, {}
        for a in A:
            if a not in D: D[a], C[a+k] = 1, a
            if a in C: C[a+k], D[C.pop(a)] = C[a], D[C[a]] + 1
        return max(D.values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",1
"class Solution:
    def getMaximumGold(self, G: List[List[int]]) -> int:
        M, N, V, m = len(G), len(G[0]), set(), [0]
        def dfs(i, j, t):
            V.add((i,j))
            for k,l in (i-1,j),(i,j+1),(i+1,j),(i,j-1):
                if 0 <= k < M and 0 <= l < N and G[k][l] and (k,l) not in V: dfs(k, l, t + G[k][l])
            m[0], _ = max(m[0], t), V.remove((i,j))
        for i,j in itertools.product(range(M),range(N)):
            if G[i][j]: dfs(i, j, G[i][j])
        return m[0]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",0
"class Solution:
    def countVowelPermutation(self, n: int) -> int:
        a, e, i, o, u, MOD = 1, 1, 1, 1, 1, 10**9+7
        for _ in range(n-1):
            a, e, i, o, u = e, (a+i)%MOD, (a+e+o+u)%MOD, (i+u)%MOD, a
        return sum([a, e, i, o, u])%MOD",0
"class Solution:
    def balancedStringSplit(self, s: str) -> int:
        stk = []
        ret = 0

        for ch in s:
            if not stk:             # begin
                ret += 1            # in balance
                stk.append(ch)
            elif ch == stk[-1]:     # continue
                stk.append(ch)
            else:                   # change direction
                stk.pop()
        return ret",1
"class Solution:
    def dieSimulator(self, n: int, R: List[int]) -> int:
        D, R, S, m = [[0]*7 for _ in range(n)], [0]+R, set(range(1,7)), 10**9 + 7
        def dfs(L, d):
            if L >= n: return 1 if L == n else 0
            c = 0
            if D[L][d]: return D[L][d]
            for i in S-{d}:
                for j in range(1,R[i]+1): c += dfs(L+j,i)
            D[L][d] = c
            return c
        return dfs(0,0) % m
		
		
- Junaid Mansuri",0
"class Solution:
    def maxEqualFreq(self, N: List[int]) -> int:
        L, C = len(N), collections.Counter(N)
        for i in range(L-1,-1,-1):
            S = set(C.values())
            if len(C.values()) == 1 or S == {1}: return i + 1
            elif len(S) == 2:
                if 1 in S and list(C.values()).count(1) == 1: return i + 1
                if list(C.values()).count(max(S)) == 1 and max(S) - min(S) == 1: return i + 1
            if C[N[i]] == 1: del C[N[i]]
            else: C[N[i]] -= 1
        return 0
		
		
- Junaid Mansuri",0
"class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 1/2",1
"class Solution:
    def checkStraightLine(self, C: List[List[int]]) -> bool:
        if len(set(i[0] for i in C)) == 1: return True
        if len(set(i[0] for i in C)) < len(C): return False
        m, [x1, y1] = (C[1][1]-C[0][1])//(C[1][0]-C[0][0]), C.pop(0)
        for x,y in C:
            if (y-y1)/(x-x1) != m: return False
        return True
		
		
- Junaid Mansuri",1
"class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort(key=len, reverse=False)         # shorter ones in the front
        result = []
        
        while folder != []:
            curr = folder.pop(0)
            result.append(curr)
            tmp = copy.deepcopy(folder)
            for i in tmp:
                if (curr+""/"") in i:
                    folder.remove(i)
            # print(result)
        
        return result",1
"class Solution:
    def balancedString(self, S: str) -> int:
        L, m, D, c, i, j = len(S), len(S), {k:v-len(S)//4 for k,v in collections.Counter(S).items() if v>len(S)//4}, {k:0 for k in 'QWER'}, -1, 0
        if not D: return 0
        for j, s in enumerate(S):
            while i < L - 1 and any(c[k] < D[k] for k in D): i += 1; c[S[i]] += 1
            if i == L - 1 and any(c[k] < D[k] for k in D): break
            m = min(m, i - j + 1); c[s] -= 1
        return m
		
		
- Junaid Mansuri",0
"class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        start = min(startTime)
        end = max(endTime)
        n = len(startTime)
        newList = [[startTime[i]-start+1, endTime[i]-start+1, profit[i]] for i in range(n)]
        newList.sort(key = lambda x : x[1])
        n = len(newList)
        dp = [0]*(n + 1)
        for i in range(n):
            [starti, endi, costi] = newList[i]
            j = i-1
            while j >= 0 and newList[j][1] > starti:
                j-=1
            dp[i+1] = max(dp[j+1]+costi,dp[i+1], dp[i])

        return dp[-1]",0
"class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        result =[]
        for x in range(1,z+1):
            l,h=1,z
            while(l<=h):
                m=(l+h)//2
                if (customfunction.f(x,m)==z):
                    result.append([x,m])
                    break;
                elif (customfunction.f(x,m)<z):
                    l=m+1
                elif (customfunction.f(x,m)>z):
                    h=m-1
        return result",0
"class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:
        # gray code generation! for every new ""bit"":
        # 1) preface reversed list with 1 == same as adding 2^(N-1)
        # 2) squish onto existing list

        # (N)  1   2    3   gray
        #      0  00  000   0
        #      1  01  001   1
        #         11  011   2
        #         10  010   3
        #             110   4
        #             111   5
        #             101   6
        #             100   7

        # then find start position (ambiguously NOT gray representation)
        # slice and dice the created list with ""start"" at index 0

        # O(2^N) time, O(2^N) space

        gc, bit = [0, 1], 1
        while bit < n:
            bit += 1

            next_vals = []
            for val in reversed(gc):
                next_vals.append( val + 2**(bit-1) )
            gc.extend(next_vals)

        ind = gc.index(start)
        return gc[ind:] + gc[:ind]",1
"class Solution:
    def maxLength(self, arr: List[str]) -> int:
        ans = 0
        freq = [0]*26 
        
        def fn(i): 
            """"""Return max length of arr[i:] given freq.""""""
            if i == len(arr): return 0 
            ans = fn(i+1) # skipping arr[i]
            if len(set(arr[i])) == len(arr[i]): 
                if all(freq[ord(c)-97] == 0 for c in arr[i]): 
                    for c in arr[i]: freq[ord(c)-97] += 1
                    ans = max(ans, len(arr[i]) + fn(i+1))
                    for c in arr[i]: freq[ord(c)-97] -= 1 # backtracking 
            return ans 
        
        return fn(0)",0
"class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        # edge case 1 allowing early quit processing. 
        if n == m : 
            return 1 
        # edge case 2, occurs according to tiling problem. Only one for which implementation breaks. 
        elif (n==11 and m == 13) or (n==13 and m==11) : 
            return 6 
        else : 
            # memo usage of results. Build from result 1 go to end result. Bottom up progression. 
            memo = [[0 for _ in range(m+1)] for _ in range(n+1)]
            # loop from 1 to n inclusive 
            for n_measure in range(1, n+1) : 
                # loop 1 to m inclusive 
                for m_measure in range(1, m+1) : 
                    # if we are at equal measures, this is a square 
                    if (n_measure == m_measure) : 
                        # mark it as 1 as these are our measures so this can be covered by equal square 
                        memo[n_measure][m_measure] = 1
                        continue
                    # only do half the array 
                    else : 
                        if m_measure < n and n_measure < m and memo[m_measure][n_measure] != 0 : 
                            memo[n_measure][m_measure] = memo[m_measure][n_measure]
                            continue
                    # otherwise, set sub rectangles 1 and 2 and minimal rectangle to infinity to start 
                    sub_rectangle1, sub_rectangle2, min_rectangle = inf, inf, inf
                    offset = 1 
                    # starting with offset of 1 go to min of n and m 
                    while offset <= min(n_measure, m_measure) : 
                        # if we have run off the smaller, break at this point 
                        if (m_measure - offset < 0) or (n_measure - offset < 0) : 
                            break
                        # get sub rectangles 1 and 2 based off of which slicing you're doing 
                        sub_rectangle1 = memo[n_measure][m_measure-offset] + memo[n_measure-offset][offset]
                        sub_rectangle2 = memo[n_measure-offset][m_measure] + memo[offset][m_measure-offset]
                        # set min to minimum of the results now built 
                        min_rectangle = min(min_rectangle, sub_rectangle1, sub_rectangle2)
                        # increment offset as if you are doing two different measures simultaneously 
                        offset += 1 
                    # memoize current result minmal plus 1 more for work done for this square itself. 
                    memo[n_measure][m_measure] = min_rectangle + 1
            return memo[n][m]",0
"class Solution:
    def minimumSwap(self, S: str, T: str) -> int:
        L, D = len(S), {'x': 1, 'y': 1}
        for i in range(L): D[S[i]] += S[i] != T[i]
        return -1 if (D['x']+D['y']) % 2 else D['x']//2 + D['y']//2
		
		
- Junaid Mansuri",1
"class Solution:
def numberOfSubarrays(self, nums: List[int], k: int) -> int:
    
    res,left,end=0,0,0
    n=len(nums)
    dic = defaultdict(int)
    while (end<n):
        dic[nums[end]%2]+=1
        if dic[1]==k:
            re = 0              # count of even numbers right side of limit (k no. of odds)
            while end+1<n and nums[end+1]%2==0:
                re+=1
                end+=1
                dic[0]+=1
            
            le = 0
            while dic[1]==k:
                le+=1
                dic[nums[left]%2]-=1
                left+=1
            
            if re:
                res += le*(re+1)
            else:
                res += le
                
        end+=1
        
    return res",0
"class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        s,temp = list(s), []
        for i in range(len(s)):
            if s[i] in [""("","")""]:
                if not temp: temp.append((i,s[i]))
                elif temp[-1][-1]==""("" and s[i] == "")"": temp.pop()
                else: temp.append((i,s[i]))
        for item in temp: s[item[0]] = None
        res = """"
        for char in s:
            if char is not None: res += char
        return res",0
"class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        
        from functools import reduce
        def gcd (a,b):
            while b:
                a, b = b, a%b
            return a
        
        from math import gcd
        
        if reduce(gcd, nums) == 1:
            return True
        else:
            return False",1
"class Solution:
    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:
        row = set()
        col = set()
        ans = 0
        for i, j in indices:
            diff = m - 2 * len(col)
            ans += diff * (-1) ** (i in row) 
            row ^= {i}
            diff = n - 2 * len(row)
            ans += diff * (-1) ** (j in col) 
            col ^= {j}
        return ans",1
"class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        cnt = sum(x==2 for x in colsum)
        if upper + lower != sum(colsum) or cnt > upper or cnt > lower : return [] #sanity check 
        
        ans = [[0]*len(colsum) for _ in range(2)]
        for i, c in enumerate(colsum): 
            if c == 2: ans[0][i] = ans[1][i] = 1
            elif c == 1:
                if cnt < upper: #there is capacity in upper
                    ans[0][i] = 1 
                    cnt += 1
                else: ans[1][i] = 1
        return ans",0
"class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        m=len(grid)
        n=len(grid[0])
        ans=0
		#replacing all 0's to -1
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    grid[i][j]=-1
		#reconverting -1's at boundaries and -1's connected with -1's at boundary to 0
        for i in range(m):
            for j in range(n):
                if (i==0 or i==m-1 or j==0 or j==n-1) and grid[i][j]==-1:
                    self.dfs(i,j,grid,m,n)
		#checking for number of closed island.
        for i in range(m):
            for j in range(n):
                if grid[i][j]==-1:
                    ans+=1
                    self.dfs(i,j,grid,m,n)
        return ans
    def dfs(self,row,col,grid,m,n):
        grid[row][col]=0
        if row-1>=0 and grid[row-1][col]==-1:
            self.dfs(row-1,col,grid,m,n)
        if row+1<m and grid[row+1][col]==-1:
            self.dfs(row+1,col,grid,m,n)
        if col-1>=0 and grid[row][col-1]==-1:
            self.dfs(row,col-1,grid,m,n)
        if col+1<n and grid[row][col+1]==-1:
            self.dfs(row,col+1,grid,m,n)
        return",0
"class Solution:
    def maxScoreWords(self, W: List[str], T: List[str], S: List[int]) -> int:
        L, CT, D, SL, X, M = len(W), collections.Counter(T), {a:S[i] for i,a in enumerate(string.ascii_lowercase)}, set(''.join(W)), set(), 0
        for n in range(1,L+1):
            for wc in itertools.combinations(range(L),n):
                if any(wc[:i] in X for i in range(1,len(wc)+1)): continue
                CC = collections.Counter(''.join([W[i] for i in wc]))
                if any(CT[c] < CC[c] for c in SL): X.add(wc)
                else: M = max(M,sum(D[i]*CC[i] for i in CC))
        return M
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp = []
        for i in range(3):
            z = []
            for j in range(len(nums)):
                z.append(0)
            dp.append(z)
        dp[nums[0]%3][0] = nums[0]
        for i in range(1,len(nums)):
            for j in range(3):
                x = dp[j][i-1] + nums[i]
                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])
                dp[j][i] = max(dp[j][i-1],dp[j][i])
        return dp[0][-1]",1
"class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        # dfs to move person
        # bfs to move box
        m = len(grid)
        n = len(grid[0])
        dirc = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        si, sj, bi, bj, tari, tarj = -1, -1, -1, -1, -1, -1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == ""S"":
                    si, sj = i, j
                if grid[i][j] == ""B"":
                    bi, bj = i, j
                if grid[i][j] == ""T"":
                    tari, tarj = i, j
        
        def ok(i, j, bi=-1, bj=-1):
            if i < 0 or j < 0 or i >= m or j >= n:
                return False
            if grid[i][j] == ""#"" or (i == bi and j == bj):
                return False
            return True
        
        def p_reachable(si, sj, ti, tj, bi, bj):
            if not ok(ti, tj, bi, bj):
                return False
            vis = set()
            def dfs(i, j):
                vis.add((i, j))
                if i == ti and j == tj:
                    return True
                flag = False
                for d in dirc:
                    newi, newj = i + d[0], j + d[1]
                    if ok(newi, newj, bi, bj) and (newi, newj) not in vis:
                        flag = flag or dfs(newi, newj)
                return flag
            return dfs(si, sj)
        
        queue = deque()
        queue.append(((bi, bj), (si, sj)))
        bvis = set()
        cnt = 0
        while queue:
            l = len(queue)
            for i in range(l):
                cur = queue.popleft()
                if cur[0][0] == tari and cur[0][1] == tarj:
                    return cnt
                for d in dirc:
                    newbi = cur[0][0] + d[0]
                    newsi = cur[0][0] - d[0]
                    newbj = cur[0][1] + d[1]
                    newsj = cur[0][1] - d[1]
                    if ok(newbi, newbj) and ((newbi, newbj), (cur[0][0], cur[0][1])) not in bvis and p_reachable(cur[1][0], cur[1][1], newsi, newsj, cur[0][0], cur[0][1]):
                        queue.append(((newbi, newbj), (cur[0][0], cur[0][1])))
                        bvis.add(((newbi, newbj), (cur[0][0], cur[0][1])))
            cnt += 1
        return -1",0
"class Solution:
    def minTimeToVisitAllPoints(self, P: List[List[int]]) -> int:
        L, t = len(P), 0
        for i in range(L-1):
            (a,b), (c,d) = P[i], P[i+1]
            t += max(abs(a-c),abs(b-d))
        return t
		
		
- Junaid Mansuri",1
"class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        R = len(grid)
        C = len(grid[0])        
        visited = set()
        
        def neighbours(r, c, grid):
            nei = set()
            for i in range(C):
                nei.add((r,i))
            for j in range(R):
                nei.add((j,c))
            nei.discard((r,c))
            return nei
                    
        def dfs(grid,i,j, visited):
            for nei in neighbours(i,j, grid):
                x, y = nei
                if nei not in visited and grid[x][y] == 1:
                    visited.add(nei)
        
        for i, row in enumerate(grid):
            for j, val in enumerate(row):
                if val == 1:
                    dfs(grid, i, j, visited)
        
        return len(visited)",0
"class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        ans = []
        n = len(products)
        now = products
        
        #iterate through length of searchWord
        for i in range(len(searchWord)):
            temp = []
            
            #iterate through length of current list
            for j in range(len(now)):
                
                #check if there are enough characters 
                if len(now[j])>= i and searchWord[:i+1] == now[j][:i+1]:
                    temp.append(now[j])
            
            #top 3 words hence sort
            temp.sort()
            
            if len(temp)>3:
                ans.append(temp[:3])
            else:
                ans.append(temp)
            now = temp
            
        return ans",1
"class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        n = min(arrLen, steps//2+1) #reachable right end
        ways = [1] + [0]*(n-1)
        for step in range(steps): 
            ways = [sum(ways[max(0,i-1):i+2]) % (10**9+7) for i in range(min(step+2,steps-step,n))]
        return ways[0]",0
"class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        class Score:
            def __init__(self):
                self.rows = [0 for i in range(3)]
                self.cols = [0 for i in range(3)]
                self.diag = 0
                self.adiag = 0
        A = Score()
        B = Score()
        for i, (x,y) in enumerate(moves):
            player = B if (i % 2) else A
            player.rows[x] += 1
            player.cols[y] += 1
            if (x == y):
                player.diag += 1
            if (x + y == 2):
                player.adiag += 1
                
            if 3 in A.rows or 3 in A.cols or A.diag == 3 or A.adiag == 3:
                return ""A""
            if 3 in B.rows or 3 in B.cols or B.diag == 3 or B.adiag == 3:
                return ""B""
            
        if len(moves) == 9:
            return ""Draw""
        else:
            return ""Pending""",0
"class Solution:
    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:
        if tomatoSlices &amp; 1 or not (2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices): return []
        return [(tomatoSlices - 2*cheeseSlices)//2, (4*cheeseSlices - tomatoSlices)//2]",0
"class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        total = 0
        dp = [[0] * len(row) for row in matrix]
        for i, row in enumerate(matrix):
            for j, num in enumerate(row):
                if not num:
                    continue
                upper = 0
                if i-1 >= 0:
                    upper = dp[i-1][j]
                left = 0
                if j-1 >= 0:
                    left = dp[i][j-1]
                diag = 0
                if i-1 >= 0 and j-1 >= 0:  # Can this be made less redundant?
                    diag = dp[i-1][j-1]
                dp[i][j] = min(upper, left, diag) + 1
                total += dp[i][j]
        return total",0
"class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        
        n = len(s)
        
        def getChanges(i, j):
            ret = 0
            while i < j:
                if s[i] != s[j]:
                    ret += 1
                i += 1
                j -= 1
            return ret
        
        cost = [[getChanges(i, j) for j in range(n)] for i in range(n)]

        @cache
        def res(l = 0, r = 0, k = k):
            if l == len(s) and r == len(s) and k == 0:
                return 0
            elif r == len(s) or k <= 0:
                return math.inf
            else:
                return min(cost[l][r] + res(r + 1, r + 1, k - 1), res(l, r +1, k))
        
        return res()",0
"class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        digit_prod = 1
        digit_sum = 0
        for i in range(len(str(n))):
            digit_prod *= int(str(n)[i]) 
            digit_sum += int(str(n)[i])
        return digit_prod - digit_sum",1
"class Solution:
    def groupThePeople(self, G: List[int]) -> List[List[int]]:
        S, D = set(G), collections.defaultdict(list)
        for i, g in enumerate(G): D[g].append(i)
        return [D[i][i*j:i*(j+1)] for i in S for j in range(G.count(i)//i)]
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def smallestDivisor(self, N: List[int], t: int) -> int:
        N.sort(); a, b, ceil = 1, N[-1], math.ceil
        while a < b:
            m = (a+b)//2
            if sum(ceil(n/m) for n in N) > t: a = m + 1
            else: b = m
        return a",1
"class Solution:
    def minFlips(self, G: List[List[int]]) -> int:
        M, N = len(G), len(G[0])
        P = [(i,j) for i,j in itertools.product(range(M),range(N))]
        for n in range(M*N+1):
            for p in itertools.permutations(P,n):
                H = list(map(list,G))
                for (x,y) in p:
                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):
                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]
                if max(max(H)) == 0: return n
        return -1
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        larr = len(arr)
        
        if larr == 0:
            return None
        
        v = len(arr)*.25
        
        prev = None
        ct = 0
        for e in arr:
            if e == prev:
                ct += 1
            else:
                ct = 1
            prev = e
            if ct > v:
                return e
        return None",1
"class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for _, y in sorted(intervals, key=lambda x: (x[0], -x[1])): 
            if y > prev: ans, prev = ans+1, y
        return ans",0
"class Solution:
    def minFallingPathSum(self, arr: List[List[int]]) -> int:
        if not arr or not arr[0]:
            return 0
        m, n = len(arr), len(arr[0])
        if n == 1:
            return arr[0][0] if m == 1 else 0
        dp = [[-1, 0], [-1, 0]]
        for i in range(m):
            min1, min2 = [[-1, float(""inf"")], [-1, float(""inf"")]]
            for j in range(n):
                min_idx = 0 if dp[0][0] != j else 1
                cur_val = dp[min_idx][1] + arr[i][j]
                if cur_val < min1[1]:
                    min1, min2 = [j, cur_val], min1
                elif cur_val < min2[1]:
                    min2 = [j, cur_val]
            dp = [min1, min2]
        return dp[0][1]",0
"class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        decn = 0
        while head:
            decn = decn*2 + head.val
            head = head.next
        
        return decn",1
"class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        def recur(number, ans):
            intNum = int(number)
            if intNum >= low and intNum <= high:  ans.append(intNum)
            if number[-1] != '9':                 recur( number + str( int(number[-1])+1 ), ans)
        ans =  []
        for i in range(1, 9): recur(str(i), ans)
        ans.sort()
        return ans",0
"class Solution:
    def maxSideLength(self, G: List[List[int]], t: int) -> int:
        M, N, m = len(G), len(G[0]), 0; S = [[0]*(N+1) for _ in range(M+1)]
        S[1] = list(itertools.accumulate([0]+G[0]))
        for i in range(1,M):
            s = list(itertools.accumulate(G[i]))
            for j in range(N): S[i+1][j+1] = s[j] + S[i][j+1]
        for i,j in itertools.product(range(M),range(N)):
            for L in range(m+1, min(M-i+1,N-j+1)):
                if S[i+L][j+L]-S[i][j+L]-S[i+L][j]+S[i][j] <= t: m = max(m,L)
                else: break
        return m
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def shortestPath(self, G: List[List[int]], k: int) -> int:
        M, N, P, Q, D, L = len(G)-1, len(G[0])-1, [(0,0,0)], [], {}, 0
        if k >= M+N: return M+N
        while P:
            for (x,y,s) in P:
                if (x,y) == (M,N): return L
                for i,j in (x-1,y),(x,y+1),(x+1,y),(x,y-1):
                    if 0<=i<=M and 0<=j<=N:
                        t = s + G[i][j]
                        if t <= k and D.get((i,j),math.inf) > t: D[(i,j)], _ = t, Q.append((i,j,t))
            P, Q, L = Q, [], L + 1
        return -1
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution(object):
    def findNumbers(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        #iniializing the counter
        counter = 0
        for i in nums:
            #counting the digits in the number
            count = 0
            while (i > 0):
                i = i//10
                count = count + 1
            #checking wether the count is even or odd
            if count % 2 == 0:
                counter +=1
        return counter",1
"class Solution:
    def isPossibleDivide(self, N: List[int], k: int) -> bool:
        L, C = len(N), collections.Counter(N)
        for i in range(L//k):
            m = min(C.keys())
            for j in range(m,m+k):
                if C[j] > 1: C[j] -= 1
                else: del C[j]
        return not (C or L % k)
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def maxFreq(self, s: str, M: int, m: int, _: int) -> int:
        L, D = len(s), collections.defaultdict(int)
        for j in range(L+1-m): D[s[j:j+m]] += (len(set(s[j:j+m])) <= M)
        return max(D.values())
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def maxCandies(self, S: List[int], C: List[int], K: List[List[int]], CB: List[List[int]], I: List[int]) -> int:
        t, I, S, B = 0, set(I), set([i for i,v in enumerate(S) if v]), 1
        while B:
            B = 0
            for b in I &amp; S: t, I, S, B = t + C[b], I.union(set(CB[b]))-{b}, S.union(set(K[b])), 1
        return t
            
            
            
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def replaceElements(self, arr: List[int]) -> List[int]:
        res = [-1]
        for i in range(len(arr)-1, 0, -1):
            res.append(max(res[-1], arr[i]))
        return res[::-1]",1
"class Solution:
    def solve(self,arr,k):    # returns the sum of arr , when replaced with k by fallowing 
                                # the given conditions  
        i=0
        while i<len(arr):
            if arr[i]>k:
                break
            i=i+1
            
        d=len(arr)-i
        d=d*k
        d=d+sum(arr[:i])
        return d
    
    def findBestValue(self, arr: List[int], target: int) -> int:
        end=max(arr)
        start=1
        x=0
        res=0
        rx=0
        arr.sort()
        while start<=end:
            mid=start+(end-start)//2
            a=list(arr)
            x=self.solve(a,mid) 
            
            if x<target:
                start=mid+1
            else:
                end=mid-1
                
            if abs(rx-target)>abs(target-x):
                rx=x                             
                res=mid
            elif abs(rx-target)==abs(target-x):
                res=min(res,mid)
                rx=min(rx,x)
                
        return res
    
    #rx is the sum of previous minimum number replaced in the array
    # mid is the number we are storing in the res  which is the number we are replacing in the array
    # every time we store sum of arr and mid  (mid is the number we are replacing in the arr  to get that sum)  considering the minimum",0
"class Solution:
    def pathsWithMaxScore(self, B: List[str]) -> List[int]:
        L, D, B[-1], m = len(B), {(0,0):(0,1)}, B[-1][:-1]+'0', 10**9 + 7
        def dfs(i,j):
            if (i,j) in D: return D[(i,j)]
            if i < 0 or j < 0 or B[i][j] == ""X"": return (0,0)
            SP = [dfs(x,y) for x,y in [(i-1,j),(i,j-1),(i-1,j-1)]]
            S = max(SP[i][0] for i in range(3))
            D[(i,j)] = (int(B[i][j]) + S, sum(y for x,y in SP if x == S))
            return D[(i,j)]
        (MS,MP) = dfs(L-1,L-1)
        return [[MS,0][MP == 0], MP % m]
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        
        queue = deque()
        queue.append(root)
        
        res = []
        while queue:
            temp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(temp)
    
        return sum(res[-1])",1
"class Solution:
    def sumZero(self, n: int) -> List[int]:
        l = []
        if n % 2 == 0:
            for i in range(1, n//2 + 1):
                l.append(i * 2)
                l.append(-i * 2)
        else:
            for i in range(-n//2 + 1, n//2 + 1):
                l.append(i)
        return l",1
"class Solution:
    
    def __init__(self):
        self.l1 = []
        self.l2 = []
    
    def inOrder(self,root, s):
        if root == None:
            return
        self.inOrder(root.left, s)
        s.append(root.val)
        self.inOrder(root.right, s)
    
    
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        self.inOrder(root1, self.l1)
        self.inOrder(root2, self.l2)
        l = self.l1 + self.l2 
        l.sort()
        return l",1
"class Solution:
    def canReach(self, A: List[int], S: int) -> bool:
        L, V, C = len(A), set(), collections.deque([S])
        while C:
            _, i = V.update(C), C.popleft()
            if A[i] == 0: return True
            if i-A[i] >=0 and i-A[i] not in V: C.append(i-A[i])
            if i+A[i] < L and i+A[i] not in V: C.append(i+A[i])
        return False
        

- Junaid MAnsuri
- Chicago, IL",1
"class Solution:
    def isSolvable(self, W: List[str], R: str) -> bool:
        LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}
        if LR < ML: return False
        def dfs(d,i,c):
            if d == ML: return c == 0
            if i == len(W) + 1:
                s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c
                return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False
            if i < LW and d >= len(W[i]): return dfs(d,i+1,c)
            ch = AW[i][-d-1]
            if ch in LMap: return dfs(d,i+1,c)
            for x in range((ch in F), 10):
                if x not in V:
                    LMap[ch], _ = x, V.add(x)
                    if dfs(d,i+1,c): return True
                    V.remove(LMap.pop(ch))
        return dfs(0,0,0)
		
		
- Junaid Mansuri
- Chicago, IL",0
"class Solution:
    def freqAlphabets(self, s: str) -> str:
        x = ''
        i = len(s)-1
        while i > -1:
            if s[i] == '#':
                if int(s[i-2:i])%26 == 0:
                    x = chr(96+26) + x
                else:
                    x = chr(96 + int(s[i-2:i])%26) + x
                i -= 3
            else:
                x = chr(96 + int(s[i])%26) + x
                i -= 1
        return x",1
"class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        graph = collections.defaultdict(list)
        for u, v in enumerate(friends):
            for i in v:
                graph[u].append(i)
        queue = collections.deque()
        queue.append((id, 0))
        visited = set()
        visited.add(id)
        res = collections.defaultdict(int)
        while queue:
            id, l = queue.popleft()
            if l == level:
                for j in watchedVideos[id]:
                    res[j] += 1
            for v in graph[id]:
                if l+1 <= level and v not in visited:
                    visited.add(v)
                    queue.append((v, l+1))
        from functools import cmp_to_key
        def func(x, y):
            if res[x] > res[y]:
                return -1
            elif res[y] > res[x]:
                return 1
            else:
                if x > y:
                    return -1
                elif y > x:
                    return 1
                else:
                    return 0
        return (sorted(res.keys(), key=cmp_to_key(func)))[::-1]",0
"class Solution:
    def minInsertions(self, s: str) -> int:
        n = len(s)
        dp = [[0 for i in range(n)] for j in range(n)]
        
        r=0
        c=1
        
        while c<n:
            ci = c
            r = 0
            
            while ci<n and r<n:
                if s[ci] == s[r]:
                    dp[r][ci] = dp[r+1][ci-1]
                else:
                    dp[r][ci] = 1+min(dp[r+1][ci],dp[r][ci-1])
                ci+=1
                r+=1
            c+=1
        return dp[0][n-1]",1
"class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        k = 0
        arr = []
        while k < len(nums):
            freq = nums[k]
            val = nums[k+1]
            for i in range(freq):
                arr.append(val)
            k += 2
            
        return arr",1
"class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        if not root: return 0 #edge case 
        ans = 0
        #preorder dfs
        stack = [(root, None, None)] #node-parent-grandparent
        while stack: 
            node, parent, grand = stack.pop()
            if grand and grand &amp; 1 == 0: ans += node.val #even-valued grandparent 
            if node.left: stack.append((node.left, node.val, parent))
            if node.right: stack.append((node.right, node.val, parent))
        return ans",0
"class Solution:
    def distinctEchoSubstrings(self, text: str) -> int:
        ans = set()
        
        for i in range(len(text)-1): 
            for j in range(i+1, (i+len(text))//2+1): 
                if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])
        
        return len(ans)",1
"class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        if n<10:
            return [1,n-1]
        a = int(str(n)[1:])+1
        a = int(''.join(['1' if i == '0' else i for i in str(a)]))
        return [a,n-a]",1
"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        a = bin(a)[2:]
        b = bin(b)[2:]
        c = bin(c)[2:]
        x = max([len(a),len(b),len(c)])
        a = a.zfill(x)
        b = b.zfill(x)
        c = c.zfill(x)
        count = 0
        for i in range(x-1,-1,-1):
            if int(c[i]) != (int(a[i]) or int(b[i])):
                if c[i] == '0':
                    if a[i] == '1':
                        count += 1
                    if b[i] == '1':
                        count += 1
                else:
                    count += 1
        return count",0
"class Solution:
    def minimumDistance(self, word: str) -> int:
        word = [ord(x)-65 for x in word]
        dist = lambda x, y: 0 if -1 in (x, y) else abs(x//6 - y//6) + abs(x%6 - y%6) # l1 distance
        
        @cache
        def fn(i, f1=-1, f2=-1):
            """"""Return minimum distance of typing word[i:] with 2 fingers.""""""
            if i == len(word): return 0 
            return min(dist(word[i], f1) + fn(i+1, word[i], f2), dist(word[i], f2) + fn(i+1, f1, word[i]))
        
        return fn(0)",0
"class Solution:
    def maximum69Number (self, num: int) -> int:

        lst_num = list(str(num))

        for i in range(len(lst_num)):
            if lst_num[i] == '6':
                lst_num[i] = '9'
                break
        return int(''.join(lst_num))",1
"class Solution:
    def printVertically(self, s: str) -> List[str]:
        M = max(map(len,s.split()))
        return [''.join(v).rstrip() for v in map(''.join,zip(*[s+' '*(M-len(s)) for s in s.split()]))]
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:
    
        def helper(node):
            if node:    
                node.left = helper(node.left)
                node.right = helper(node.right)

                if not node.left and not node.right and node.val == target:
                    return None
                else:
                    return node
        
        return helper(root)",1
"class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        intervals = [(0, ranges[0])]
        for i in range(1, n + 1):
            l, r = max(i - ranges[i], 0), i + ranges[i]
            if intervals[-1][1] < r:
                while intervals and intervals[-1][0] >= l:
                    intervals.pop()
                if not intervals:
                    intervals.append((l, r))
                elif intervals[-1][1] < n and l <= intervals[-1][1]:
                    intervals.append((intervals[-1][1], r))
		return len(intervals) if intervals[-1][1] >= n else -1",0
"class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        # there is no way to replace a single character to make ""a"" not a palindrome
        # because no matter what we change, it is still a palindrome
        if n == 1:
            return ''
        # let's think about n = 2 case, e.g. ""bb""
        # in this case, to acheive the lexicographically smallest one
        # we should replace from the left and the best character to use is ""a""
        # for ""bb"", we replace the first ""b"" to ""a"" to become ""ab""
        
        # let's think about another n = 2 case, e.g. ""aa""
        # in this case, to acheive the lexicographically smallest one
        # we should replace from the left and the best character to use is ""a""
        # however, for ""aa"", we cannot use ""a"" here and the best character to use is ""b"" now
        # for ""aa"", we replace the second ""a"" to ""b"" to become ""ab""
        # why not replace the first ""a""? because ""ba"" is not smallest.
        for i in range(n // 2):
            #  here we know that as long as palindrome[i] is not ""a"", we skip it
            if palindrome[i] != 'a':
                # otherwise, we replace the first character that is not ""a""
                return palindrome[:i] + 'a' + palindrome[i + 1:]
        # by the time it reaches here, the only possible case is all the characters in palindrome is ""a""
        # e.g. ""aaaaaa"" so that we haven't changed anything in above logic
        # in this case, as mentioned above, the best character to use is ""b""
        # and we should replace the last character to achieve the smallest one possible
        return palindrome[:-1] + 'b'",0
"class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        
        diag = {}
        m = len(mat)
        n = len(mat[0])
        
        for row in range(m):
            for col in range(n):
                diag.setdefault(col-row, [])
                diag[col-row].append(mat[row][col])
        
        for key, val in diag.items():
            diag[key] = sorted(val)
        
        for row in range(m):
            for col in range(n):
                mat[row][col] = diag[col-row].pop(0)
        
        return mat",1
"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        maxi, mini = -math.inf, math.inf
        
        for a, b in zip(nums, nums[1:]):
            maxi = max(min(a, b), maxi)
            mini = min(max(a, b), mini)
        change = max(0, (maxi - mini) * 2)
        
        # solving the boundary situation
        for a, b in zip(nums, nums[1:]):
            tmp1 = - abs(a - b) + abs(nums[0] - b)
            tmp2 = - abs(a - b) + abs(nums[-1] - a)
            change = max([tmp1, tmp2, change])
			
        original_value = sum(abs(a - b) for a, b in zip(nums, nums[1:]))
        return  original_value + change",0
"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        rank = {x:len(arr)-i for i, x in enumerate(sorted(arr, reverse=True))}
        return map(rank.get, arr)",0
"class Solution:
    def removePalindromeSub(self, s: str) -> int:
        
        n=len(s)
        if not n:
            return 0
        if s[::-1]==s:
            return 1
        else:
            return 2",1
"class Solution:
    def filterRestaurants(self, R: List[List[int]], V: int, P: int, D: int) -> List[int]:
        R = [[r[1],r[0]] for r in R if r[2] >= V and r[3] <= P and r[4] <= D]
        return list(zip(*sorted(R, reverse = True)))[1] if R else []
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        
        dis=[]
        for i in range(n):
            x=[]
            for j in range(n):
                x.append(float(""inf""))
            dis.append(x)
            
        
        for i in range(len(edges)):
            x=edges[i]
            dis[x[0]][x[1]]=x[2]
            dis[x[1]][x[0]]=x[2]
            
        
        for k in range(n):
            for j in range(n):
                for i in range(n):
                    if dis[i][j]>dis[i][k]+dis[k][j]:
                        dis[i][j]=dis[i][k]+dis[k][j]
        
        d={}
        print(dis)
        for i in range(n):
            d[i]=0
        for i in range(n):
            for j in range(n):
                if dis[i][j]<=distanceThreshold:
                    if i==j:
                        continue
                    d[i]+=1
                    
        l=list(d.keys())
        min=float(""inf"")
        
        for i in range(len(l)):
            if d[l[i]]<min:
                min=d[l[i]]
                
        ans=[]
        for i in range(len(l)):
            if d[l[i]]==min:
                ans.append(l[i])
                
        
        
        return max(ans)",0
"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
        n = len(jobDifficulty)
        if d > n:
            return -1

        # Memoize maximum for every cut
        max_dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(i, n):
                if i == j:
                    max_dp[i][j] = jobDifficulty[i]
                else:
                    max_dp[i][j] = max(max_dp[i][j - 1], jobDifficulty[j])
        
        # Calculate minimum difficulty
        dp = [[0 for _ in range(n)] for _ in range(d)]
        for i in range(d):
            for j in range(i, min(n, n - d + i + 1)):
                if i == 0:
                    dp[i][j] = max_dp[i][j]
                else:
                    dp[i][j] = min(
                        dp[i - 1][k - 1] + max_dp[k][j]
                        for k in range(i, j + 1)
                    )
        return dp[d - 1][n - 1]",0
"class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:

        row = []
        for i in range(len(mat)):
            row.append((sum(mat[i]), i))
        heapq.heapify(row)

        ans = []
        while k>0:
            (val, idx) = heapq.heappop(row)
            ans.append(idx)
            k -= 1

        return ans",1
"class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        h = [-c for c in Counter(arr).values()]
        heapq.heapify(h)
        
        size = len(arr)
        half = (size + 1) // 2        
        result = 0
        while size > half:
            size += heapq.heappop(h)
            result += 1
            
        return result",1
"class Solution:
    def maxProduct(self, root: TreeNode) -> int:
        subtreeSums = set()
        
        def getSum(node):
            if not node:
                return 0
            elif not node.left and not node.right:
                subtreeSums.add(node.val)
                return node.val
            else:
                result = getSum(node.left) + getSum(node.right) + node.val
                subtreeSums.add(result)
                return result
            
        rootSum = getSum(root)
        idealSplit = rootSum/2
        closestToIdeal = 0
        
        for possibleSum in subtreeSums:
            if math.fabs(possibleSum - idealSplit) < math.fabs(closestToIdeal - idealSplit):
                closestToIdeal = possibleSum        
        
        return (((rootSum - closestToIdeal) % (10**9 + 7)) * (closestToIdeal % (10**9 + 7)))  % (10**9 + 7)",1
"class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n=len(arr)
        ans=-float('inf')
        dp=[-1 for i in range(n)]
        def dfs(ind):
            if dp[ind]!=-1:
                return dp[ind]
            v1,v2=0,0
            for left in range(ind-1,max(-1,ind-d-1),-1):
                if arr[left]<arr[ind]:
                    lv=1+dfs(left)
                else:
                    break
                v1=max(v1,lv)
            for right in range(ind+1,min(n,ind+d+1),1):
                if arr[right]<arr[ind]:
                    rv=1+dfs(right)
                else:
                    break
                v2=max(v2,rv)
            dp[ind]=max(v1,v2,1)
            return dp[ind]
        for i in range(n):
            ans=max(ans,dfs(i))
        return ans",0
"class Solution:
    def numberOfSteps(self, num: int) -> int:
        count = 0 # taking a couter to count  number of steps to reduce it to zero

        while num>0: # nums should not be less then 0
            if num % 2 == 0: # if num is completely divide by zero 
                num = num//2 # to have the quotient
                count+=1 # as number got reduced we will increase the counter
            else:
                num-=1 # and if num is not even then we subtract one out of it.
                count+=1 # as number got reduced we will increase the counter
        return count # returning the step occurred o reduce the number.",0
"class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        window_start, total, res = 0, 0, 0
        
        for i in range(k - 1):
            total += arr[i]
            
        for window_end in range(k - 1, len(arr)):
            total += arr[window_end]
            if window_end - window_start + 1 > k:
                total -= arr[window_start]
                window_start += 1
                
            if total / k >= threshold:
                res += 1
            
        return res",0
"class Solution:
    def angleClock(self, H: int, M: int) -> float:
        return min(abs(30*H-11*M/2),360-abs(30*H-11*M/2))
		
		
- Junaid Mansuri
- Chicago, IL",1
"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        N, grps = len(arr), defaultdict(list)

        for i, el in enumerate(arr): 
            grps[el].append(i)

        vis, vis_grps = set(), set()
        
        def bfs(lvl, dist):
            nextLvl = set()
            
            for i in lvl:
                if i in vis: continue
                if i == N-1: return dist
                
                vis.add(i)
                
                if i: nextLvl.add(i-1)
                if i+1 < N: nextLvl.add(i+1)
                
                if not arr[i] in vis_grps:
                    vis_grps.add(arr[i])
                    nextLvl.update(grps[arr[i]])
            
            return bfs(nextLvl, dist + 1)
            
        return bfs(set([0]), 0)",1
"class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        s = set([x*1.0 for x in arr])

        from collections import Counter
        if Counter(arr)[0] >= 2:
            return True
        
        for i in arr:
            t = i/2
            
            if t in s and t != 0:
                return True
        
        return False",1
"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        x=list((Counter(s) &amp; Counter(t)).elements())
        return len(s)-len(x)",1
"class Solution:
    def maxStudents(self, seats: List[List[str]]) -> int:
        m, n = len(seats), len(seats[0]) # dimensions 
        
        valid = []
        for i in range(m): 
            val = 0
            for j in range(n): 
                if seats[i][j] == ""."": val |= 1 << j 
            valid.append(val)
        
        @cache
        def fn(i, mask): 
            """"""Return max students taking seats[i:] given previous row as mask.""""""
            if i == len(seats): return 0 
            ans = fn(i+1, 0)
            for x in range(1 << n): 
                if x &amp; valid[i] == x and (x >> 1) &amp; x == 0 and (mask >> 1) &amp; x == 0 and (mask << 1) &amp; x == 0: 
                    ans = max(ans, bin(x).count(""1"") + fn(i+1, x))
            return ans 
        
        return fn(0, 0)",0
"class Solution:
    
    def negativeCounter(self, lst: List[int]) -> int:
        l = 0
        r = len(lst) - 1
        count = 0
        
        while l <= r:
            mid = l + (r - l)//2
            if lst[mid] >= 0:
                l = mid + 1
            else:
                count += r - mid + 1
                r = mid - 1
        return count
    
    def countNegatives(self, grid: List[List[int]]) -> int:
        
        count = 0       
        for item in grid:
            count += self.negativeCounter(item)
        return count",1
"class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        events.sort(key=lambda x: (x[1], x[0]))
        attend = set()
        
        for start, end in events:
            for day in range(start, end+1):
                if day not in attend: 
                    attend.add(day)
                    break
                    
        return len(attend)",1
"class Solution:
    def isPossible(self, target: List[int]) -> bool:
        n = len(target)
        sumk = 0
        for x in sorted(target):
            if x == 1:
                continue
            if (x-1) % (n-1) != 0:
                return False
            k = (x-1)//(n-1)
            if not k > sumk:
                return False
            sumk += k
        return True",1
"class Solution:
    def count1s(self, num):
        count = 0
        while num >= 1:
            if num%2: count += 1
            num = num//2
        return count
    def cmp(self, vals):
        l,r = vals
        return r * 10000 + l
        
    def sortByBits(self, arr: List[int]) -> List[int]:
        new_arr = [[arr[i], self.count1s(arr[i])] for i,_ in enumerate(arr)]
        sorted_new_arr = sorted(new_arr, key = self.cmp)
        result = [sorted_new_arr[i][0] for i,_ in enumerate(sorted_new_arr)]
        return result",1
"class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        return reduce(lambda y,x:[y[0]+1+min(y[1].values()), dict(y[1],**{x[1]:x[0]})],
		              enumerate(s+'a'),[0,defaultdict(lambda:-1)])[0]",0
"class Solution:
    def countOrders(self, n: int) -> int:
        ans = 1
        for x in range(2, n+1): 
            ans = (ans*x*(2*x-1)) % 1_000_000_007
        return ans",1
"class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        if date1 > date2: date1, date2 = date2, date1
        y1, m1, d1 = [int(x) for x in date1.split(""-"")]
        y2, m2, d2 = [int(x) for x in date2.split(""-"")]
        
        leap = lambda y: (y%4 == 0 and y%100 != 0) or (y%400 == 0)
        dates = 365*(y2-y1) + sum(leap(y) for y in range(y1, y2))
        
        days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        dates -= days[m1-1] + (m1 > 2 and leap(y1)) + d1
        dates += days[m2-1] + (m2 > 2 and leap(y2)) + d2
        
        return dates",0
"class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        children = 0
        for i in range(n):
            if i > leftChild[i] > -1 or i > rightChild[i] > -1: return False
            children += (leftChild[i] > -1) + (rightChild[i] > -1)
        return children == n - 1",0
"class Solution:
    def smallerNumbersThanCurrent(self, nums):
        count = [0 for i in range(102)]
        for num in nums: count[num+1] += 1
        for i in range(1, len(count)): count[i] += count[i-1]
        return [count[num] for num in nums]",1
"class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        d = {}
        for z in range(len(votes[0])):
            for i in votes:
                d[i[z]] = d.get(i[z],'') + chr(97 + z)
        d = dict((i,j) for i,j in sorted(d.items(),key=lambda x:x[0]))
        return ''.join([i for i,j in sorted(d.items(),key=lambda x:x[1])])",0
"class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        if root is None:
            return False
        if self.helper(head, root):
            return True
        if self.isSubPath(head, root.left):
            return True
        return self.isSubPath(head, root.right)

    def helper(self, list_node: ListNode, tree_node: TreeNode) -> bool:
        if list_node is None:
            return True
        if tree_node is None:
            return False
        if tree_node.val != list_node.val:
            return False
        else:
            return self.helper(list_node.next, tree_node.left) or self.helper(list_node.next, tree_node.right)",0
"class Solution:
    def dfs(self, grid: List[List[int]]) -> int:
        # timeout
        
        size_y = len(grid)
        size_x = len(grid[0])
        src = (0, 0)
        des = (size_y - 1, size_x - 1)
        stack = [(src, 0)]
        costs = {
            src: 0
        }
        
        while stack:
            cur, cost = stack.pop()
            sign = grid[cur[0]][cur[1]]
            
            # print(cur, cost, sign)
            
            for neighbor, neighbor_sign in self.iter_neighbors(cur, size_y, size_x):
                neighbor_cost = cost
                if sign != neighbor_sign:
                    neighbor_cost += 1
                known_neighbor_cost = costs.get(neighbor)
                
                if known_neighbor_cost is None or known_neighbor_cost > neighbor_cost:
                    costs[neighbor] = neighbor_cost

                    stack.append((neighbor, neighbor_cost))
    
        return costs[des]
    
    def bfs(self, grid: List[List[int]]) -> int:
        # 7500 ms, 14.2 MB
        size_y = len(grid)
        size_x = len(grid[0])
        src = (0, 0)
        des = (size_y - 1, size_x - 1)
        queue = [(src, 0)]
        costs = {
            src: 0
        }
        
        while queue:
            cur, cost = queue.pop(0)
            sign = grid[cur[0]][cur[1]]
            
            for neighbor, neighbor_sign in self.iter_neighbors(cur, size_y, size_x):
                neighbor_cost = cost
                if sign != neighbor_sign:
                    neighbor_cost += 1
                known_neighbor_cost = costs.get(neighbor)
                
                if known_neighbor_cost is None or known_neighbor_cost > neighbor_cost:
                    costs[neighbor] = neighbor_cost

                    queue.append((neighbor, neighbor_cost))
    
        return costs[des]
    
    def dijkstra(self, grid: List[List[int]]) -> int:
        # 1000 ms, 16.7 MB
        import heapq

        class Node:
            def __init__(self, y, x, sign, distance=0, via=None):
                self.coord = (y, x)
                self.distance = distance
                self.via = via
                self.sign = sign

            def __lt__(self, other):
                return self.distance < other.distance
        
        size_y = len(grid)
        size_x = len(grid[0])
        start = Node(0, 0, grid[0][0])
        
        node_map = {
            (0, 0): start
        }
        visited_coords = {(0,0)}
        heap = [start]
        
        des_coord = (size_y - 1, size_x - 1)
        
        while heap:
            cur = heapq.heappop(heap)
            visited_coords.add(cur.coord)
            y, x = cur.coord
            
            for neighbor_coord, neighbor_sign in self.iter_neighbors(cur.coord, size_y, size_x):
                if neighbor_coord != cur.coord and neighbor_coord not in visited_coords:

                    if cur.sign == neighbor_sign:
                        # no penalty when it's the node the arrow is pointing at
                        nd = cur.distance
                    else:
                        nd = cur.distance + 1

                    node = node_map.get(neighbor_coord)
                    if node:
                        if node.distance > nd:
                            node.distance = nd
                            node.via = cur
                            heapq.heapify(heap)
                    else:
                        node = Node(*neighbor_coord, grid[neighbor_coord[0]][neighbor_coord[1]], distance=nd, via=cur)
                        node_map[neighbor_coord] = node
                    
                        heapq.heappush(heap, node)

        des_node = node_map[des_coord]

        return des_node.distance
    
    def iter_neighbors(self, coord: tuple, size_y: int, size_x: int):
        y, x = coord
        for sign in range(1, 5):
            if sign == 1:  # right
                if x < size_x - 1:
                    yield (y, x + 1), sign
            elif sign == 2: # left
                if x > 0:
                    yield (y, x - 1), sign
            elif sign == 3: # down
                if y < size_y - 1:
                    yield (y + 1, x), sign
            else:           # up
                if y > 0:
                    yield (y - 1, x), sign

    def minCost(self, grid: List[List[int]]) -> int:
        return self.dijkstra(grid)",0
"class Solution:
    def sortString(self, s: str) -> str:
        
        count, res, flag = collections.Counter(sorted(s)), [], True

        while count:
            temp = list(count)
            res += temp if flag else reversed(temp)
            count -= collections.Counter(temp)
            flag ^= True        
        
        return """".join(res)",1
"class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # one (int) variable to store vowel-related information
        # e.g., 00000 (0)
        # if a occurs, 00000 ^ 00001 = 00001 (1)
        # if i occurs, 00001 ^ 00100 = 00101 (5)
        # if a occurs, 00101 ^ 00001 = 00100 (4)
        # ---------------------------------------------------------
        # if at index 1, we have state 00101 (5)
        # and at index 11, we have state 00101 (5) again, 
        # then we can claim this sub-array (from index 1 to 11) has even vowels 
        # with the evidence that 00101 ^ 00101 = 00000 
        # ---------------------------------------------------------
        # Rationale
        # 1. We one-pass the array &amp; record the state at each element 
        # 2. If the current state has been recorded before, we compare to the leftmost index
        #    with the same state 
        
        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}
        d = {0: -1} # d: dictoray to record the leftmost indices of states 
        state, ans = 0, 0 
        for i, c in enumerate(s): # c: char 
            if c in vowels:
                state ^= vowels[c]
            
            # record the leftmost index with state v 
            if not (state in d): 
                d[state] = i 
                
            ans = max(ans, i-d[state])
        
        return ans",0
"class Solution:
    def longestZigZag(self, root: TreeNode) -> int:
        
        def fn(node): 
            """"""Return #nodes on longest ZigZag path starting at given node""""""
            nonlocal ans 
            if node is None: return (0, 0)
            (_, r1), (l2, _) = fn(node.left), fn(node.right)
            ans = max(ans, r1+1, l2+1)
            return (r1+1, l2+1)
        
        ans = 0
        fn(root)
        return ans-1",1
"class Solution:
    def maxSumBST(self, root: TreeNode):
        self.max = 0
		
        def dfs(root):
            if not root :  return (""N"" , 0)
            
            l_v , l_acc  =  dfs(root.left)            
            r_v , r_acc = dfs(root.right)
            
            if (l_v == ""N"" and r_v == ""N"") or (l_v == ""N"" and isinstance(r_v, int) and  r_v > root.val ) or (isinstance(l_v, int) and  l_v < root.val and r_v == ""N"" )  or isinstance(l_v, int) and isinstance(r_v, int) and l_v < root.val < r_v:
                now_acc = l_acc + r_acc + root.val
                self.max = max(self.max , now_acc)
                return (root.val ,now_acc )
            else: 
                return (root.val , -sys.maxsize )
            
        dfs(root)
        return self.max",0
"class Solution:
    def generateTheString(self, n: int) -> str:
        return ""a""*n if n &amp; 1 else ""a""*(n-1) + ""b""",1
"class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        ans = 0
        largest = 0
        for i,n in enumerate(flips):
            largest = max(largest, n)
            if largest == i+1:
                ans+=1
        return ans",1
"class Solution:
    def __init__(self):
        self.result = [0]
    def dfs(self,count,head,informTime,time): 
        self.result[0] = max(self.result[0],time)
        for emp in count[head]:
            self.dfs(count,emp,informTime,time+informTime[head])
            
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        count = collections.defaultdict(list)
        for i in range(len(manager)):
            count[manager[i]].append(i)
        
        self.dfs(count,headID,informTime,0)
        return self.result[0]",0
"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if target==1:
            return 1.0 if len(edges)==0 else 0.0
        # note it's a undirected graph
        graph=[{} for _ in range(n+1)]
        for src,dst in edges:
            graph[src][dst]=1
            graph[dst][src]=1
        # do a bfs
        queue=[(1,1.0)]
        next=[]
        for time in range(t):
            for node,p in queue:
                for child in graph[node]:
                    del graph[child][node]
                    if child==target:
                        if time==t-1 or len(graph[child])<1:
                            return p/len(graph[node])
                        else:
                            return 0.0
                    next.append((child,p/len(graph[node])))
            queue=next
            next=[]
        return 0.0",0
"class Solution:  
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:  
          
        queue = [([], original)]  
        while queue:  
            actions, node = queue.pop(0)  
            if id(node) == id(target):  
                cloned_target = cloned  
                for a in actions:  
                    if a == 1:  
                        cloned_target = cloned_target.right  
                    else:  
                        cloned_target = cloned_target.left  
                  
                return cloned_target  
                  
            if node.left:  
                actions_copy = []  
                actions_copy.extend(actions)  
                actions_copy.append(0) # Move left  
                queue.append((actions_copy, node.left))  
                  
            if node.right:  
                actions_copy = []  
                actions_copy.extend(actions)  
                actions_copy.append(1) # Move right  
                queue.append((actions_copy, node.right))  
                  
        return None",0
"class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        row_count = len(matrix)
        column_count = len(matrix[0])
        
        result = []
        for row in matrix:
            # Identify min value in row and get it's column index
            min_value = min(row)
            min_index = row.index(min_value)
            column_index = 0
            column_max = 0
            # Using the column check for max of that column
            while column_index < row_count:
                if matrix[column_index][min_index] > column_max:
                    column_max = matrix[column_index][min_index]
                column_index += 1
            # If row min equals column max then add it to our results list   
            if column_max == min_value:
                result.append(min_value)
                
        return result",0
"class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        
        def inorder_gen(n: TreeNode):
            if not n:
                return
            yield from inorder_gen(n.left)
            yield n
            yield from inorder_gen(n.right)
            n.left, n.right = None, None
            
        seq = tuple(inorder_gen(root))
        
        def restore(r, l) -> TreeNode:
            if r > l:
                return
            mid = l + (r - l) // 2
            n = seq[mid]
            n.left, n.right = restore(r, mid - 1), restore(mid + 1, l)
            return n
        
        return restore(0, len(seq)-1)",1
"class Solution:
def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
    MOD = 10**9+7
	
	#  Converting both list into one list
    candidates = zip(efficiency,speed)
	
	#  sort the candidates in terms of decreasing speed
    candidates = sorted(candidates,key=lambda x:x[0],reverse=True)
    speed_sum=res=0
	
	# defining heap to store ""K"" efficient candidates
    heap=[]
	
	# Checking with every candidates
    for ce,cs in candidates:
        if len(heap)>=k:
            speed_sum-=heap[0]
            heapq.heappop(heap)
        
        heapq.heappush(heap,cs)
        speed_sum+=cs
        res=max(res,speed_sum*ce)
    
	return res%MOD",1
"class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        count, total = 0, len(arr1)
        
        for out in arr1:
            for inner in arr2:
                if abs(out - inner) <= d:
                    count += 1
                    brea
        return total - count",1
"class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        count, reservedSeats, available_rows = 0, sorted(reservedSeats), n

        row = reservedSeats[0][0]
        available_rows -= 1
        row_result =  [0] * 10
        
        for seats in reservedSeats:
            sit = seats[1]
            if row == seats[0]:
                row_result[sit-1] = 1
            else:
                # Calculate
                spaces = 0
                for idx, chair in enumerate(row_result):
                    if chair == 0:
                        spaces += 1
                    else:
                        spaces = 0
                    
                    if spaces >= 4 and idx in (4,6,8):
                        count += 1
                        spaces = 0
                    
                row = seats[0] 
                row_result =  [0] * 10
                row_result[sit-1] = 1
                available_rows -= 1
                
        spaces = 0
        for idx, chair in enumerate(row_result):
            if chair == 0:
                spaces += 1
            else:
                spaces = 0
            if spaces >= 4  and idx in (4,6,8):
                count += 1
                spaces = 0
        
        count = count + (available_rows * 2)
                        
        return count",0
"class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        
		# to store the power value of n, and avoid repeated computation
        loop_up_table = {}
        
        def power_val( n ):
            
            step, origin_input = 0, n
            while n != 1:

                
                if n in loop_up_table:
                    # speed up by look-up table
                    loop_up_table[origin_input] = loop_up_table[n] + step
                    return loop_up_table[n]+step
                
                
                if n &amp; 1 == 1:
                    n = 3*n + 1
                else:
                    n = n // 2
            
                step += 1
            
            loop_up_table[origin_input] = step
            return step
        
        # ------------------------------------------
        
        ranked_value = sorted( range(lo, hi+1), key = lambda n:  (power_val(n), n) )

        return ranked_value[k-1]",0
"class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        
        def solve(index,end,slices,n,dic):
            key=(index,n)
            if key in dic:
                return dic[key]
            else:
                if n==0 or index>end:
                    return 0
                include=slices[index]+solve(index+2,end,slices,n-1,dic)
                exclude=solve(index+1,end,slices,n,dic)
                dic[key]=max(include,exclude)
                return dic[key]
        l=len(slices)
        dic1={}
        dic2={}
        c1=solve(0,l-2,slices,l//3,dic1)
        c2=solve(1,l-1,slices,l//3,dic2)
        return max(c1,c2)",0
"class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        result = []
        for i in range(0, len(index)):
            # insertion is guaranteed to be valid
            result.insert(index[i], nums[i]) # shift then insert value
        return result",1
"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        
        def fn(x):
            c = s = 0
            for i in range(1, int(x**0.5)+1):
                if x % i == 0: 
                    c += 1 + (0 if x//i == i else 1)
                    s += i + (0 if x//i == i else x//i)
            return s if c == 4 else 0
        
        return sum(fn(x) for x in nums)",1
"class Solution:
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        if not grid or not grid[0]:
            return False
        
        M, N = len(grid), len(grid[0])
        left, right, up, down = (0,-1), (0,1), (-1,0), (1,0)
        direction = { 1: (left, right), 2: (up, down), 3: (left, down), 4: (right, down), 5: (left, up), 6: (right, up) }
        compatibles = { right: {1, 3, 5}, left: {1, 4, 6}, up: {2, 3, 4}, down: {2, 5, 6} }
        
        q = collections.deque([(0, 0)])
        seen = {(0, 0)}
        while q:
            r, c = q.popleft()
            if (r, c) == (M-1, N-1):
                return True
            di_x, di_y = direction[grid[r][c]]
            accepted_paths = compatibles[di_x] | compatibles[di_y]
            for dr, dc in [di_x, di_y]:
                cr, cc = r+dr, c+dc
                if (cr, cc) not in seen and 0 <= cr < M and 0 <= cc < N and grid[cr][cc] in accepted_paths:
                    seen.add((cr, cc))
                    q.append((cr, cc))
        return False",0
"class Solution:
    def longestPrefix(self, s: str) -> str:
        lps = [0]*len(s)
        curr = 1
        pre = 0
        while curr < len(s):
            if s[curr] == s[pre]:
                lps[curr] = pre + 1
                curr +=1
                pre+=1
            else:
                if pre == 0:
                    lps[curr] = 0
                    curr += 1
                else:
                    pre = lps[pre-1]
        a = ''
        for i in range(lps[-1]):
            a += s[i]
        return a",1
"class Solution:
    def findLucky(self, arr: List[int]) -> int:
        ans = [0] * 501
        res = -1
        for i in range(len(arr)):
            ans[arr[i]] += 1
        for i in range(1, 501):
            if ans[i] == i:
                res = max(res, i)
        return res",1
"class Solution:
    def numTeams(self, rating: List[int]) -> int:
        teams = [0]
        
        def up(n1, n2):
            return n2 > n1
        
        def down(n1, n2):
            return n2 < n1
        
        def search_team(team, np=0, op=up):
            for i in range(np, len(rating)):
                nv = rating[i]
                if not team or op(team[-1], nv):
                    team_copy = []
                    team_copy.extend(team)
                    team_copy.append(nv)
                    if len(team_copy) < 3:
                        search_team(team_copy, np=i, op=op)
                    else:
                        teams[0] += 1
        
        # Search team in up rating
        search_team([])
        # Search team in down rating        
        search_team([], op=down)
        
        return teams[0]",0
"class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        p=10**9+7
        ord_a=ord('a')
        l=len(evil)
        dup=[]
        for i in range(1, l):
            if evil[i:]==evil[:l-i]:
                dup.append(i)
        lend=len(dup)
        def count(s):
            tmp_ct=0
            bd=1
            ind=n
            without_s=[]
            for i in range(n):
                tmp_ct*=26
                if bd:
                    tmp_ct+=ord(s[i])-ord_a
                if i>=l-1 and ind>i-l and evil<s[i-l+1:i+1]:
                    tmp_ct-=1
                if i>=l:
                    tmp_ct-=without_s[i-l]
                if i>=l-1:
                    if s[i-l+1:i+1]==evil:
                        bd=0
                        ind=i
                tmp_ct%=p
                tmp_with_s=0
                for j in range(lend):
                    d=dup[j]
                    if i>=d:
                        tmp_with_s+=without_s[i-d]
                    if i>=d-1 and ind>i-d and evil[:d]<s[i-d+1:i+1]:
                        tmp_with_s+=1
                without_s.append(tmp_ct-tmp_with_s)
            return tmp_ct, bd
        str_ct1, bd1=count(s1)
        str_ct2, bd2=count(s2)
        return (str_ct2-str_ct1+bd2)%p",0
"class Solution:
    def countLargestGroup(self, n: int) -> int:
        freq = {}
        for x in range(1, n+1): 
            key = sum(int(d) for d in str(x))
            freq[key] = 1 + freq.get(key, 0)
        vals = list(freq.values())
        return vals.count(max(vals))",1
"class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if len(s) < k:
            return False
        
        counter = collections.Counter(s)
        
        odd_count = 0
        for key in counter:
            if counter[key] % 2 != 0:
                odd_count += 1
        
        return odd_count <= k",1
"class Solution:
    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        
        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:
            return True
        
        elif xc > x2:
            if yc > y2:
                return r**2 >= (xc-x2)**2 + (yc-y2)**2
            elif yc >= y1 and yc < y2:
                return r >= xc-x2
            else: # yc < y1
                return r**2 >= (xc-x2)**2 + (yc-y1)**2
        elif xc <= x1:
            if yc > y2:
                return r**2 >= (xc-x1)**2 + (yc-y2)**2
            elif yc >= y1 and yc < y2:
                return r >= x1-xc
            else: # yc < y1
                return r**2 >= (xc-x1)**2 + (yc-y1)**2
        elif xc > x1 and xc < x2 and yc > y2:
            
            return r >= yc -y2
        else: 
            return r >= y1-yc",0
"class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort()
        result , current_sum = 0 , 0
        while satisfaction and satisfaction[-1] + current_sum > 0:
            current_sum += satisfaction.pop()
            result += current_sum
        return result",1
"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        
        # make nums sorted in descending order
        nums.sort( reverse = True )
        
        summation = sum( nums )
        
        sequence, partial_sum = [], 0
        
        # keep picking number from largest one, until partial sum is larger than (summation / 2)
        for number in nums:
            
            partial_sum += number
            sequence.append( number )
            
            if partial_sum > summation / 2:
                break
                
        return sequence",1
"class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        nums = [a, b, c]
        chars = ['a', 'b', 'c']
        indices = [0, 1, 2]
        def keyFunc(i):
            return nums[i]
        indices = sorted(indices, key=keyFunc)
        if nums[indices[2]] > (nums[indices[1]] + nums[indices[0]] + 1) * 2:
            nums[indices[2]] = (nums[indices[1]] + nums[indices[0]] + 1) * 2
        if nums[indices[2]] > nums[indices[1]] + nums[indices[0]] + 1:
            s = """"
            gaps = nums[indices[1]] + nums[indices[0]] + 1
            doubles = nums[indices[2]] % gaps
            if doubles == 0:
                doubles = gaps
            singles = nums[indices[2]] - doubles
            for k in [0, 1]:
                for i in range(nums[indices[k]]):
                    if doubles > 0:
                        s += chars[indices[2]]
                        doubles -= 1
                    s += chars[indices[2]]
                    s += chars[indices[k]]
            if doubles > 0:
                s += chars[indices[2]]
            s += chars[indices[2]]
            return s
        else:
            s = """"
            singles = nums[indices[2]]
            gaps = nums[indices[1]] + nums[indices[0]] + 1
            zeros = gaps - singles
            skip = True
            for k in [0, 1]:
                for i in range(nums[indices[k]]):
                    if zeros > 0 and skip:
                        zeros -= 1
                    else:
                        s += chars[indices[2]]
                    s += chars[indices[k]]    
                    skip = not skip
            if not(zeros > 0 and skip):
                s += chars[indices[2]]
            return s",0
"class Solution:
    def stoneGameIII(self, s: List[int]) -> str:
        n = len(s)
        dpi = 0
        dp1 = 0
        dp2 = 0
        i = n-1
        while i >= 0:
            ans = -1<<32
            ans = max(ans,s[i]-dpi)
            if i+1 < n:
                ans = max(ans,(s[i]+s[i+1])-dp1)
            if i+2 < n:
                ans = max(ans,(s[i]+s[i+1]+s[i+2])-dp2)
            dp2 = dp1
            dp1 = dpi
            dpi = ans
            i -= 1
        if dpi > 0:
            return ""Alice""
        if dpi == 0:
            return ""Tie""
        return ""Bob""",0
"class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        words_set = words.sort(key=len)
        ans = []
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                if words[i] in words[j]:
                    ans.append(words[i])
        return set(ans)",1
"class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        
        p=[]
        for i in range(1,m+1):
            p.append(i)
        
        result=[]
        for i in range(len(queries)):
            x=queries[i]
            idx=p.index(x)
            p.pop(idx)
            p.insert(0,x)
            result.append(idx)
        
        return result
        print(result)",1
"class Solution:
    def entityParser(self, text: str) -> str:
        mapping = {""&amp;quot;"" : '""', 
                   ""&amp;apos;"" : ""'"", 
                   ""&amp;gt;""   : "">"", 
                   ""&amp;lt;""   : ""<"", 
                   ""&amp;frasl;"": ""/"", 
                   ""&amp;amp;""  : ""&amp;""}
        for key, val in mapping.items():
            text = text.replace(key, val)
        return text",0
"class Solution:
    def numOfWays(self, n: int) -> int:
        if n == 0:
            return 0
        atlevel = 12
        five = 6
        four = 6
        depth = 1
        while depth < n:
            depth+=1
            a1four = five*2
            a1five = five*3
            b1five = four*2
            b1four = four*2
            atlevel = a1four+a1five+b1four+b1five
            five = a1five+b1five
            four = a1four+b1four
        return atlevel%(10**9+7)",1
"class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        
        prefix_sum = 0
        negative_most_offset = float('inf')
        
        # linear scan, and update nagative most offset by prefix sum
        for i in range(0, len(nums)):
            
            prefix_sum += nums[i]
            negative_most_offset = min( prefix_sum, negative_most_offset)
        
        # compute the minimum value to get positive
        threshold = min( negative_most_offset,  0 )
        
        # abs to flip the sign, +1 to make it larger than zero
        return abs(threshold)+1",1
"class Solution:
    
   
    
    def findMinFibonacciNumbers(self, k: int) -> int:
        m= [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733 
]
        m.sort()
        m=m[::-1]
        x=0
        count=0
        print(m)
        i=0
        y=k

        
        
        for i in range(len(m)):
            if m[i]>k:
                continue
            count+=1
            x+=m[i]
            if x>k:
                x-=m[i]
                count-=1
            if x==k:
                break
        return count",0
"class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        def get_hs(n):
            ''' get happy string for length=`n`'''
            def _gen_of_hs(hs, n=n):
                ''' generator of happy string'''
                if len(hs) == n:
                    yield hs
                else:
                    for c in ['a', 'b', 'c']:
                        if hs and hs[-1] == c:
                            continue
                            
                        yield from _gen_of_hs(hs+c)
                        
            return _gen_of_hs('', n)
        
        num_of_hs = 0
        ''' number of happy string generated'''
        
        # Algorithm: Keep generating happy string util the kth one generated.
        for hs in get_hs(n):
            num_of_hs += 1
            if num_of_hs == k:
                return hs
            
        # Unable to retrieve the kth happy string
        return """"
            `",0
"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        dp = [0]*(len(s)+1)
        dp[-1] = sm = 1 
        
        ii = len(s)
        for i in reversed(range(len(s))): 
            if s[i] != ""0"": 
                while ii - i - 1 > log10(k) or int(s[i:ii]) > k: 
                    sm = (sm - dp[ii]) % 1_000_000_007
                    ii -= 1
                dp[i] = sm
                sm = (sm + dp[i]) % 1_000_000_007
        return dp[0]",1
"class Solution:
    def reformat(self, s: str) -> str:
        nextDigit, nextStr, res = 0, 0, """"
		
        def helper(curr,fn):
            #return first occurance str with function passed (digit, alpha)
            while curr<len(s):
                if fn(s[curr]):
                    break;
                curr+=1
            return curr
			
        #append to res digit and str in that order
        while nextDigit<len(s) and nextStr<len(s):
            nextDigit = helper(nextDigit, str.isdigit)
            nextStr = helper(nextStr, str.isalpha)
            if nextDigit >= len(s):
                break
            res += s[nextDigit] 
            if nextStr >= len(s):
                break
            res += s[nextStr] 
            nextDigit += 1
            nextStr += 1
            
        #if there are digits remaining 
        if helper(nextDigit + 1, str.isdigit) < len(s):
            return """"
        # if the current string is not accounted for, prepend it to the result
        if nextStr < len(s) and s[nextStr].isalpha():
            res = s[nextStr] + res
        # if we can find more strings
        if helper(nextStr + 1, str.isalpha) < len(s):
            return """"
        return res",0
"class Solution:
    def displayTable(self, orders) :
        #definitely needs improvement.
        tables = {}
        food = {}
        for order in orders: #go thru orders to list all table and food items.
            tables[order[1]] = None
            food[order[2]] = None
        food_kinds = len(food)
        tables_num = len(tables)
        display_table = [[""0"" for i in range(food_kinds+1)] for j in range(tables_num+1)]
        display_table[0][0] = ""Table""
        row_table = 1
        tables = dict(sorted(tables.items(),key = lambda x:int(x[0]))) #sort table in numeric order
        for table in tables:
            display_table[row_table][0]= table
            tables[table] = row_table #record which row is for this table.
            row_table+=1
        column_table = 1
        food = dict(sorted(food.items(),key = lambda x:x[0])) #sort food item in alphabetical order
        for food_item in food:
            display_table[0][column_table]= food_item
            food[food_item]= column_table #record which column is for this food item
            column_table +=1
            
        for order in orders:
            if display_table[tables[order[1]]][food[order[2]]] == ""0"":
                display_table[tables[order[1]]][food[order[2]]]=""1""
            else: 
                display_table[tables[order[1]]][food[order[2]]]=str(int(display_table[tables[order[1]]][food[order[2]]])+1)
        return display_table",0
"class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        vals = {'c': 0, 'r': 1, 'o': 2, 'a': 3, 'k': 4}
        croaks = [0] * 4
        frogs = 0

        for c in croakOfFrogs:
            val = vals[c]
            if val:
                if not croaks[val - 1]:
                    return -1
                croaks[val - 1] -= 1
                
            if val != 4:
                croaks[val] += 1
            
            frogs = max(frogs, sum(croaks))
        
        return frogs if not sum(croaks) else -1",1
"class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        
        @cache
        def fn(i, x, k): 
            """"""Return number of ways to build arr[i:] with current max at x and remaining cost at k.""""""
            if n - i < k: return 0 # impossible 
            if m - x < k: return 0 # impossible 
            if k == 0: return x**(n-i)
            return x*fn(i+1, x, k) + fn(i+1, x+1, k-1) + fn(i, x+1, k) - (x+1)*fn(i+1, x+1, k)
        
        return fn(0, 0, k) % 1_000_000_007",0
"class Solution:
    def maxScore(self, s: str) -> int:
        s_len = len(s)  
        ''' Length of `s`'''  
        max_score = -1  
        ''' Keep max score during searching'''  
        for i in range(s_len-2, -1, -1):  
            if s[i] != '0':  
                # Skip split on 1  
                continue  
  
            split_left = s[:i+1]  
            ''' Left part after split'''  
            if split_left.count('0') >= split_left.count('1'):  
                # print(""{}: {} {}"".format(s, split_left, s[i+1:]))  
                cur_score =  split_left.count('0') + s[i+1:].count('1')  
                if cur_score > max_score:  
                    max_score = cur_score  
  
        # If mas_score = -1, it means no split at all  
        # So we have to split at least once by minimum cost:  
        # s[:1] + s[1:]  
        # which will lose one '1' and obtain score = s.count('1') - 1   
        return max_score if max_score > 0 else s.count('1') - 1  


sol = Solution()
for s, ans in [
                (""01101"", 4),
                (""110000"", 3),
                (""1011011"", 5),
                (""01001"", 4),
                (""011101"", 5),
                (""00111"", 5),
                (""1111"", 3),
                (""11100"", 2),
                (""0000"", 3),
                (""0100001"", 6)
              ]:
    rel = sol.maxScore(s)
    print(""{}: {}"".format(s, rel))
    assert ans == rel",0
"class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        M = sum(cardPoints[:k])
        temp = M
        for i in range(1, k+1):
            temp += cardPoints[-i]
            temp -= cardPoints[k-i]
            if temp > M:
                M = temp
        
        return M",1
"class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        idx, val = [], []
        for i, row in enumerate(nums):
            for j, num in enumerate(row): 
                idx.append((i+j, -i))
                val.append(num)
        _, ans = zip(*sorted(zip(idx, val)))
        return ans",1
"class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        stk = []
        subsum = 0
        best = float('-inf')
        for idx in range(len(nums)):
            while stk and nums[stk[-1]] < 0  and (len(stk) == 1 or idx - stk[-2] <= k) and nums[stk[-1]] < nums[idx]:
                subsum -= nums[stk.pop()]  # kick out more expensive negative bridge elements
            if nums[idx] > 0 and subsum < 0:
                stk = [idx]
                subsum = nums[idx]  # don't have a negative start
            else:
                stk.append(idx)
                subsum += nums[idx]
            best = max(best, subsum)
            
        return best",0
"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        maxCandy = max(candies)
        boolResult = []
        
        for candy in candies:
            if candy + extraCandies >= maxCandy:
                boolResult.append(True)
            else:
                boolResult.append(False)
        
        return boolResult",1
"class Solution:
    def maxDiff(self, num: int) -> int:
        
        num_string = str(num)
        
        def apply_transform( src_char: str, dest_char: str, s: str):
        
            return int( s.replace( src_char, dest_char ) )
        
        # -----------------------------------------------------------
        
        # digit replacement for maximum number
        
        max_num = num
        
        for char in num_string:
            if char < '9':
                max_num = apply_transform( char, '9', num_string ) 
                break
        
        # -----------------------------------------------------------
        
        # digit replacement for minimum number
        
        min_num = num
        
        if num_string[0] > '1':
            # leading digit cannot be zero
            min_num = apply_transform( num_string[0], '1', num_string )
        
        else:
            for char in num_string[1:]:
                if char > '1':
                    min_num = apply_transform( char, '0', num_string )
                    break
        
        return max_num - min_num",0
"class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        s1, s2 = sorted([char for char in s1]), sorted([char for char in s2])

        return all([s1[i] >= s2[i] for i in range(len(s1))]) or all([s1[i] <= s2[i] for i in range(len(s1))])",0
"class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        N = len(hats) # number of people
        h2p = collections.defaultdict(list) # hat -> people
        for person in range(N):
            for hat in hats[person]:
                h2p[hat].append(person)
                
        if len(h2p) < N: # when the number of hats < the number of people
            return 0
        
		# For each hat, dp stores the status of the people has been matched by a hat.
        # e.g. 0b0000000000 means no one wears a hat
        # 0b0010000000 means only person No.2 wears a hat
        # There are totally 2 ^ N different possible status.
        MASK = [1 << p for p in range(N)]
        dp = [[0] * (2 ** N) for _ in range(len(h2p) + 1)]
        dp[0][0] = 1
        
        i, MOD = 1, 1000000007
        while h2p: # O(H)
            _, people = h2p.popitem()
            for j, n in enumerate(dp[i - 1]): #O(2^P)
                if not n:
                    continue
                
                dp[i][j] += n # when mask = 0
                for p in people: #O(P)
                    if not (MASK[p] &amp; j):
                        dp[i][MASK[p] + j] += n
            i += 1
        
        return dp[-1][-1] % MOD",0
"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        source = set([path[1] for path in paths])
        destination = set([path[0] for path in paths])
        destination_city = source.difference(destination)
        return destination_city.pop()",1
"class Solution:
    def kLengthApart(self, nums, k: int) -> bool:
        prev = -k - 1
        for i in range(len(nums)):
            if nums[i] == 1:
                if i - prev - 1 < k:
                    return False
                prev = i

        return True",1
"class Solution:
    # no need of binary search, described below....
	def solve(self, nums, k):

        def valid(n):
            # slide a window length N
            minq = deque()  # stores (val, index)
            maxq = deque()  # descending

            for r, v in enumerate(nums):
                while maxq and maxq[-1][0] < v:
                    # i replace him as a maximum
                    # candidate in the current window
                    maxq.pop()
                while minq and minq[-1][0] > v:
                    # i replace him as a minimum
                    # candidate in the current window
                    minq.pop()
                # now adding self will maintain property
                maxq.append((v, r))
                minq.append((v, r))

                # lazy pop max/min whom no longer in window
                while maxq and maxq[0][1] <= (r - n):
                    maxq.popleft()
                while minq and minq[0][1] <= (r - n):
                    minq.popleft()

                # check if valid ;)
                # print(' ',maxq,minq)
                if r >= (n - 1) and maxq[0][0] - minq[0][0] <= k:
                    return True

            return False

        l, r = 1, len(nums) + 1
        while l < r:
            n = (l + r) // 2
            print(l, r, n)
            if valid(n):
                l = n + 1
            else:
                r = n
        return l - 1",0
"class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        row=len(mat)
        col=len(mat[0])
        temp=[i for i in mat[0]]
        for i in range(1,row):
            currSum=[]
            for j in range(col):
                for it in range(len(temp)):
                    currSum.append(temp[it]+mat[i][j])
            currSum.sort()
            temp.clear()
            maxSize=min(k,len(currSum))
            for size in range(maxSize):
                temp.append(currSum[size])
        return temp[k-1]",1
"class Solution:
    def buildArray(self, t: List[int], n: int) -> List[str]:
        l=[]
        for i in range(1,t[-1]+1):
            l.append(""Push"")
            if i not in t:
                l.append(""Pop"")
            
        return l",1
"class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        count = 0
        for i in range(len(arr)):
            x = arr[i]
            for k in range(i+1,len(arr)):
                x = x ^ arr[k]
                if x == 0:
                    count = count + (k-i)
        return count",1
"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        tree = dict()
        for fm, to in edges: tree.setdefault(fm, []).append(to)
            
        def fn(i):
            """"""Returns distance and found flag""""""
            dist, found = 0, hasApple[i]
            for j in tree.get(i, []):
                d, f = fn(j)
                dist += 2+d if f else 0
                found |= f
            return dist, found
        
        return fn(0)[0]",1
"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        m, n = len(pizza), len(pizza[0])
        
        prefix = [[0]*(n+1) for _ in range(m+1)] # prefix array 
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
                if pizza[i][j] == ""A"": prefix[i+1][j+1] += 1
                
        @cache
        def fn(i, j, k):
            """"""Return number of ways of cutting pizza[i:][j:] for k people.""""""
            if i == m or j == n: return 0 # out of pizza 
            apples = prefix[-1][-1] - prefix[-1][j] - prefix[i][-1] + prefix[i][j]
            if apples < k+1: return 0 # not enough apple 
            if k == 0: return 1
            
            ans = 0 
            for ii in range(i, m): 
                if prefix[ii+1][-1] - prefix[ii+1][j] - prefix[i][-1] + prefix[i][j]: 
                    ans += fn(ii+1, j, k-1)
            for jj in range(j, n): 
                if prefix[-1][jj+1] - prefix[-1][j] - prefix[i][jj+1] + prefix[i][j]: 
                    ans += fn(i, jj+1, k-1)
            return ans % 1_000_000_007
        
        return fn(0, 0, k-1)",0
"class Solution:
    def maxPower(self, s: str) -> int:
        curr = power = 1
        for i in range(1, len(s)):
            power = max(power, (curr := curr+1 if s[i] == s[i-1] else 1))
        return power",1
"class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
                
        result, seen = [], set()
                
        for num in range(1, n+1):
            for denom in range(num+1, n+1):                
                if (num/denom) not in seen:
                    seen.add(num/denom)
                    result += [f""{num}/{denom}""]
                    
        return result",1
"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        
        def dfs(node,maxval):
            if not node:
                return 0
            
            
            res = 1 if node.val>=maxval else 0
            maxval = max(node.val, maxval)
            res+= dfs(node.left,maxval)
            res+=dfs(node.right, maxval)
            return res
        return dfs(root, root.val)",1
"class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        
        @cache
        def fn(x): 
            """"""Return max integer given target x.""""""
            if x == 0: return 0
            if x < 0: return -inf 
            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))
        
        return str(max(0, fn(target)))",1
"class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        
		# make a pair with start-time and end-time
        homework_interval = zip(startTime, endTime)
        
		# compute the number of busy students by condition judgement
        return sum( ( start <= queryTime <= end ) for start, end in homework_interval )",0
"class Solution:
    def arrangeWords(self, text: str) -> str:
        return "" "".join(sorted(str(text[0].lower()+text[1:]).split(),key=len)).capitalize()",0
"class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        
        # convert to list of sets
        favoriteCompanies = [set(ele) for idx, ele in enumerate(favoriteCompanies)]
        
        # go through all subsets
        result = []
        for index, companies in enumerate(favoriteCompanies):
            
            # a bool whether we will add this set
            add_to_list = True
            
            for other_index, other_companies in enumerate(favoriteCompanies):
                
                # check whether we look at the same set
                if index == other_index:
                    continue
                
                # if we are subset we set add_to_list to false and break
                if companies.issubset(other_companies):
                    add_to_list = False
                    break
                
            # add if we want to
            if add_to_list:
                result.append(index)
                
        return result",1
"class Solution:
    def numPoints(self, points: List[List[int]], r: int) -> int:
        
        def getPointsInside(i, r, n):
            # This vector stores alpha and beta and flag
            # is marked true for alpha and false for beta
            angles = []

            for j in range(n):
                
                if i != j and distance[i][j] <= 2 * r:
                    # acos returns the arc cosine of the complex
                    # used for cosine inverse
                    B = math.acos(distance[i][j] / (2 * r))

                    # arg returns the phase angle of the complex
                    x1, y1 = points[i]
                    x2, y2 = points[j]
                    
                    A = math.atan2(y1 - y2, x1 - x2)
                    
                    alpha = A - B
                    
                    beta = A + B
                    
                    angles.append((alpha, False))
                    
                    angles.append((beta, True))

            # angles vector is sorted and traversed
            angles.sort()
            # count maintains the number of points inside
            # the circle at certain value of theta
            # res maintains the maximum of all count
            cnt, res = 1, 1
            for angle in angles:
                # entry angle
                if angle[1] == False: 
                    cnt += 1
                # exit angle
                else: 
                    cnt -= 1

                res = max(cnt, res)

            return res

        # Returns count of maximum points that can lie
        # in a circle of radius r.
        #a dis array stores the distance between every
        # pair of points
        n = len(points)
        max_pts = n
        distance = [[0 for _ in range(max_pts)] for _ in range(max_pts)]
        for i in range(n - 1):
            for j in range(i + 1, n):
                # abs gives the magnitude of the complex
                # number and hence the distance between
                # i and j
                x1, y1 = points[i]
                x2, y2 = points[j]
                distance[i][j] = distance[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)

        # This loop picks a point p
        ans = 0
        # maximum number of points for point arr[i]
        for i in range(n):
            ans = max(ans, getPointsInside(i, r, n))

        return ans",0
"class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        for i, word in enumerate(sentence.split()):
            if word.startswith(searchWord): return i+1
        return -1",1
"class Solution:
    def maxVowels1(self, s: str, k: int) -> int:
        vowel = {'a','e','i','o','u'}
        maxVowels = 0
        for all_windows in range(len(s) - k+1):
            currentVowels = 0
            for letter in s[all_windows:all_windows + k]:
                if vowel.intersection({letter}):
                    currentVowels+=1
            if currentVowels > maxVowels:
                maxVowels= currentVowels
        return maxVowels",0
"class Solution:
    def pseudoPalindromicPaths (self, root: TreeNode) -> int:
        def dfs(root: TreeNode, bitmap: int) -> int:
            if not root:
                return 0
            bitmap ^= 1 << root.val
            if not root.left and not root.right:
                return int(bitmap &amp; (bitmap - 1) == 0)
            return dfs(root.left, bitmap) + dfs(root.right, bitmap)
        return dfs(root, 0)",0
"class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def fn(i, j): 
            """"""Return max dot product of nums1[i:] and nums2[j:].""""""
            if i == len(nums1) or j == len(nums2): return -inf
            return max(nums1[i]*nums2[j] + fn(i+1, j+1), nums1[i]*nums2[j], fn(i+1, j), fn(i, j+1))
        
        return fn(0, 0)",0
"class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        return Counter(target)==Counter(arr)",0
"class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        return all(bin(i)[2:].zfill(k) in s for i in range(2**k))",0
"class Solution:
    def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        
        def bfs(root, dest):
            
            stack = deque([root])
            seen = set()
            
            while stack:
                
                item = stack.popleft()
                if item == dest:
                    return True
                for child in graph[item]:
                    
                    if child not in seen:
                        seen.add(child)
                        stack.append(child)
            return False
        
        graph = {i: [] for i in range(n)}
        for a, b in prerequisites:
            graph[a].append(b)
         
        res = []
        for a, b in queries:
            
            res.append(bfs(a, b))
        return res",0
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])
        
        
        @cache
        def dfs(row1, col1, row2, col2, n, m):
			
            if (col1 >= m or col1 < 0) or (col2 >= m or col2 < 0) or row1 >= n or row2 >= n: return -math.inf
            
            temp = grid[row1][col1] if row1 == row2 and col1 == col2 else grid[row1][col1] + grid[row2][col2]
            
			# if reached the bottom of the grid then return the temp value
            if row1 == n-1 and row2 == n-1: return temp

            return temp + max(dfs(row1+1, a, row2+1, b, n, m)
                             for a in [col1-1, col1, col1+1]
                             for b in [col2-1, col2, col2+1])

        # one starting point is (0,0) and other is (0,m-1)
        return dfs(0, 0, 0, m-1, n, m)",0
"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        nums.sort()
        return (nums[len(nums)-1] - 1)*(nums[len(nums)-2] - 1)",1
"class Solution:
    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        horizontalCuts.sort()
        verticalCuts.sort()
        
        maxHorizontalArea = max(horizontalCuts[0], h - horizontalCuts[-1])
        maxVerticalArea = max(verticalCuts[0], w - verticalCuts[-1])
        
        for i in range(0, len(horizontalCuts) - 1):
            maxHorizontalArea = max(maxHorizontalArea, horizontalCuts[i + 1] - horizontalCuts[i])
            
        for i in range(0, len(verticalCuts) - 1):
            maxVerticalArea = max(maxVerticalArea, verticalCuts[i + 1] - verticalCuts[i])
        
        return (maxHorizontalArea * maxVerticalArea) % int(1e9 + 7)",0
"class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        visited = set()
        inDegree = collections.defaultdict(list)
        outDegree = collections.defaultdict(set)
        for con in connections:
            outDegree[con[0]].add(con[1])
            inDegree[con[1]].append(con[0])
        cnt = 0
        stack = [0]
        while stack:
            city = stack.pop()
            if city in visited:
                continue
            visited.add(city)
            stack.extend(inDegree[city])
            for c in outDegree[city]:
                if c not in visited:
                    cnt += 1
                    stack.append(c)
        return cnt",1
"class Solution:
    def getProbability(self, balls: List[int]) -> float:
        n = sum(balls)//2
        
        @cache 
        def fn(i, s0, s1, c0, c1):
            """"""Return number of ways to distribute boxes successfully (w/o considering relative order).""""""
            if s0 > n or s1 > n: return 0 # impossible 
            if i == len(balls): return int(c0 == c1)
            ans = 0 
            for x in range(balls[i]+1): 
                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)
            return ans
        
        return fn(0, 0, 0, 0, 0) / comb(2*n, n)",0
"class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        '''Time complexity: Olog(n as specified in the arg), Space complexity: O(1)'''
        
        # To manage space, we can work on the same variable (i.e. modifying in place)
        # We can iterate n times, while popping the last element and inserting in its right position in the same list
        
        for i in range(n, 0, -1):
            nums.insert(i, nums.pop())
            
        return nums",0
"class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        n = len(arr)
        
        if n == 1:
            return arr[:k]
        elif n == k:
            return arr
        
        arr.sort()
        m = arr[(n-1)//2]
        
        res = []
        i, j = 0, n-1
        while i < j:
            if abs(arr[i]-m) > abs(arr[j]-m):
                res.append(arr[i])
                i += 1
            elif abs(arr[i]-m) < abs(arr[j]-m):
                res.append(arr[j])
                j -= 1
            else: # abs(arr[i]-m) == abs(arr[j]-m)
                if arr[i] > arr[j]:
                    res.append(arr[i])
                    i += 1
                elif arr[i] < arr[j]:
                    res.append(arr[j])
                    j -= 1
                else:
                    res.append(arr[i])
                    i += 1
            if len(res) == k:
                return res",0
"class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
    
        # check how many neighbors in initial state
        neighbor = 0
        prev = 0
        for house in houses:
            if house and house != prev:
                prev = house
                neighbor += 1
            
        if neighbor > target: return -1
        
        
        # dp[# index][# color][# neighbor]
        dp = [[[inf] * (target+1) for _ in range(n)] for _ in range(m)]
        if not houses[0]:
            for color in range(n):
                dp[0][color][1] = cost[0][color]
        else:
            dp[0][houses[0]-1][1] = 0
        
        for i in range(1, m):
            for color in range(n):
                for neighbor in range(1, target+1):
                    # i-th house is not painted yet
                    if not houses[i]:
                        # same color with i-1
                        dp[i][color][neighbor] = dp[i-1][color][neighbor] + cost[i][color]
                        # different color with i-1
                        for diff_color in range(n):
                            if color != diff_color:
                                dp[i][color][neighbor] = min(dp[i][color][neighbor], dp[i-1][diff_color][neighbor-1] + cost[i][color])
                    # i-th house is already painted
                    else:
                        if color+1 == houses[i]:
                            dp[i][color][neighbor] = dp[i-1][color][neighbor]
                            for diff_color in range(n):
                                if color != diff_color:
                                    dp[i][color][neighbor] = min(dp[i][color][neighbor], dp[i-1][diff_color][neighbor-1])
                        else:
                            dp[i][color][neighbor] = inf
                                          
        minCost = inf
        for j in range(n):
            minCost = min(minCost, dp[-1][j][target])
        return minCost if minCost != inf else -1",0
"class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
#         each number in the array is a price
#         there is a discount where you will get that i term discounted by the next item in the array that is less than or equal to the current item's price

# you ONLY need to look ahead of i, never before. AND you stop when you've reached that discount amount

        finalSale = []
        
        for i in range(0, len(prices)):
            currentPrice = prices[i]
            discountAmount = 0
            for j in range(i + 1, len(prices)):
                possibleDiscount = prices[j]
                if possibleDiscount <= currentPrice:
                    currentPrice = currentPrice - possibleDiscount
                    break
            finalSale.append(currentPrice)
                    
        return finalSale",1
"class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        complements = {0: -1}
        cum_sum = 0
        intervals = []
        for i, el in enumerate(arr):
            cum_sum += el
            if cum_sum - target in complements:
                intervals.append((complements[cum_sum - target] + 1, i))
            complements[cum_sum] = i 

        if len(intervals) < 2:
            return -1

        intervals.sort(key=lambda x: x[1] - x[0])
        non_overlap_intervals = filter_non_overlap(intervals)

        if not non_overlap_intervals:
            return -1

        return sum(interval[1] - interval[0] + 1 for interval in non_overlap_intervals)


def filter_non_overlap(intervals):
    for i in range(len(intervals)):
        for j in range(i + 1, len(intervals)):
            if not (intervals[i][0] <= intervals[j][1] and intervals[j][0] <= intervals[i][1]):
                return intervals[i], intervals[j]",0
"class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort()
        len_houses = len(houses)
        if k == len_houses:
            return 0
        cost = {**{(i,i): 0 for i in range(len_houses)},
                **{(i,i+1):houses[i+1] - houses[i]  for i in range(len_houses - 1)}}
        for i in range(len_houses):
            for r in range(1,min(i+1,len_houses-i)):
                cost[i-r,i+r] = cost[i-r+1,i+r-1] + houses[i+r] - houses[i-r]
                if i+r + 1 < len_houses:
                    cost[i-r,i+r+1] = cost[i-r+1,i+r] + houses[i+r+1] - houses[i-r]
        dp = {(j,1):cost[0,j] for j in range(len_houses)} # dp(i,k) is total cost of using k mail boxes for first i houses
        for box in range(2, k + 1):
            for j in range(box - 1, len_houses):
                dp[j,box] = min(dp[i,box-1] + cost[i+1,j] for i in range(box - 2, j))
        return dp[len_houses - 1, k]",0
"class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        runningSum = [nums[0]]
        for i in range(1, len(nums)):
            currentSum = 0
            for j in range(i+1):
                currentSum += nums[j]
            runningSum.append(currentSum)
        return runningSum",1
"class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        most_common = Counter(arr).most_common()
        for i in range(len(most_common) - 1, -1, -1):
            if k >= most_common[i][1]:
                k -= most_common[i][1]
            else:
                return i + 1
            
        return 0",1
"class Solution:
    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if len(bloomDay) < m*k:
            return -1
        
        l = 1
        r = max(bloomDay)
        
        while l < r:
            mid = l + (r-l) // 2
            if self.condition(mid,bloomDay,k,m):
                r = mid
            else:
                l = mid+1
        return l
        
        
        
    def condition(self,n,nums,k,m):
        bouquets = 0
        flowers = 0
        for flower in nums:
            if flower <= n:
                bouquets += (flowers + 1) // k
                flowers = (flowers + 1) % k    
            else:
                flowers = 0
                
        return bouquets >= m",0
"class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        k = 0
        for x in range(start, start+(2*n),2):
            k ^= x
        
        return k",1
"class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        d, res = {}, []
        for name in names:
            if name in d:
                orig_name = name
                # get the smallest positive key
                key = d[name]
                while(name in d):
                    name = orig_name + ""({})"".format(key)
                    key += 1
                d[name] = 1
				# memoization done so as to get the latest version of this next time
                d[orig_name] = key
            else:
                d[name] = 1
            res.append(name)
        return res",1
"class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        days = dict() #days of raining for a given lake 
        for d, lake in enumerate(rains): 
            if lake: days.setdefault(lake, deque()).append(d)
            
        ans, hp = [], [] #min-heap 
        full = set() #full lakes
        for d, lake in enumerate(rains): 
            if lake: 
                if lake in full: return []
                full.add(lake)
                days[lake].popleft()
                if days[lake]: heappush(hp, (days[lake][0], lake))
                ans.append(-1)
            else: 
                if hp: 
                    _, lake = heappop(hp)
                    full.remove(lake)
                    ans.append(lake)
                else: 
                    ans.append(1)
        return ans",0
"class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = dict()
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
            
        ref = self.mst(n, graph)
        critical, pseudo = [], []
        for i in range(len(edges)):
            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)
            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)
        return [critical, pseudo]
            
        
    def mst(self, n, graph, init=None, exclude=None):
        """"""Return weight of MST of given graph using Prim's algo""""""

        def visit(u): 
            """"""Mark node and put its edges to priority queue""""""
            marked[u] = True
            for v, w in graph.get(u, []):
                if exclude and u in exclude and v in exclude: continue
                if not marked[v]: heappush(pq, (w, u, v))
                    
        ans = 0
        marked = [False]*n
        pq = [] #min prioirty queue
        
        if init: 
            u, v, w = init
            ans += w
            marked[u] = marked[v] = True
            visit(u) or visit(v)
        else:
            visit(0)

        while pq: 
            w, u, v = heappop(pq)
            if marked[u] and marked[v]: continue
            ans += w
            if not marked[u]: visit(u)
            if not marked[v]: visit(v)
                
        return ans if all(marked) else inf",0
"class Solution:
    def average(self, salary: List[int]) -> float:
        salary.remove(min(salary))
        salary.remove(max(salary))
        avg = 0
        for i in range(0,len(salary)):
            avg += salary[i] 
        
        return float(avg / len(salary))",1
"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        try:
            return list(filter(lambda x:n%x==0,range(1,n+1)))[k-1]
        except:
            return -1",1
"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        sums=0 #Summaries of our streaks before making two mistakes
        sumlist=list() #list of that summaries. So we can find our biggest streak later with max()
         
        if sum(nums)==len(nums): #First of all lets test the case there might be no penalties at all
            return sum(nums)-1
        
        s=0 #Penalty counter. Be careful, 2 penalties and streak is over!
        i=0 #lets start our journey from beginning of our list.
        while i< len(nums):
            if nums[i]==0 and s==0: #First Penalty!(0) You can continue, for now...
                s+=1 #Saving that you already done your first penalty
                p=i #Saving your first penalty's location.
                i+=1 #Go next one!
            elif nums[i]==0 and s!=0: #Second Penalty(0) stop now!!! And tell everything you count by far to 'SUMLIST'
                sumlist.append(sums) #saving your streak...
                s=0  #new beginning no penalties...
                sums=0 #but ofcourse youre starting from bottom
				i=p  #start from your first penalty's location!
                i+=1 #actually next of it. Since its a penalty, its not fair to start with a penalty already
            else:
                sums+=1 #No penalties? Add 1 more to your pocket
                i+=1 #Go next one
        sumlist.append(sums) #There might be only one zero so lets append sums just in case, we will return max of that sumlist so, no problem.
        return max(sumlist) #Returning maximum of our streaks with only one penalty!",0
"class Solution:
    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
        graph = collections.defaultdict(int)
        for x, y in dependencies:
            graph[y] |= 1 << (x - 1) # dependency mask of course y
        last_mask = (1 << n) - 1 # all course
        queue = collections.deque([(0, 0)]) # start with zero course taken
        visited = {0}
        while queue:
            mask, num_semesters = queue.popleft()
			# mask &amp; (1 << (x - 1)) == 0 course have not been taken
			# mask &amp; graph[x] == graph[x] but all its dependency course have been taken
            free_courses = [x for x in range(1, n + 1) if (mask &amp; (1 << (x - 1)) == 0) and mask &amp; graph[x] == graph[x]]
            for courses in itertools.combinations(free_courses, min(k, len(free_courses))):
                new_mask = mask
                for x in courses:
                    new_mask |= 1 << (x - 1)
                if new_mask == last_mask:
                    return num_semesters + 1
                if new_mask not in visited:
                    visited.add(new_mask)
                    queue.append((new_mask, num_semesters + 1))",0
"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        directions = {
            'N': (0,1),
            'E': (1,0),
            'W': (-1,0),
            'S': (0,-1)
        }
        
        s = (0, 0)
        storage = [(0,0)]
        for d in path:
            x,y = s
            i,j = directions[d]
            x, y = x+i, y+j
            s = x,y
            if s in storage:
                return True
            else:
                storage.append(s)
        
        return False",1
"class Solution:
    def canArrange(self, a: List[int], k: int) -> bool:
        d=[0]*k 
        for i in a: 
            d[i%k]+=1 
        for i in range(k):
            if i==0:
                if d[i]%2!=0:
                    return 0
            elif(d[i]!=d[k-i]):
                return 0
        return 1",1
"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        nums.sort()
        
        ans = 0
        lo, hi = 0, len(nums)-1
        while lo <= hi: 
            if nums[lo] + nums[hi] > target: hi -= 1
            else: 
                ans += pow(2, hi - lo, 1_000_000_007)
                lo += 1
        
        return ans % 1_000_000_007",1
"class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        deque = collections.deque()
        res = -math.inf

        for point in points:
            x, y = point[0], point[1]
            
            while deque and x - deque[0][0] > k:
                deque.popleft()
            
            if deque:
                res = max(res, (y + deque[0][1]) + (x - deque[0][0]))
            
            # while deque AND any equation including (x, y) will always yield a greater
			# (or ==) result than any equation including (deque[-1][0], deque[-1][1])
            while deque and (deque[-1][0] - x) + (y - deque[-1][1]) >= 0:
                deque.pop()
            
            deque.append(point)
        
        return res",0
"class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        diff=arr[0]-arr[1]
        for i in range(1,len(arr)-1):
            if arr[i]-arr[i+1]!=diff:
                return False
        else:
            return True",1
"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        left_max = max(left) if left else 0
        right_max = n - min(right) if right else 0
        return max(left_max, right_max)",0
"class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        n,m = len(mat), len(mat[0])
        nums = []
        for i in range(n):
            num = []
            for j in range(m-1,-1,-1):
                if mat[i][j] == 0:
                    num = [0] + num
                elif mat[i][j] == 1 and j == m-1:
                    num = [1] + num
                elif mat[i][j] == 1 and j != m-1:
                    num = [1 + num[0]] + num
            nums.append(num)
        ans = 0
        for i in range(n):
            for j in range(m):
                x = m + 1
                for k in range(i,n):
                    x = min(x,nums[k][j])
                    ans += x
        return ans",0
"class Solution:
    def minInteger(self, num: str, k: int) -> str:
        n = len(num)
        if k >= n*(n-1)//2: return """".join(sorted(num)) #special case
        
        #find smallest elements within k swaps 
        #and swap it to current position 
        num = list(num)
        for i in range(n):
            if not k: break 
            #find minimum within k swaps
            ii = i
            for j in range(i+1, min(n, i+k+1)): 
                if num[ii] > num[j]: ii = j 
            #swap the min to current position 
            if ii != i: 
                k -= ii-i
                for j in range(ii, i, -1):
                    num[j-1], num[j] = num[j], num[j-1]
        return """".join(num)",0
"class Solution:
    def reformatDate(self, date: str) -> str:
        month, date = {""Jan"":""01"", ""Feb"":""02"", ""Mar"":""03"", ""Apr"":""04"", ""May"":""05"", ""Jun"":""06"", ""Jul"":""07"", ""Aug"":""08"", ""Sep"":""09"", ""Oct"":""10"", ""Nov"":""11"", ""Dec"":""12""}, date.split()
        return date[2] + '-' + month[date[1]] + '-' + ''.join(['0']+[d for d in date[0] if d.isdigit()])[-2:]",0
"class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        ans = [nums[0]]
        for i in range(1, n):
            ans.append(nums[i])    
            nums[i] += nums[i-1]
            ans.append(nums[i])    
            for j in range(i-1): ans.append(nums[i] - nums[j])
        ans.sort()                
        return sum(ans[left-1:right]) % 1000000007",1
"class Solution:
    def minDifference(self, nums: List[int]) -> int:
        heapq.heapify(nums)
        return min(map(lambda x, y: x-y, heapq.nlargest(4,nums), heapq.nsmallest(4,nums)[::-1]))",0
"class Solution:
    def __init__(self):
        self.cache = {}
    
    def winnerSquareGame(self, n: int) -> bool:
        if not n: return False
        if n in self.cache:
            return self.cache[n]
        i = int(math.sqrt(n))
        while i >= 1:
            if not self.winnerSquareGame(n - i*i):
                self.cache[n] = True
                return self.cache[n]
            i -= 1
        self.cache[n] = False
        return self.cache[n]",1
"class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        repetitions = {}

        for value in nums:
            repetitions[value] = repetitions.get(value, -1) + 1
        
        return sum((v*(v+1))//2 for v in repetitions.values())",1
"class Solution:
    def numSub(self, s: str) -> int:
        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split('0')))",0
"class Solution:
	def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        edge_prob=[]
        for i in range(n):
            edge_prob.append([])
        for i in range(len(edges)):
            edge_prob[edges[i][0]].append([edges[i][1],succProb[i]])
            edge_prob[edges[i][1]].append([edges[i][0],succProb[i]])
        
        prob=[0]*n
        pq=[]
        pq.append((-1,start))
        while pq:
            current=heapq.heappop(pq)
            if prob[current[1]]==0:
                prob[current[1]]=-current[0]
                for neighbor in edge_prob[current[1]]:
                    heapq.heappush(pq,(-neighbor[1]*prob[current[1]],neighbor[0]))
                if current[1]==end:
                    break
        return prob[end]",0
"class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        #euclidean distance 
        fn = lambda x, y: sum(sqrt((x-xx)**2 + (y-yy)**2) for xx, yy in positions)
        #centroid as starting point
        x = sum(x for x, _ in positions)/len(positions)
        y = sum(y for _, y in positions)/len(positions)
        
        ans = fn(x, y)
        chg = 100 #change since 0 <= positions[i][0], positions[i][1] <= 100
        while chg > 1e-6: #accuracy within 1e-5
            zoom = True
            for dx, dy in (-1, 0), (0, -1), (0, 1), (1, 0):
                xx = x + chg * dx
                yy = y + chg * dy
                dd = fn(xx, yy)
                if dd < ans: 
                    ans = dd 
                    x, y = xx, yy
                    zoom = False 
                    break 
            if zoom: chg /= 2
        return ans",0
"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        total = numBottles
        p = numBottles
        
        while p >= numExchange:
            p_int = p // numExchange
            p_rem = p % numExchange
            p = p_int + p_rem
            total += p_int
        
        return total",1
"class Solution:
    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        graph = self.build_graph(edges)
        res = [0] * n
        visited = set()
		
        def add(seen1, seen2):
            seen = [0] * 26
            for i in range(26):
                seen[i] = seen1[i] + seen2[i]
            return seen
        
        def index(char):
            return ord(char) - ord('a')
        
        def dfs(node):
		    # Maintain a visited since the edge is represented in both directions in the graph
            visited.add(node)
            seen = [0] * 26
            for neigh in graph.get(node, []):
                if not neigh in visited:
                    seen = add(seen, dfs(neigh))
                
            seen[index(labels[node])] += 1
            res[node] = seen[index(labels[node])]
            return seen
        
        dfs(0)
        return res
        
    def build_graph(self, edges):
        graph = {}
        for edge in edges:
		     # Include edges in both directions since ordering of edges is not guaranteed
			 # e.g. case [[0, 2], [0, 3], [1, 2]]
			 # In above example we should traverse from 2 to 1.
            graph.setdefault(edge[0], []).append(edge[1])
            graph.setdefault(edge[1], []).append(edge[0])
        return graph",0
"class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        
        # record last index(+1) and interval relations
        last, interval = {}, {}
        for i, c in enumerate(s):
            last[c] = i + 1
            if c not in interval:
                interval[c] = set(''.join(s.split(c)[1:-1]))
        
        # union-find
        parent = {c: c for c in s}
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = find(y)
            return
        
        for c in interval:
            for n in interval[c]:
                if c in interval[n]:
                    union(c, n)
        
        # cut and remove redundant character
        splits, max_splits = [(s, 0)], []
        
        while splits:
            
            # cut
            splits_cut = []
            for string, start in splits:
                left = right = 0 
                for i, c in enumerate(string):
                    right = max(right, last[c] - start)
                    if i == right - 1:
                        splits_cut.append((string[left:right], start + left))
                        left = right
            
            # remove redundant
            splits_rem = []
            for string, start in splits_cut:
                len_splits_rem = len(splits_rem)
                redundant = find(string[0])
                
                left = 0
                while left < len(string):
                    if find(string[left]) == redundant:
                        left += 1
                    else:
                        right = left
                        while right < len(string) and find(string[right]) != redundant:
                            right += 1
                        splits_rem.append((string[left:right], start + left))
                        left = right

                if len_splits_rem == len(splits_rem):
                    max_splits.append(string)

            splits = splits_rem
        
        return max_splits",0
"class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while n > m: 
            n &amp;= n-1 #unset last set bit
        return n",1
"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if low % 2 == 0:
            low += 1
        return (((high - low)//2) + 1)",1
"class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        freq = [1, 0]
        ans = prefix = 0
        for x in arr: 
            prefix += x 
            ans += freq[1 ^ prefix&amp;1]
            freq[prefix&amp;1] += 1
        return ans % 1_000_000_007",1
"class Solution:
    def numSplits(self, s: str) -> int:
        tail_d, head_d, ans = {}, {}, 0
        
        def add_c(d, c):
            if c not in d:
                d[c] = 1
            else:
                d[c] += 1
                
        def remove_c(d, c):
            n = d[c]
            n -= 1
            if n == 0:
                del d[c]
            else:
                d[c] = n
                                
        def is_same(d1, d2):
            return len(d1) == len(d2)
        
        # 0) Initialize tail_d
        for c in s:
            add_c(tail_d, c)
            
            
        # 1) Start searching number of good ways of split        
        for c in s:
            remove_c(tail_d, c)
            add_c(head_d, c)
            if is_same(tail_d, head_d):
                ans += 1
        
            if len(tail_d) < len(head_d):
                break
                
        # 3) Return the answer
        return ans",0
"class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ans = 0 
        stack = [] # increasing stack
        for x in target: 
            while stack and stack[-1] >= x: 
                ans += stack.pop() - max(x, (stack or [0])[-1])
            stack.append(x)
        prev = 0
        for x in stack: 
            ans += x - prev 
            prev = x
        return ans",1
"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        fs = ''
        num = 0
        for i in range(len(indices)):
            ind = indices.index(num)
            fs += s[ind]
            num += 1
        return fs",1
"class Solution:
    def minFlips(self, target: str) -> int:

        count = 0
        checkfor = 1

        for i in range(len(target)):
            if int(target[i]) == checkfor:
                count += 1
                checkfor ^= 1

        return count",1
"class Solution:
    def __init__(self):
        self.res = 0
        
    def traversal(self, node, dist):
        if not node:
            return []
        
        if not node.left and not node.right:
            return [1]
        
        dists_from_left = self.traversal(node.left, dist)
        dists_from_right = self.traversal(node.right, dist)
        
        for ld in dists_from_left:
            for rd in dists_from_right:
                if ld + rd <= dist:
                    self.res += 1
        
        return [d + 1 for d in dists_from_left + dists_from_right if d < dist]
        
        
    def countPairs(self, root: TreeNode, distance: int) -> int:
        self.traversal(root, distance)
        
        return self.res",1
"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        # Find min lenth of the code starting from group ind, if there are res_k characters to delete and 
		#       group ind needs to be increased by carry_over additional characters
        def FindMinLen(ind, res_k, carry_over=0): 
            
            # If we already found the min length - just retrieve it (-1 means we did not calculate it)
            if carry_over == 0 and dynamic[ind][res_k] != -1:
                return dynamic[ind][res_k]
            
            # Number of character occurences that we need to code. Includes carry-over.
            cur_count = carry_over + frequency[ind]

            # Min code length if the group ind stays intact. The code accounts for single-character ""s0"" vs. ""s""  situation.
            min_len = 1 + min(len(str(cur_count)), cur_count - 1) + FindMinLen(ind+1,res_k)

            # Min length if we keep only 0, 1, 9, or 99 characters in the group - delete the rest, if feasible
            for leave_count, code_count in [(0,0), (1, 1), (9, 2), (99, 3)]:
                if cur_count > leave_count and res_k >= cur_count - leave_count:
                    min_len = min(min_len, code_count + FindMinLen(ind + 1,res_k - (cur_count - leave_count)))

            # If we drop characters between this character group and next group, like drop ""a"" in ""bbbabb""
            next_ind = chars.find(chars[ind], ind + 1)
            delete_count = sum(frequency[ind+1:next_ind])
            if next_ind > 0 and res_k >= delete_count:
                min_len = min(min_len, FindMinLen(next_ind, res_k - delete_count, carry_over = cur_count))

            # If there was no carry-over, store the result
            if carry_over == 0: dynamic[ind][res_k] = min_len
            return min_len
        
        # Two auxiliary lists - character groups (drop repeated) and number of characters in the group
        frequency, chars = [], """"
        for char in s:
            if len(frequency)==0 or char != chars[-1]:
                frequency.append(0)
                chars = chars + char
            frequency[-1] += 1
        
        # Table with the results. Number of character groups by number of available deletions.  
        dynamic = [[-1] * (k + 1) for i in range(len(frequency))] + [[0]*(k + 1)]
        
        return FindMinLen(0, k)",0
"class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        length=len(arr)
        count=0
        for i in range(length):
            for j in range(i+1,length):
                for k in range(j+1,length):
                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        count+=1
                    else:
                        continue
                            
        return count",0
"class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        n = len(arr)
        winningInteger = arr[0]
        winCount = 0
        for i in range(1, n):
            if winningInteger > arr[i]:
                winCount += 1
            else:
                winningInteger = arr[i]
                winCount = 1
            if winCount == k:
                return winningInteger
        return winningInteger",1
"class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]
        n = len(grid)

        res = 0
        for i in range(n):
            for j in range(i, n):
                if A[j] >= n - 1 - i:
                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]
                    res += j - i
                    break
            else:
                return -1
        
        return res",1
"class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        i = j = score1 = score2 = maxScore = 0
        m, n = len(nums1), len(nums2)
        MOD = 10 ** 9 + 7
        
        while i < m and j < n:
            if nums1[i] < nums2[j]:
                score1 += nums1[i]
                i += 1
            elif nums1[i] > nums2[j]:
                score2 += nums2[j]
                j += 1
            else:
                maxScore += nums1[i] + max(score1, score2)
                maxScore %= MOD
                score1 = score2 = 0
                i += 1
                j += 1
        
        while i < m:
            score1 += nums1[i]
            i += 1
        while j < n:
            score2 += nums2[j]
            j += 1
        
        maxScore += max(score1, score2)
        return maxScore % MOD",0
"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        check = [True]*2001
        for e in arr:
            check[e] = False
        ind = 1
        for i in range(k):
            while check[ind]==False:
                ind+=1
            ind+=1
        return ind-1",1
"class Solution:
    def canConvertString(self, s: str, t: str, k: int) -> bool:
        if len(s)!=len(t):return False
        
        lookup=collections.defaultdict(int)
        for i in range(len(s)):
            if s[i]!=t[i]:
                char = ord(t[i])-ord(s[i])
                if char<0:char+=26
                lookup[char] += 1        
        
        keys = sorted(lookup.keys())
        for key in keys:
            temp=key
            if key<k:
                lookup[key]-=1
                while lookup[key]:
                    temp+=26
                    if temp>k:break
                    if temp<=k:
                        lookup[key]-=1
            if temp>k or key>k:return False
        return True",0
"class Solution:
    def minInsertions(self, s: str) -> int:
        stack = []
        ret = 0
        for c in s:
            if c == '(':
                if stack and not stack[- 1]:
                    ret += 1
                    stack.pop()
                stack.append(1)
            else:
                if not stack:
                    ret += 1
                    stack.append(1)
                if stack[- 1]:
                    stack[- 1] -= 1
                else:
                    stack.pop()
        while stack:
            ret += 1 + stack.pop()
        return ret",1
"class Solution:
    def longestAwesome(self, s: str) -> int:
        ans = prefix = 0
        seen = {0: -1}
        for i, c in enumerate(s):
            prefix ^= 1 << int(c) #toggle bit 
            ans = max(ans, i - seen.get(prefix, inf))
            for k in range(10): 
                x = prefix ^ (1 << k) #toggle kth bit 
                ans = max(ans, i - seen.get(x, inf))
            seen.setdefault(prefix, i)
        return ans",0
"class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        '''
        length pattern:
            1-1
            2-2*1+1=3=2**2-1
            3-2*3+1=7=2**3-1
            4-2*7+1=15=16-1=2**4-1
            n-2**n-1
        k-th bit:
            k<2**(n-1)
        '''
        def helper(n,k):
            if n==1:
                return 0
            elif k==2**(n-1):
                return 1
            elif k<2**(n-1):
                return helper(n-1,k)
            else:
                return 1-helper(n-1,2**(n-1)-(k-2**(n-1)))
        return str(helper(n,k))",1
"class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        
        moddict = {}
        moddict[0] = 0
        
        res = 0  # value to be returned
        
        cnt = 1
        s = 0 
        
        for num in nums:
            s += num
            if s-target in moddict:
                res += 1
                moddict = {}
            moddict[s] = cnt
            
            cnt += 1
        return res",1
"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        # Function to make cut
        def makeCut(start, end, t=dict()):
            
            # Make key
            key = (start, end)
            
            # If key doesn't exist
            if key not in t:
            
                # Init
                currMin = float(""inf"")

                # For all cuts
                for cut in cuts:

                    # If cuts exist between the start and end, it's a valid cut.
                    if start < cut < end:

                        # Get the current cost of the cut 
                        cost = end - start

                        # Update currMin
                        currMin = min(currMin, cost + makeCut(start, cut, t) + makeCut(cut, end, t))

                # Update the currenty key, if nothing is processed, the value is 0
                t[key] = currMin if currMin != float(""inf"") else 0
            
            # return the current key
            return t[key]
        
        return makeCut(0,n)",1
"class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        return any(a % 2 == b % 2 == c % 2 == 1 for a, b, c in zip(arr, arr[1:], arr[2:]))",0
"class Solution:
    def minOperations(self, n: int) -> int:
        k=[]
        val = [j for j in range(n)]
        arr = list(map(lambda i:((2*i)+1),val))
        avg = int((sum(arr))/n)
        for s in arr:
            if s<avg:                
                k.append(avg-s) 
        return(sum(k))",1
"class Solution:
    def maxDistance(self, A, n):
        A.sort()
        L    = len(A)
        lo   = 1
        hi   = (A[-1]-A[0])//(n-1)
        best = 1
        n   -= 1
        def valid(mid):
            prev = A[0]
            i    = 0
            for j in range(n):
                d = prev + mid
                while i<L and A[i]<d:
                    i += 1
                if i==L:
                    return False
                prev = A[i]
            return True
        
        while lo<=hi:
            mid = (lo+hi) >> 1
            if valid(mid):
                best = mid
                lo   = mid + 1
            else:
                hi = mid - 1
        
        return best",1
"class Solution:
    def minDays(self, n: int) -> int:
        memo = dict()
        def minimumDays(n):
            if n in memo:
                return memo[n]
            
            if n == 1:
                return 1
            if n== 2 or n == 3:
                return 2
            
            memo[n] = min(n%2+minimumDays(n//2)+1, n%3+minimumDays(n//3)+1)
            
            return memo[n]
        
        return minimumDays(n)",1
"class Solution:
    def thousandSeparator(self, n: int) -> str:
        n=str(n)
        res=""""
        if len(str(n)) <4:
            return str(n)
        count=0
        for i in range(len(n)-1,-1,-1):

            if count<3:
                res+=str(n[i])
                count+=1
            if count==3 and i!=0:
                res+="".""
                
                count=0
        return str(res[::-1])",1
"class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        d = {}
        ans = []
        for x,y in edges:
            if y not in d:
                d[y] = [x]
            else:
                d[y].append(x)
        
        for x in range(n):
            if x not in d:
                ans.append(x)
        
        return ans",1
"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        return sum(bin(x).count(""1"") for x in nums) + len(bin(max(nums))) - 3",0
"class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        sets_vals = defaultdict(set)
        for r, row in enumerate(grid):
            for c, v in enumerate(row):
                sets_vals[v].add((r, c))
        for _, set_val in sets_vals.items():
            while set_val:
                chain_len = 0
                start = set_val.pop()
                neighbours = {start}
                chain = {start: (chain_len, tuple())}
                while neighbours:
                    chain_len += 1
                    new_neighbours = set()
                    for r, c in neighbours:
                        for new_cell in [(r + 1, c), (r - 1, c), (r, c + 1),
                                         (r, c - 1)]:

                            if (new_cell in chain and
                                    new_cell != chain[(r, c)][1] and
                                    chain[new_cell][0] + chain_len > 3):
                                return True

                            if new_cell in set_val:
                                chain[new_cell] = (chain_len, (r, c))
                                new_neighbours.add(new_cell)
                                set_val.remove(new_cell)

                    neighbours = new_neighbours
        return False",0
"class Solution:
    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
        for i in range(len(rounds)-1):
            a, b = rounds[i],rounds[i+1]
            if a < b:
                for j in range(a+1,b):
                    rounds.append(j)
            else:
                for j in range(a+1,n+1):
                    rounds.append(j)
                for j in range(1,b):
                    rounds.append(j)
        m = 0
        v = []
        d = Counter(rounds)
        for i in d:
            if d[i] > m-1:
                v.append(i)
                m = d[i]
        return sorted(v)",0
"class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        if len(piles) == 0:
            return 0

        piles.sort()
        
        len_piles = len(piles)
        cnt = 0
        for i in range(len_piles - 2, len_piles //3 -1, -2):
            cnt += piles[i]
        return cnt",1
"class Solution:
    def findLatestStep(self, arr: List[int], m: int) -> int:
        span = [0]*(len(arr)+2)
        freq = [0]*(len(arr)+1)
        ans = -1
        for i, x in enumerate(arr, 1): 
            freq[span[x-1]] -= 1
            freq[span[x+1]] -= 1
            span[x] = span[x-span[x-1]] = span[x+span[x+1]] = 1 + span[x-1] + span[x+1]
            freq[span[x]] += 1
            
            if freq[m]: ans = i
        return ans",1
"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        # prefix sum 
        prefix = [0]
        for x in stoneValue: prefix.append(prefix[-1] + x)
        
        @lru_cache(None)
        def fn(lo, hi):
            """"""Return the score of arranging values from lo (inclusive) to hi (exclusive). """"""
            if lo+1 == hi: return 0 
            val = 0
            for mid in range(lo+1, hi): 
                lower = prefix[mid] - prefix[lo]
                upper = prefix[hi] - prefix[mid]
                if lower < upper: val = max(val, lower + fn(lo, mid))
                elif lower > upper: val = max(val, upper + fn(mid, hi))
                else: val = max(val, lower + max(fn(lo, mid), fn(mid, hi)))
            return val 
                
        return fn(0, len(stoneValue))",0
"class Solution:
    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
        i=0
        d=m
        if m >len(arr) or k >len(arr):
            return(False)
        while d < len(arr):    
            p=arr[i:d]
            count=1
            j,l=i+m,d+m
            while l<len(arr)+1:
                if arr[j:l]==p:
                    count+=1
                else:
                    break
                if count>=k:
                    return(True)
                    break
                j+=m
                l+=m
            i+=1
            d+=1
        return(False)",0
"class Solution:
    
    @staticmethod
    def process(st, end, cnt_neg, arr):
        if st >= 0 and st <= end and end >= 0:
            if not (cnt_neg % 2):
                return end - st + 1
            first_neg_ind = st 
            last_neg_ind = end
            while(first_neg_ind <= end and arr[first_neg_ind] >= 0):
                first_neg_ind += 1
            while(last_neg_ind >= st and arr[last_neg_ind] >= 0):
                last_neg_ind -= 1
            print((st, end, first_neg_ind, last_neg_ind))
            return max(last_neg_ind - st, end - first_neg_ind)
            
        return 0
    
    def getMaxLen(self, nums: List[int]) -> int:
        prev = 0
        ans = 0
        cnt_neg = 0
        for i in range(len(nums)):
            if not nums[i]:
                ans = max(ans, Solution.process(prev, i-1, cnt_neg, nums))
                prev = i + 1
                cnt_neg = 0
            if nums[i] < 0:
                cnt_neg += 1
        ans = max(ans, Solution.process(prev, len(nums)-1, cnt_neg, nums))
        return ans",0
"class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        grid = """".join("""".join(map(str, x)) for x in grid)
        
        @lru_cache(None)
        def fn(s): 
            """"""Return True if grid is disconnected.""""""
            row, grid = [], []
            for i, c in enumerate(s, 1):
                row.append(int(c))
                if i%n == 0: 
                    grid.append(row)
                    row = []
                    
            def dfs(i, j): 
                """"""""""""
                grid[i][j] = 0
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: dfs(ii, jj)
                return 1
            return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j])
        
        #bfs 
        queue = [grid]
        level = 0 
        seen = {grid}
        while queue: 
            tmp = []
            for node in queue: 
                if fn(node) == 0 or fn(node) >= 2: return level 
                for i in range(m*n):
                    if node[i] == ""1"": 
                        nn = node[:i] + ""0"" + node[i+1:]
                        if nn not in seen: 
                            seen.add(nn)
                            tmp.append(nn)
            queue = tmp
            level += 1",0
"class Solution:
      

    def numOfWays(self, nums: List[int]) -> int:
        FACT = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460, 57155068, 943272305, 14530444, 523095984, 354551275, 472948359, 444985875, 799434881, 776829897, 626855450, 954784168, 10503098, 472639410, 741412713, 846397273, 627068824, 726372166, 318608048, 249010336, 948537388, 272481214, 713985458, 269199917, 75195247, 286129051, 595484846, 133605669, 16340084, 996745124, 798197261, 286427093, 331333826, 536698543, 422103593, 280940535, 103956247, 172980994, 108669496, 715534167, 518459667, 847555432, 719101534, 932614679, 878715114, 661063309, 562937745, 472081547, 766523501, 88403147, 249058005, 671814275, 432398708, 753889928, 834533360, 604401816, 187359437, 674989781, 749079870, 166267694, 296627743, 586379910, 119711155, 372559648, 765725963, 275417893, 990953332, 104379182, 437918130, 229730822, 432543683, 551999041, 407899865, 829485531, 925465677, 24826746, 681288554, 260451868, 649705284, 117286020, 136034149, 371858732, 391895154, 67942395, 881317771, 114178486, 473061257, 294289191, 314702675, 79023409, 640855835, 825267159, 333127002, 640874963, 750244778, 281086141, 979025803, 294327705, 262601384, 400781066, 903100348, 112345444, 54289391, 329067736, 753211788, 190014235, 221964248, 853030262, 424235847, 817254014, 50069176, 159892119, 24464975, 547421354, 923517131, 757017312, 38561392, 745647373, 847105173, 912880234, 757794602, 942573301, 156287339, 224537377, 27830567, 369398991, 365040172, 41386942, 621910678, 127618458, 674190056, 892978365, 448450838, 994387759, 68366839, 417262036, 100021558, 903643190, 619341229, 907349424, 64099836, 89271551, 533249769, 318708924, 92770232, 420330952, 818908938, 584698880, 245797665, 489377057, 66623751, 192146349, 354927971, 661674180, 71396619, 351167662, 19519994, 689278845, 962979640, 929109959, 389110882, 98399701, 89541861, 460662776, 289903466, 110982403, 974515647, 928612402, 722479105, 218299090, 96415872, 572421883, 774063320, 682979494, 693774784, 611379287, 166890807, 880178425, 837467962, 705738750, 616613957, 338771924, 497191232, 896114138, 560652457, 661582322, 224945188, 262995829, 859081981, 857116478, 279856786, 408062844, 406076419, 367193638, 985761614, 767884817, 77737051, 801784560, 410447512, 813374614, 702909132, 777826615, 11426636, 685259446, 721228129, 931065383, 593559607, 860745086, 578819198, 495425745, 893029457, 6156532, 502193801, 37480384, 220174401, 383076669, 3013247, 750298503, 574624441, 230733683, 144887710, 656590378, 773954850, 358485371, 772254339, 469363737, 95843299, 823414273, 87709482, 892174648, 749756145, 185864756, 68295241, 98238739, 131504392, 111672419, 928208089, 687974198, 753032165, 71715287, 506557931, 290314197, 546089425, 174590825, 187067364, 817659471, 309331349, 303445769, 964814732, 112937795, 848457973, 113604679, 263728612, 162653895, 519013648, 956915940, 591788795, 26960558, 818561771, 201473695, 830318534, 283328761, 298655153, 103269519, 567777414, 629890782, 707451727, 528064896, 419467694, 259775012, 452053078, 972081682, 512829263, 412924123, 354780756, 917691336, 648929514, 519218426, 957710940, 848100261, 607279584, 78508462, 651656900, 271922065, 927371945, 976904514, 655633282, 147015495, 44958071, 431540693, 956102180, 821001984, 4640954, 508310043, 709072863, 866824584, 318461564, 773853828, 371761455, 53040744, 609526889, 972452623, 799173814, 723225821, 3874155, 305590228, 289496343, 139259591, 348260611, 756867525, 848691744, 101266155, 835557082, 267191274, 448180160, 518514435, 443022120, 614718802, 151579195, 204297074, 912569551, 137049249, 515433810, 979001276, 524451820, 229298431, 88837724, 892742699, 387369393, 840349900, 206661672, 18186411, 619853562, 246548548, 236767938, 893832644, 930410696, 321544423, 971435684, 402636244, 780681725, 194281388, 661238608, 964476271, 643075362, 439409780, 96895678, 723461710, 915447882, 785640606, 114709392, 933696835, 539582134, 739120141, 300372431, 244129985, 722433522, 26638091, 388855420, 42468156, 647517040, 474194942, 832805846, 958306874, 489519451, 339220689, 9833277, 923477502, 390998217, 790283925, 694135631, 736657340, 609563281, 873127083, 489593220, 264439147, 891171227, 489029295, 502009550, 325923608, 280525558, 857054649, 820622208, 558213940, 216997416, 487921842, 951328535, 606653379, 794417402, 449723904, 783486165, 414645478, 809681447, 114612567, 824953206, 255016498, 147060381, 88903008, 228293174, 394357308, 362355866, 900088886, 638573794, 779598451, 904922263, 451026166, 549459329, 212643744, 563246709, 391796933, 174243175, 189725986, 238337196, 60051478, 782959006, 982673239, 237607992, 685987666, 694447544, 195840153, 519748540, 446086975, 523485236, 185780714, 716004996, 214280883, 140643728, 555470704, 516522055, 116665689, 899547947, 490696549, 683197147, 686671136, 988747143, 744912554, 619072836, 345158054, 224284246, 637879131, 78947725, 342273666, 237716550, 915360466, 711578771, 423071394, 228124918, 271834959, 480779410, 254894593, 859192972, 990202578, 258044399, 151532640, 644862529, 48049425, 448119239, 130306338, 850105179, 401639970, 606863861, 183881380, 837401090, 513536652, 714177614, 946271680, 243293343, 403377310, 688653593, 15447678, 754734307, 631353768, 202296846, 159906516, 912696536, 737140518, 467380526, 896686075, 309895051, 356369955, 461415686, 706245266, 10064183, 183054210, 455971702, 737368289, 956771035, 564163693, 365118309, 226637659, 304857172, 440299843, 717116122, 485961418, 615704083, 476049473, 354119987, 329471814, 620060202, 251964959, 45357250, 175414082, 671119137, 48735782, 122378970, 717506435, 18459328, 949577729, 771970076, 635808197, 608040366, 165916428, 258536202, 902229110, 617090616, 548564593, 613394864, 753777984, 577888302, 416452176, 881599549, 524547188, 599140122, 522765386, 657552586, 256787840, 287613719, 776067801, 597965522, 458655497, 764387515, 350167935, 494713961, 513386012, 576480762, 864589772, 86987059, 495636228, 512647986, 721997962, 982831380, 162376799, 204281975, 462134806, 189646394, 425968575, 209834628, 494248765, 664281698, 947663843, 540352769, 25662122, 986679150, 207298711, 477043799, 24708053, 528335066, 189351697, 717500453, 42764755, 316734785, 823726196, 293357001, 547414377, 258966410, 602945692, 561521296, 351253952, 752369730, 174204566, 871148004, 302242737, 554611874, 540181425, 349941261, 414343943, 921115587, 959388563, 227019335, 708812719, 793380997, 342547759, 324322556, 458370547, 356254978, 809319893, 159690374, 848340820, 971304725, 180230004, 103061704, 207441144, 443272953, 45593686, 541647240, 612817107, 849140508, 109375794, 906749744, 159084460, 541378020, 692284266, 908221578, 720697998, 363923522, 819281897, 701846632, 479994712, 196613531, 29272489, 792937812, 859009553, 202148261, 385627435, 115321267, 612859231, 132778909, 173511339, 782369566, 322583903, 324703286, 31244274, 433755056, 109559692, 871157455, 350443931, 592104988, 197184362, 141678010, 649163959, 746537855, 954594407, 850681817, 703404350, 467293824, 684978431, 565588709, 378843675, 825260479, 749777538, 850502015, 387852091, 412307507, 307565279, 914127155, 864079609, 845970807, 414173935, 638273833, 664477235, 173471099, 480759791, 839694748, 190898355, 956270620, 957911348, 43002811, 628936576, 966234409, 667971950, 236586166, 954211897, 223051884, 21058295, 656573222, 631532535, 809706350, 984734695, 314281677, 311454037, 640732448, 434907794, 175084834, 434807109, 973816812, 488481268, 844735329, 917344075, 314288693, 459259162, 992521062, 667512257, 603748166, 679935673, 833938466, 933875943, 522922384, 981191471, 457854178, 112860028, 484939649, 611363777, 627371454, 844300972, 962501388, 738504183, 631041465, 29224765, 334078303, 211237785, 626057542, 900175080, 728504100, 450509755, 575177363, 905713570, 416609984, 874776027, 334255451, 683287462, 999293262, 474888472, 317020697, 180417613, 591538360, 879151833, 605566485, 569294094, 970567518, 896200922, 943088633, 145735679, 884701203, 949403596, 749113557, 78958680, 850679027, 665376978, 686499745, 426302291, 842343474, 708066168, 962548572, 349652428, 833757979, 492365420, 136639914, 76093131, 591710464, 208764552, 166233017, 498121245, 545840935, 26721664, 736011124, 880639351, 137410283, 42609708, 235572009, 981737748, 718913567, 909319027, 906112184, 298059463, 274736280, 217450848, 351267027, 149682364, 249066734, 11785215, 333890217, 774940233, 302540697, 519852435, 802535369, 620684620, 306323295, 752310997, 848793393, 883503040, 569433124, 254795373, 855478464, 660158704, 87911700, 944741410, 351053939, 2634663, 134077016, 736459220, 4882454, 969435081, 120150411, 922584286, 828772112, 106810765, 371205161, 17024731, 960279329, 389323593, 23991206, 744762405, 684217429, 479374977, 963728237, 3246420, 688035746, 381629444, 752436308, 274567573, 440219140, 702541058, 919238277, 563955926, 467150839, 5249506, 399086000, 833151662, 847391187, 655983283, 337920422, 866913758, 675206635, 549602585, 963783662, 324756002, 393087771, 731515248, 787956453, 550936813, 398161393, 631665856, 442637251, 454846959, 348994181, 88011024, 513458067, 60476466, 9760396, 403700900, 990173371, 519613195, 945797344, 114696834, 327457551, 905694736, 143025346, 289024806, 451579463, 325709522, 18701196, 326143996, 49850509, 619195074, 414881030, 850660769, 880149960, 651809429, 592293509, 810577782, 929598726, 835669318, 731671946, 529667681, 285562083, 293565850, 686472980, 274474950, 282703792, 889076915, 56602629, 546147347, 255724802, 873696194, 831784350, 110556728, 279941051, 667003092, 302778600, 803516696, 772054724, 165410893, 531446229, 958833885, 703493734, 68812272, 481542542, 722167619, 172528691, 173636402, 356397518, 390931659, 311533827, 53449710, 959934024, 259493848, 215350798, 907381983, 791418522, 896453666, 530274270, 443147787, 468552325, 410897594, 491169384, 314015783, 406644587, 772818684, 721371094, 596483817, 922913559, 78344520, 173781169, 485391881, 326797438, 209197264, 227032260, 183290649, 293208856, 909531571, 778733890, 346053132, 674154326, 75833611, 738595509, 449942130, 545136258, 334305223, 589959631, 51605154, 128106265, 85269691, 347284647, 656835568, 934798619, 602272125, 976691718, 647351010, 456965253, 143605060, 148066754, 588283108, 104912143, 240217288, 49898584, 251930392, 868617755, 690598708, 880742077, 200550782, 935358746, 104053488, 348096605, 394187502, 726999264, 278275958, 153885020, 653433530, 364854920, 922674021, 65882280, 762280792, 84294078, 29666249, 250921311, 659332228, 420236707, 614100318, 959310571, 676769211, 355052615, 567244231, 840761673, 557858783, 627343983, 461946676, 22779421, 756641425, 641419708]

        MMI = [0, 1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006, 47619048, 409090912, 739130440, 41666667, 280000002, 576923081, 370370373, 35714286, 758620695, 233333335, 129032259, 281250002, 939393946, 676470593, 628571433, 27777778, 621621626, 78947369, 717948723, 425000003, 658536590, 23809524, 395348840, 204545456, 822222228, 369565220, 404255322, 520833337, 448979595, 140000001, 784313731, 788461544, 56603774, 685185190, 763636369, 17857143, 385964915, 879310351, 50847458, 616666671, 688524595, 564516133, 15873016, 140625001, 30769231, 469696973, 686567169, 838235300, 579710149, 814285720, 98591550, 13888889, 410958907, 310810813, 93333334, 539473688, 831168837, 858974365, 202531647, 712500005, 123456791, 329268295, 84337350, 11904762, 670588240, 197674420, 252873565, 102272728, 415730340, 411111114, 164835166, 184782610, 43010753, 202127661, 231578949, 760416672, 268041239, 724489801, 646464651, 570000004, 940594066, 892156869, 572815538, 394230772, 209523811, 28301887, 224299067, 342592595, 9174312, 881818188, 873873880, 508928575, 893805316, 692982461, 147826088, 939655179, 239316241, 25423729, 478991600, 808333339, 438016532, 844262301, 886178868, 782258070, 856000006, 7936508, 480314964, 570312504, 798449618, 515384619, 190839696, 734848490, 165413535, 843283588, 274074076, 419117650, 58394161, 789855078, 604316551, 407142860, 134751774, 49295775, 832167838, 506944448, 151724139, 705479457, 149659865, 655405410, 530201346, 46666667, 483443712, 269736844, 594771246, 915584422, 625806456, 929487186, 343949047, 601265827, 685534596, 856250006, 962732926, 561728399, 116564418, 664634151, 587878792, 42168675, 5988024, 5952381, 242603552, 335294120, 795321643, 98837210, 791907520, 626436786, 325714288, 51136364, 683615824, 207865170, 435754193, 205555557, 933701664, 82417583, 562841534, 92391305, 524324328, 521505380, 577540111, 601063834, 338624341, 615789478, 439790579, 380208336, 694300523, 634020623, 343589746, 862244904, 969543154, 823232329, 507537692, 285000002, 228855723, 470297033, 108374385, 946078438, 131707318, 286407769, 526570052, 197115386, 832535891, 604761909, 90047394, 514150947, 32863850, 612149537, 79069768, 671296301, 875576043, 4587156, 470319638, 440909094, 950226251, 436936940, 125560539, 754464291, 364444447, 446902658, 35242291, 846491234, 711790398, 73913044, 277056279, 969827593, 90128756, 619658124, 880851070, 512711868, 67510549, 239495800, 280334730, 904166673, 406639007, 219008266, 707818935, 922131154, 89795919, 443089434, 165991904, 391129035, 28112450, 428000003, 912350604, 3968254, 339920951, 240157482, 556862749, 285156252, 70038911, 399224809, 517374521, 757692313, 417624524, 95419848, 836501907, 367424245, 611320759, 582706771, 138576780, 421641794, 743494429, 137037038, 450184505, 209558825, 388278391, 529197084, 752727278, 394927539, 252707583, 802158279, 681003589, 203571430, 718861215, 67375887, 650176683, 524647891, 77192983, 416083919, 808362375, 253472224, 961937723, 575862073, 756013751, 852739732, 522184304, 574829936, 210169493, 327702705, 215488217, 265100673, 441471575, 523333337, 770764125, 241721856, 646864691, 134868422, 137704919, 297385623, 749185673, 457792211, 857605184, 312903228, 787781356, 464743593, 492012783, 671974527, 403174606, 800632917, 652996850, 342767298, 614420067, 428125003, 741433027, 481366463, 597523224, 780864203, 406153849, 58282209, 3058104, 832317079, 343465048, 293939396, 631419944, 521084341, 624624629, 2994012, 737313438, 502976194, 41543027, 121301776, 631268441, 167647060, 284457480, 897660825, 206997086, 49418605, 715942034, 395953760, 985590785, 313218393, 521489975, 162857144, 413105416, 25568182, 175637395, 341807912, 19718310, 103932585, 826330538, 717877100, 713091927, 602777782, 113573408, 466850832, 812672182, 541208795, 882191787, 281420767, 376021801, 546195656, 295392956, 262162164, 436657685, 260752690, 16085791, 788770059, 618666671, 300531917, 212201593, 669312174, 195250661, 307894739, 160104988, 719895293, 172323761, 190104168, 966233773, 847150265, 932816544, 817010315, 951156819, 171794873, 102301791, 431122452, 63613232, 484771577, 840506335, 911616168, 760705295, 253768846, 55137845, 142500001, 855361602, 614427865, 779156333, 735148520, 424691361, 554187196, 238329240, 473039219, 188264060, 65853659, 352798056, 643203888, 578692498, 263285026, 16867470, 98557693, 534772186, 916267949, 844868741, 802380958, 966745850, 45023697, 44917258, 757075477, 134117648, 16431925, 526932088, 806074772, 610722615, 39534884, 761020887, 835648154, 614318711, 937788025, 50574713, 2293578, 354691078, 235159819, 642369025, 220454547, 716553293, 975113129, 88036118, 218468470, 83146068, 562780273, 176733782, 877232149, 285077953, 682222227, 605321512, 223451329, 161147904, 517621149, 432967036, 423245617, 172866522, 355895199, 198257082, 36956522, 321041217, 638528143, 820734347, 984913800, 208602152, 45064378, 775160605, 309829062, 240938168, 440425535, 447983018, 256355934, 763213536, 533755278, 646315794, 119747900, 228511532, 140167365, 206680586, 952083340, 355509358, 703319507, 654244311, 109504133, 653608252, 853909471, 607802879, 461065577, 38854806, 544897963, 641547866, 221544717, 632860045, 82995952, 529292933, 695564521, 156941651, 14056225, 266533068, 714000005, 1996008, 456175302, 282306165, 1984127, 588118816, 669960479, 747534522, 120078741, 491159139, 778431378, 344422703, 142578126, 598440550, 535019459, 314563109, 699612408, 400386850, 758687264, 597302509, 878846160, 191938581, 208812262, 921606125, 47709924, 441904765, 918250957, 301707782, 683712126, 510396979, 805660383, 561205277, 791353389, 589118203, 69288390, 844859819, 210820897, 811918069, 871747218, 404452693, 68518519, 60998152, 725092256, 311233888, 604779416, 801834868, 694139199, 541133459, 264598542, 854280516, 376363639, 39927405, 697463773, 457504524, 626353795, 174774776, 901079143, 457809698, 840501798, 491949914, 101785715, 525846706, 859430611, 433392543, 533687947, 578761066, 825088345, 446208116, 762323949, 732864680, 538596495, 334500878, 708041963, 813263531, 904181191, 229565219, 126736112, 771230508, 980968865, 898100179, 787931040, 869191056, 878006879, 732418530, 426369866, 447863251, 261092152, 724020448, 287414968, 585738544, 605084750, 656514387, 663851356, 160202362, 607744112, 95798320, 632550340, 835845902, 720735791, 410684477, 761666672, 296173047, 885382066, 76285241, 120860928, 887603312, 823432349, 729818786, 67434211, 36124795, 568852463, 492635028, 648692815, 696574230, 874592840, 377235775, 728896109, 716369535, 428802592, 953150249, 156451614, 842190022, 393890678, 630818624, 732371800, 571200004, 746006395, 944178635, 835987267, 36565978, 201587303, 438985740, 900316462, 30015798, 326498425, 696062997, 171383649, 880690744, 807210037, 677621288, 714062505, 720748835, 870716517, 43545879, 740683235, 359689925, 298761612, 119010820, 890432105, 640986137, 703076928, 291858681, 529141108, 29096478, 1529052, 438167942, 916158543, 823439884, 171732524, 698027319, 146969698, 216338882, 315709972, 983408755, 760542174, 33082707, 812312318, 163418292, 1497006, 41853513, 368656719, 62593145, 251488097, 493313525, 520771517, 454814818, 60650888, 320531760, 815634224, 609720181, 83823530, 345080766, 142228740, 530014645, 948830416, 411678835, 103498543, 237263466, 524709306, 927431066, 357971017, 444283650, 197976880, 92352093, 992795396, 520863313, 656609200, 862266864, 760744991, 696709590, 81428572, 489301002, 206552708, 85348507, 12784091, 626950359, 587818701, 991513444, 170903956, 385049368, 9859155, 355836852, 551966296, 701262277, 413165269, 366433569, 358938550, 93444910, 856545967, 318497916, 301388891, 224687935, 56786704, 802213007, 233425416, 630344832, 406336091, 696011009, 770604401, 235939645, 941095897, 729138172, 640710387, 66848568, 688010904, 29931973, 273097828, 698778838, 147696478, 538565633, 131081082, 721997306, 718328846, 590847918, 130376345, 506040272, 508042899, 676037488, 894385033, 889185587, 809333339, 215712385, 650265962, 304116868, 606100800, 896688748, 334656087, 952443864, 597625334, 779973655, 653947373, 582128782, 80052494, 1310616, 859947650, 518954252, 586161884, 850065195, 95052084, 855656703, 983116890, 690012975, 923575136, 648124196, 466408272, 525161294, 908505161, 839124845, 975578413, 613607193, 585897440, 645326509, 551150899, 805874846, 215561226, 868789815, 31806616, 419313853, 742385792, 278833969, 920253171, 841972193, 455808084, 822194205, 880352651, 537106922, 126884423, 877038902, 527568926, 964956202, 571250004, 46192260, 427680801, 764632633, 807213936, 592546588, 889578170, 581164812, 367574260, 102595798, 712345684, 755856972, 277093598, 816728173, 119164620, 223312885, 736519613, 73439413, 94132030, 462759466, 532926833, 618757617, 176399028, 52247874, 321601944, 917575764, 289346249, 617896014, 131642513, 712907122, 8433735, 84235861, 549278850, 496998803, 267386093, 601197609, 958133978, 560334532, 922434374, 696066751, 401190479, 853745547, 483372925, 239620405, 522511852, 848520716, 22458629, 348288078, 878537742, 216725561, 67058824, 722679206, 508215966, 690504108, 263466044, 359064330, 403037386, 792298722, 805361311, 67520373, 19767442, 269454125, 880510447, 718424107, 417824077, 158381504, 807159359, 987312579, 968894016, 200230151, 525287360, 360505169, 1146789, 918671255, 177345539, 265142859, 617579913, 891676175, 821184516, 840728106, 610227277, 759364364, 858276650, 612684036, 987556568, 736723169, 44018059, 559188279, 109234235, 497187855, 41573034, 738496077, 781390140, 705487127, 88366891, 287150840, 938616078, 813823863, 642538980, 314794218, 841111117, 591564932, 302660756, 256921375, 611725668, 786740337, 80573952, 324145537, 758810578, 882288235, 216483518, 963776077, 711622812, 371303398, 86433261, 712568311, 677947603, 741548533, 99128541, 41349293, 18478261, 916395229, 660520612, 776814740, 819264075, 304864867, 910367177, 952535066, 492456900, 252960174, 104301076, 23630505, 22532189, 595927121, 887580306, 515508025, 154914531, 16008538, 120469084, 164004261, 720212771, 568544106, 223991509, 115588548, 128177967, 467724871, 381606768, 551214365, 266877639, 262381456, 323157897, 884332288, 59873950, 383001052, 114255766, 687958120, 570083686, 204806689, 103340293, 8342023, 476041670, 746097820, 177754679, 580477678, 851659757, 338860106, 827122159, 260599795, 554752070, 199174408, 326804126, 669412981, 926954739, 943473799, 803901443, 468717952, 730532792, 584442174, 19427403, 492339125, 772448985, 1019368, 320773933, 399796544, 610772362, 793908635, 816430026, 447821685, 41497976, 17189080, 764646470, 172552978, 847782264, 877139986, 578470829, 901507544, 507028116, 911735212, 133266534, 874874881, 857000006]
        n = len(nums)
        lis = [0] * n
        def count(subnums):
            nonlocal lis
            if subnums:
                low = [num for num in subnums if num < subnums[0]]
                high = [num for num in subnums if num > subnums[0]]
                lis[subnums[0]-1] = len(subnums)
                count(low)
                count(high)
        
        count(nums)




        M = 10 ** 9 + 7
        denum = 1
        for k in range(1,n+1):
            denum = (denum * MMI[lis[k-1]]) % M
        return (FACT[n] * denum) % M - 1",0
"class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        
        n = len(mat)
        
        diagonal_sum = 0
        
        for i in range(n):
            diagonal_sum += mat[i][i]
            
			# Before adding the element for the second diagonal, 
			# make sure we are not in the middle element
            if n - i != i + 1: 
                diagonal_sum += mat[i][-i - 1]
        
        return diagonal_sum",1
"class Solution:
    def numWays(self, s: str) -> int:
        n = len(s)
        mod = 10**9+7
        numOnes = [0]*n
        numOnes[0] = 1 if s[0] == '1' else 0
        
        for i, ch in enumerate(s[1:]):
            numOnes[i+1] += numOnes[i]
            if ch == '1':
                numOnes[i+1] += 1
            i += 1

        if numOnes[-1]%3 != 0:
            return 0
        elif numOnes[-1] == 0:
            return ((n - 1)*(n-2)%mod)//2
        else:
			# get the required number of ones in each partition
            val = numOnes[-1]//3
        
        multiples = [val*1, val*2] # values to be counted in 'numOnes' array
        
        res = 1
        for multiple in multiples:
            res = res*numOnes.count(multiple)%mod
        
        return res",0
"class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        lo = next((i for i in range(len(arr)-1) if arr[i] > arr[i+1]), None)
        hi = next((i for i in reversed(range(1, len(arr))) if arr[i-1] > arr[i]), None)
        if lo is None: return 0 
        
        ll = bisect_right(arr, arr[hi], 0, lo+1)
        rr = bisect_left(arr, arr[lo], hi, len(arr))
        
        return min(hi - ll, rr - lo - 1)",0
"class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        # start = initial index
        # end = destination index     

        MOD = (10**9)+7 
        lenLocations = len(locations)

        @cache
        def dfs(index, fuel):
            # If you have no more fuel and you're at destination:
            # You cannot try another other routes, return 1 because you're at destination
            if fuel == 0 and index == finish:
                return 1

            # If no more fuel and not at route:
            # You cannot try another other routes, return 1 because you're not at destination
            if fuel <= 0:
                return 0
            
            # If your current index is destination index, you found an existing route
            countWays = 1 if index == finish else 0

            # Try every location index (dfs), but you cannot stay at your current index
            for nextIndex in range(len(locations)):
                if index != nextIndex:
                    cost = abs(locations[index]-locations[nextIndex])
                    countWays += dfs(nextIndex,fuel-cost)

            return countWays

        return dfs(start,fuel) % MOD",0
"class Solution:
    def modifyString(self, s: str) -> str:
        if len(s) == 1 and s[0] != '?':
            return s[0]
        elif len(s) == 1 and s[0] == '?':
            return 'a'
        else:
            x = {'a','b','c'}
            res = ''
            for i in range(len(s)):
                if s[i] == '?':
                    if i == 0:
                        res += list(x.difference(set(s[i+1])))[0]
                    elif i == len(s)-1:
                        res += list(x.difference(set([s[i-1],res[i-1]])))[0]
                    else:
                        res += list(x.difference(set([s[i-1],s[i+1],res[i-1]])))[0]
                else:
                    res += s[i]
            return res",0
"class Solution:
    # two-sum. search for nums1[i]^2/nums2[k]
    # O(mn) time : O(m + n) space
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        def count(arr1, arr2):
            res = 0
            for n1 in arr1:
                n2_freq = defaultdict(int)
                for n2 in arr2:
                    if n1*n1 / n2 in n2_freq:
                        res += n2_freq[n1*n1 / n2]
                    n2_freq[n2] += 1
            return res
        return count(nums1, nums2) + count(nums2, nums1)",1
"class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        
        consecutives = dict()
        
        i = 1
        prev = colors[0]
        count = 0
        while i < len(colors):
            if colors[i] == prev:
                if count not in consecutives:
                    consecutives[count] = [neededTime[i-1]]
                consecutives[count].append(neededTime[i])
            else:
                prev = colors[i]
                count +=1
            i+=1

        sum_ = 0
        for list_ in consecutives.values():
            if len(list_) == 1:
                sum_ += list_[0]
            else:
                max_ = 0
                for i in list_:
                    sum_+=i
                    max_ = max(max_, i)
                sum_ -= max_
        return sum_",0
"class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        ans, m, n = 0, len(mat), len(mat[0])
        row, col = [0] * m, [0] * n
        for i in range(m):
            for j in range(n):
                row[i] += mat[i][j]
                col[j] += mat[i][j]
        for i in range(m):
            for j in range(n):
                if mat[i][j] and row[i] == 1 and col[j] == 1: ans += 1; break
        return ans",0
"class Solution:
    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
        prefDict = {i:preferences[i] for i in range(n)}
        res = set()
        for i, (x1,y1) in enumerate(pairs):
            for j, (x2,y2) in enumerate(pairs):
                if i != j:
                    if prefDict[x1].index(y2) < prefDict[x1].index(y1): # smaller index means higher preference
                        if prefDict[y2].index(x1) < prefDict[y2].index(x2):
                            res.add(x1)
                    if prefDict[x1].index(x2) < prefDict[x1].index(y1):
                        if prefDict[x2].index(x1) < prefDict[x2].index(y2):
                            res.add(x1)
                    if prefDict[y1].index(x2) < prefDict[y1].index(x1):
                        if prefDict[x2].index(y1) < prefDict[x2].index(y2):
                            res.add(y1)
                    if prefDict[y1].index(y2) < prefDict[y1].index(x1):
                        if prefDict[y2].index(y1) < prefDict[y2].index(x2):
                            res.add(y1)
        return len(res)",0
"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        graph = {}
        self.create_graph(points, graph)
        print(graph)
        visited = {0}
        min_heap = MinHeap(graph[0])

        result = 0

        while len(visited) < len(points):
            cost, vertex = min_heap.remove()
            if vertex not in visited:
                visited.add(vertex)
                result += cost
                
                if vertex not in graph:
                    continue
                
                for i in graph[vertex]:
                    cost, node = i
                    if node not in visited:
                        min_heap.insert((cost, node))

        return result
        
    def create_graph(self, points, graph):
        for point in range(len(points)):
            graph[point] = []
        
        for i in range(len(points) - 1):
            # can be with -1 or without
            for j in range(i + 1, len(points)):
                curr_point = points[i]
                next_point = points[j]
                result = self.difference(curr_point[0], curr_point[1],
                                        next_point[0], next_point[1])
                    
                graph[i].append((result, j))
                graph[j].append((result, i))
    
    
    def difference(self, a, b, c, d):
        return abs(a - c) + abs(b - d)
     

class MinHeap:
    def __init__(self, arr):
        self.heap = self.buildHeap(arr)
    
    def check(self):
        return len(self.heap) == 0
    
    def buildHeap(self, arr):
        parentIdx = (len(arr) - 2) // 2
        for i in reversed(range(parentIdx + 1)):
            self.siftDown(i, len(arr) - 1, arr)
        return arr
    
    def peek(self):
        return self.heap[0]
    
    def remove(self):
        to_remove = self.heap[0]
        node = self.heap.pop()
        if len(self.heap) > 0:
            self.heap[0] = node
            self.siftDown(0, len(self.heap) - 1, self.heap)
        return to_remove
    
    def insert(self, value):
        self.heap.append(value)
        self.siftUp()
    
    def siftDown(self, idx, length, arr):
        idxOne = idx * 2 + 1
        while idxOne <= length:
            idxTwo = idx * 2 + 2 if idx * 2 + 2 <= length else -1
            if idxTwo != -1 and arr[idxOne][0] > arr[idxTwo][0]:
                swap = idxTwo
            else:
                swap = idxOne
            
            if arr[swap][0] < arr[idx][0]:
                self.swapValues(swap, idx, arr)
                idx = swap
                idxOne = idx * 2 + 1
            else:
                return
    
    def swapValues(self, i, j, arr):
        arr[i], arr[j] = arr[j], arr[i]
    
    def siftUp(self):
        idx = len(self.heap) - 1
        while idx > 0:
            parentIdx = (idx - 1) // 2
            if self.heap[idx][0] < self.heap[parentIdx][0]:
                self.swapValues(idx, parentIdx, self.heap)
                idx = parentIdx
            else:
                return",0
"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t): return False # edge case 
        
        pos = [deque() for _ in range(10)]
        for i, ss in enumerate(s): pos[int(ss)].append(i)
            
        for tt in t: 
            i = pos[int(tt)].popleft()
            for ii in range(int(tt)): 
                if pos[ii] and pos[ii][0] < i: return False # cannot swap 
        return True",1
"class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        chg = [0]*len(nums) # change 
        for i, j in requests: 
            chg[i] += 1
            if j+1 < len(nums): chg[j+1] -= 1
        for i in range(1, len(nums)): chg[i] += chg[i-1] # cumulated change
        return sum(n*c for n, c in zip(sorted(nums), sorted(chg))) % 1_000_000_007",0
"class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        target = sum(nums) % p # targetted remainder 
        ans = inf
        seen = {(prefix := 0): -1}
        for i, x in enumerate(nums): 
            seen[(prefix := (prefix+x)%p)] = i # update seen before check 
            if (prefix-target) % p in seen: 
                ans = min(ans, i - seen[(prefix-target) % p])
        return ans if ans < len(nums) else -1 # not allowed to remove whole array",0
"class Solution(object):
    def isPrintable(self, targetGrid):
        """"""
        :type targetGrid: List[List[int]]
        :rtype: bool
        """"""
#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher
        m,n=len(targetGrid),len(targetGrid[0])
        # strore upper,left,right,bottom most for every color
        colors={}
        for i in range(m):
            for j in range(n):
                c=targetGrid[i][j]
                if c not in colors:
                    colors[c]=[sys.maxsize,sys.maxsize,-1*sys.maxsize,-1*sys.maxsize]
                colors[c][0]=min(colors[c][0],i)
                colors[c][1]=min(colors[c][1],j)
                colors[c][2]=max(colors[c][2],j)
                colors[c][3]=max(colors[c][3],i)
        # print(colors)
        # this is for check is it possible to fill with this color or not
        def isPossibleTofill(color):
            upper,left,right,bottom=colors[color]
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    if targetGrid[i][j]>0 and targetGrid[i][j]!=color:return False
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    targetGrid[i][j]=0
            return True
                                 
        c1=colors.keys()
        while c1:
            c2=set()
            for col in c1:
                if isPossibleTofill(col)==False:
                    c2.add(col)
            if len(c2)==len(c1):return False
            c1=c2
        if len(c1)==0:return True
        return False",0
"class Solution:
    def reorderSpaces(self, text: str) -> str:
        space = text.count(' ')                            # count how many space in total
        text = [word for word in text.split(' ') if word]  # split text to individual word in a list
        n = len(text)                                      # count total words
        if n == 1: return text[0] + space * ' '            # length == 1 is a special case, since no space in between only at the end
        avg, reminder = divmod(space, n-1)                 # get average space between words and spaces left (will be appended the end)
        return (' '*avg).join(text) + ' ' * reminder       # compose result",0
"class Solution:
    def maxUniqueSplit(self, s: str) -> int:
        strings = set()
        self.max_len = 0
        def split(s) :
            if not s :
                self.max_len = max(self.max_len, len(strings)) 
                return 
            
            for i in range(1,len(s)+1) :
                cs = s[:i] 
                if cs not in strings :
                    strings.add(cs)
                    split(s[i:])
                    strings.remove(cs)
                    
                        
        split(s)
        
        return self.max_len",1
"class Solution:
def maxProductPath(self, grid: List[List[int]]) -> int:
    
    MOD = 10**9+7
    m,n = len(grid),len(grid[0])
    dp = [[[0,0] for _ in range(n)] for _ in range(m)]
    dp[0][0][0]=grid[0][0]
    dp[0][0][1]=grid[0][0]
    for i in range(1,m):                     #First Column
        dp[i][0][0] = dp[i-1][0][0]*grid[i][0]
        dp[i][0][1] = dp[i-1][0][1]*grid[i][0]
    
    for j in range(1,n):                     #First Row
        dp[0][j][0] = dp[0][j-1][0]*grid[0][j]
        dp[0][j][1] = dp[0][j-1][1]*grid[0][j]
    
    for i in range(1,m):
        for j in range(1,n):
            if grid[i][j]<0:
                dp[i][j][0] = min(dp[i][j-1][1],dp[i-1][j][1])*grid[i][j]
                dp[i][j][1] = max(dp[i][j-1][0],dp[i-1][j][0])*grid[i][j]
            else:
                dp[i][j][0] = max(dp[i][j-1][0],dp[i-1][j][0])*grid[i][j]
                dp[i][j][1] = min(dp[i][j-1][1],dp[i-1][j][1])*grid[i][j]
    
    if dp[-1][-1][0]<0 and dp[-1][-1][1]<0:
        return -1
    
    return max(dp[-1][-1][0],dp[-1][-1][1])%MOD",0
"class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        mn = [min(x) for x in cost] # min cost of connecting points in 1st group 
        
        @lru_cache(None)
        def fn(j, mask):
            """"""Return min cost of connecting group1[i:] and group2 represented as mask.""""""
            if j == n: return sum(mn[i] for i in range(m) if not (mask &amp; (1<<i)))
            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))
                
        return fn(0, 0)",0
"class Solution:
    def minOperations(self, logs: List[str]) -> int:
        res=[]
        for word in logs:
            if word==""../"" and len(res)>0:
                res.pop()
            elif word==""./"":
                continue
            elif word!=""../"" and word!=""./"":
                res.append(word)
        return len(res)",1
"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        i=0
        count=0
        profit=0
        rem=0
        onBoard=0
        max_profit_rounds=-1
        max_profit=0
        while True:
            if i>=len(customers)-1 and rem==0:              
                break
            if i<len(customers):
                rem+=customers[i]
                i+=1
            count+=1
            if rem>4:
                onBoard+=4
                rem-=4
            else:
                onBoard+=rem
                rem=0
            profit=(onBoard*boardingCost)-(count*runningCost)
            if profit>max_profit:
                max_profit=profit
                max_profit_rounds=count

            
        if max_profit<0:
            return -1
        
        return max_profit_rounds",0
"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        
        def fn(k, mask): 
            """"""Return maximum number of achievable transfer requests.""""""
            if k == len(requests): 
                net = [0]*n
                for i, (u, v) in enumerate(requests): 
                    if mask &amp; 1 << i: 
                        net[u] -= 1
                        net[v] += 1
                return 0 if any(net) else bin(mask).count(""1"")
            return max(fn(k+1, mask), fn(k+1, mask | 1 << k))
        
        return fn(0, 0)",0
"class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        ans = set()
        seen = {}
        for key, time in sorted(zip(keyName, keyTime)): 
            if key not in ans: 
                h, m = time.split("":"")
                time = int(h) * 60 + int(m)
                seen.setdefault(key, deque()).append(time)
                if len(seen[key]) == 3: 
                    if seen[key][-1] <= seen[key][0] + 60: ans.add(key)
                    seen[key].popleft()
        return sorted(ans)",0
"class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        # 0) Initialization
        ROW_SIZE = len(rowSum)
        COL_SIZE = len(colSum)
        mtx = [[0] * COL_SIZE for ri in range(ROW_SIZE)]
        for i, rs in enumerate(rowSum):
            mtx[i][0] = rs
            
		# 1) Iteratively meet column sum by making reduction from first column
        valid_row_set = set(list(filter(lambda ri: mtx[ri][0], range(ROW_SIZE))))
        for ci in range(1, COL_SIZE):
            cs = colSum[ci]
            empty_ri_list = []
            for ri in valid_row_set:
                if mtx[ri][0] < cs:
                    cs -= mtx[ri][0]
                    mtx[ri][ci] = mtx[ri][0]
                    mtx[ri][0] = 0                     
                    empty_ri_list.append(ri)
                elif mtx[ri][0] == cs:
                    mtx[ri][ci] = mtx[ri][0]
                    mtx[ri][0] = cs = 0
                    empty_ri_list.append(ri)
                    break
                elif mtx[ri][0] > cs:
                    mtx[ri][ci] = cs
                    mtx[ri][0] -= cs
                    break
                    
            for eri in empty_ri_list:
                valid_row_set.remove(eri)
                                
        return mtx",0
"class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        busy = [] # min-heap
        free = list(range(k)) # min-heap 
        freq = [0]*k
        
        for i, (ta, tl) in enumerate(zip(arrival, load)): 
            while busy and busy[0][0] <= ta: 
                _, ii = heappop(busy)
                heappush(free, i + (ii - i) % k) # circularly relocate it
            if free: 
                ii = heappop(free) % k 
                freq[ii] += 1
                heappush(busy, (ta+tl, ii))
        
        mx = max(freq)
        return [i for i, x in enumerate(freq) if x == mx]",0
"class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort() 
        fn = lambda x: x - (len(nums) - bisect_left(nums, x))
        lo, hi = 0, nums[-1]
        while lo <= hi: 
            mid = lo + hi >> 1
            if fn(mid) < 0: lo = mid + 1
            elif fn(mid) == 0: return mid
            else: hi = mid - 1
        return -1",0
"class Solution:
    def isEvenOddTree(self, root: TreeNode) -> bool:
        
        if not root: return True
        
        queue=[root]
        lvl=0
        while queue:
            order=[]
            for _ in range(len(queue)):
                node=queue.pop(0)
                
                if lvl%2==0:
                    if node.val&amp;1:
                        if not order: order.append(node.val)
                        else:
                            if order[-1]<node.val: order.append(node.val)
                            else: return False
                        if node.left:queue.append(node.left)
                        if node.right: queue.append(node.right)
                    else: return False
                else:
                    if node.val%2==0:
                        if not order: order.append(node.val)
                        else:
                            if order[-1]>node.val: order.append(node.val)
                            else: return False
                        if node.left:queue.append(node.left)
                        if node.right: queue.append(node.right)
                    else: return False
            lvl+=1
        return True",0
"class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:
        
        array = []
        nloc = 0
        for p in points:
            if p == l:
                nloc += 1
            else:
                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))
        array.sort()
        angles = array + [a+360 for a in array]
        left, maxm = 0, 0
        for right, a in enumerate(angles):
            if a-angles[left] > angle:
                left += 1
            maxm = max(right-left+1, maxm)
        
        return maxm + nloc",0
"class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        if not n: return 0 # edge case 
        if not (n &amp; (n-1)): return 2*n-1
        b = 1 << n.bit_length()-1 
        return self.minimumOneBitOperations((b>>1)^b^n) + b",1
"class Solution:
    def maxDepth(self, s: str) -> int:
        maxDepth:int = 0
        bracketNum:int = 0

        for c in s:
            if c == '(': 
                bracketNum += 1
                if bracketNum > maxDepth: maxDepth = bracketNum
            elif c == ')':
                bracketNum -= 1
        return maxDepth",1
"class Solution:
    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
        
        g = defaultdict(list)
        
        for u, v in roads:  # create graph adjacency list
            g[u].append(v)
            g[v].append(u)
        
        res = 0
        
        for i in range(n):
            for j in range(i+1, n):
                val = len(g[i]) + len(g[j]) # sum the amount of roads for each city
                if j in g[i]:   # remove road connected to both cities
                    val -= 1
                res = max(res, val)
        
        
        return res",1
"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: bool
        """"""
        if len(a) == 1 or len(b) == 1:
            return True  
        b = b[::-1] # reverse string b
        return (a[0] == b[0] and a[1] == b[1]) or (a[-1] == b[-1] and a[-2] == b[-2]) # search for same substrings : 1) start from head(a_prefix + b_suffix) 
																												# 2) start from tail(b_prefix + a_suffix).",0
"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        def maxDistance(subtree):
            edges,node,maxD=[0]*3
            for i in range(n):
                if (subtree>>i)&amp;1==0:continue
                node+=1
                for j in range(i+1,n):
                    if (subtree>>j)&amp;1==0:continue
                    edges+=dist[i][j]==1
                    maxD=max(maxD,dist[i][j])
            if edges!=node-1:
                return 0
            else:
                return maxD
        dist=[[float('inf')]*n for i in range(n)]
        for i,j in edges:
            dist[i-1][j-1]=dist[j-1][i-1]=1
        for mid in range(n):
            for n1 in range(n):
                for n2 in range(n):
                    dist[n1][n2]=min(dist[n1][n2],dist[n1][mid]+dist[mid][n2])
        ans=[0]*(n-1)
        for i in range(1,2**n):
            d=maxDistance(i)
            if d>0:
                ans[d-1]+=1
        return ans",0
"class Solution:
    def trimMean(self, arr: List[int]) -> float:
		# Calculate how many elements make the top/bottom 5%. 
		# Since the length of the array will always be a multiple 
		# of 20, we don't need to do any special checks, just divide
        numToRemove = len(arr) // 20
		
		# Remove the top and bottom 5% of the elements by finding 
		# the min/max of the list
        for i in range(numToRemove):
            arr.remove(max(arr))
            arr.remove(min(arr))
        
		# Return the average of the new list
		return sum(arr) / len(arr)",1
"class Solution:
    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        return max(
            (
                (sum(qi // (1 + dist) for xi, yi, qi in towers if (dist := sqrt((xi - x) ** 2 + (yi - y) ** 2)) <= radius),
                 [x, y]) for x in range(51) for y in range(51)
            ),
            key=lambda x: (x[0], -x[1][0], -x[1][1])
        )[1]",0
"class Solution:
    def numberOfSets(self, n: int, k: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return number of sets.""""""
            if n <= k: return 0 
            if k == 0: return 1
            return 2*fn(n-1, k) + fn(n-1, k-1) - fn(n-2, k)
        
        return fn(n, k) % 1_000_000_007",1
"class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        if(len(s)==len(set(s))):
            return -1
			
        maxdiff=0
        dicts=collections.defaultdict(list)
		
        for index,char in enumerate(s):
            dicts[char]+=[index]
           
        for k,v in dicts.items():
            diff=v[-1]-v[0]-1
            if diff>maxdiff:
                maxdiff=diff
				
        return maxdiff",1
"class Solution:
    def __init__(self):
        self.mn = 'z' * 100
        self.vis = set()
    
    def solve(self, st):
        if ''.join(st) in self.vis:
            return
        self.vis.add(''.join(st))
        new = st
        for i in range(1, len(st), 2):
            st[i] = str((int(st[i]) + self.a) % 10)
        self.mn = min(''.join(st), self.mn)
        
        lp = new[-self.b:]
        fp = new[:self.l - self.b]
        new = lp + fp
        self.mn = min(self.mn, ''.join(new))
        
        self.solve(st)
        self.solve(new)
    
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        self.a = a ; self.b = b
        self.l = len(s)
        self.b = self.b % self.l
        s = list(s)
        self.solve(s)
        return self.mn",0
"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        ages, scores = zip(*sorted(zip(ages, scores)))
        
        @lru_cache(None)
        def fn(i): 
            """"""Return max score up to ith player included.""""""
            if i < 0: return 0 # boundary condition 
            return scores[i] + max((fn(ii) for ii in range(i) if ages[ii] == ages[i] or scores[ii] <= scores[i]), default=0)
        
        return max(fn(i) for i in range(len(scores)))",0
"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        max_d = -1
        letter = None
        
        
        duration = [releaseTimes[0]]
        
        for i in range(1,len(releaseTimes)):
            duration.append(releaseTimes[i]- releaseTimes[i-1])
        
        for index, i in enumerate(duration):
            if(i > max_d):
                max_d = i
                letter = keysPressed[index]
            elif(i == max_d and ord(keysPressed[index])>ord(letter)):
                letter = keysPressed[index]
        return letter",1
"class Solution:
    
    def checker(self,nums):
        i = 2
        n = len(nums)
        diff = nums[1] - nums[0]
        while i < n:
            if nums[i] - nums[i-1] != diff:
                return False
            i += 1
        return True
    
    def checkArithmeticSubarrays(self, nums: List[int], left: List[int], right: List[int]) -> List[bool]:
        m, i, ans = len(left), 0, []
        while i < m:
            l, r = left[i], right[i]
            sub = nums[l:r+1]
            sub.sort()
            ans.append(self.checker(sub))
            i += 1
        return ans",1
"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        
        M, N = map(len, (heights, heights[0]))
        heap = [(0, 0, 0)]
        seen = set()
        result = 0
        
        while heap:
            
            # Pop
            effort, i, j = heapq.heappop(heap)
            
            # Mark seen
            seen.add((i, j))
            
            # Update minimum ""effort""
            result = max(result, effort)
            
            # Success condition
            if i == M-1 and j == N-1:
                break
                                    
            # BFS
            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if not (x >= 0 <= y): continue
                if x >= M or y >= N: continue
                if (x, y) in seen: continue
                effort = abs(heights[i][j] - heights[x][y])
                heapq.heappush(heap, (effort, x, y))
                                
        return result",0
"class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        
        def find_root(x: int, y: int):
            if parent[x][y] == (x, y):
                return (x, y)
            else:
                r = find_root(parent[x][y][0], parent[x][y][1])
                parent[x][y] = r
                return r
        
        def union(x1, y1, x2, y2):
            root_a = find_root(x1, y1)
            root_b = find_root(x2, y2)
            parent[root_b[0]][root_b[1]] = root_a
            
        ########################################################
        
		# *parent* records the parent of each point in matrix form
		# points with same value in the same row/column should have the same parent
        parent = [[(j, i) for i in range(n)] for j in range(m)]
        
		# sort each row, if there are points with same value, union them
        for i in range(m):
            value = []
            for j in range(n):
                v = tuple([matrix[i][j], i, j])
                value.append(v)
            value.sort()
            for k in range(n - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
					
        # sort each column, if there are points with same value, union them            
        for i in range(n):
            value = []
            for j in range(m):
                v = tuple([matrix[j][i], j, i])
                value.append(v)
            value.sort()
            for k in range(m - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
        
        ########################################################
        
        dic = {} # point index : point that it directs ->
        in_degree = {} # point index : number of incoming arrows <-
		
		# Ex. [20, -21, 14]
		# sort: -21 (0, 1) -> 14 (0, 2) -> 20 (0, 0)
		# dic = { (0, 0) : [], (0, 1) : [(0, 2)], (0, 2) : [(0, 0)] }
		# in_degree = { (0, 0) : 1, (0, 1) : 0, (0, 2) : 1 }
		
		# only select ""root"" points that parent[point] = point itself
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    dic[(i, j)] = []
                    in_degree[(i, j)] = 0
                    
		# if there are points that parent[point] = its parent but not the ""root"" ancestor
		# make parent[point] = the ""root"" ancestor
		
		# Ex. before: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (8, 0)
		# after: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (4, 4)
		
        for i in range(m):
            for j in range(n):
                while parent[i][j] not in dic:
                    parent[i][j] = parent[parent[i][j][0]][parent[i][j][1]]
        
		# continue to construct *dic* and *in_degree*
		# make connections in each row
        for i in range(m):
            row = []
            for j in range(n):
                r = tuple([matrix[i][j], parent[i][j][0], parent[i][j][1]])
                row.append(r)
            row.sort()
            for k in range(n - 1):
                if row[k][0] < row[k + 1][0]:
                    if (row[k][1], row[k][2]) in dic and (row[k + 1][1], row[k + 1][2]) in dic:
                        if (row[k + 1][1], row[k + 1][2]) not in dic[(row[k][1], row[k][2])]:
                            dic[(row[k][1], row[k][2])].append((row[k + 1][1], row[k + 1][2]))
                            in_degree[(row[k + 1][1], row[k + 1][2])] += 1
        
		# and make connections in each column
        for i in range(n):
            col = []
            for j in range(m):
                c = tuple([matrix[j][i], parent[j][i][0], parent[j][i][1]])
                col.append(c)
            col.sort()
            for k in range(m - 1):
                if col[k][0] < col[k + 1][0]:
                    if (col[k][1], col[k][2]) in dic and (col[k + 1][1], col[k + 1][2]) in dic:
                        if (col[k + 1][1], col[k + 1][2]) not in dic[(col[k][1], col[k][2])]:
                            dic[(col[k][1], col[k][2])].append((col[k + 1][1], col[k + 1][2]))
                            in_degree[(col[k + 1][1], col[k + 1][2])] += 1
        
        #######################################################################
        
		# *distance* records the rank of the ""root"" points (just my naming habit)
        distance = {} # point index : rank
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    distance[(i, j)] = 0
        
		# first put ""root"" points that have 0 in_degree (meaning they are the smallest) in queue
        queue = []
        for i in in_degree:
            if in_degree[i] == 0:
                queue.append(i)
                distance[i] = 1
        
        head = 0
        tail = len(queue) - 1
        while head <= tail:
            h = queue[head]

            for p in dic[h]:
                in_degree[p] -= 1
                if in_degree[p] == 0:
                    queue.append(p)
                    distance[p] = distance[h] + 1

            head += 1
            tail = len(queue) - 1
        
        #######################################################################
        
		# *rank* records the final result in matrix form
        rank = [[0 for i in range(n)] for j in range(m)]
        
		# now we already got the rank of those ""root"" points recorded in *distance*
		# let's put them in *rank*, also their descendants'
        for i in range(m):
            for j in range(n):
                rank[i][j] = distance[parent[i][j]]
        
        return rank",0
"class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        counter = [(x[0], len(list(x[1]))) for x in groupby(sorted(nums))]
        sorted_new_array = sorted(counter, key=lambda x: (x[1], -x[0]))
        nums = []
        for i in sorted_new_array:
            nums += ([i[0]] * i[1])
        return nums",1
"class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        last = None
        mx = None
        for i in sorted(points):
            i = i[0]
            if last is not None and (mx is None or i - last > mx):
                mx = i - last
            last = i
        return mx",1
"class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        ans=0
        for i in range(len(s)):
            for j in range(len(t)):
                x=i
                y=j
                d=0
                while x<len(s) and y<len(t):
                    if s[x]!=t[y]:
                        d+=1
                    if d==1:
                        ans+=1
                    if d==2:
                        break
                    x+=1
                    y+=1
        return ans",0
"class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        @lru_cache(None)
		# dfs(i, j) is number of ways to construct taget[:i+1] using chars with index at most j in the word in the words dictionary. 
        def dfs(i, j):
            if i < 0:
                return 1
            if j < 0:
                return 0
            # 
            ans = dfs(i, j-1)
            if chars_count[j][target[i]] > 0:
                ans += dfs(i-1, j-1)*chars_count[j][target[i]]
                ans %= 10**9+7
            return ans
            
        
        m, n = len(target), len(words[0])
        chars_count = [Counter([word[idx] for word in words]) for idx in range(n)]
        return dfs(m-1, n-1)",0
"class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        joined = ""##"".join([str(i) for i in arr])
        joined = ""#"" + joined + ""#""
        pieces.sort()
        for pce in pieces:
            pJoined = ""##"".join(str(i) for i in pce)
            replaceStr = ""#"" + pJoined + ""#""
            joined = joined.replace(replaceStr, """")
        
        if joined == """":
            return True
        return False",1
"class Solution(object):
    def countVowelStrings(self, n, p=0):
        if n == 0:
            return 1
        
        return sum([self.countVowelStrings(n-1, i) for i in range(p, 5)])",1
"class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        s = 0
        for i in range(1,len(heights)):
            if heights[i] > heights[i-1]:
                s += heights[i] - heights[i-1]         # height to be climbed
                if bricks >= s:                     # if bricks are available, continue
                    continue
                elif ladders > 0:           # else use ladder and note: remove the height to be climbed from total sum
                    s -= heights[i] - heights[i-1]
                    ladders -= 1                              # remove a ladder
                else:
                    return i - 1                  # i-1 th building was the last building which was reached
                    
        return len(heights) - 1                # last building reached",0
"class Solution:
    def fact(self, n):
		""""""factorial with cache""""""
        if n in self.fact_cache:
            return self.fact_cache[n]
        x = self.fact(n-1) * n
        self.fact_cache[n] = x
        return x
    def max_k(self, x, y):
		""""""number of combinations for ordering x and y identical elements
		if x < 0, return 0
		""""""
        if x < 0:  # special case for our problem where there is no H left
            return 0
        return self.fact(x+y) // self.fact(x) // self.fact(y)
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        self.fact_cache = {0: 1}
        y, x = destination  # numbers of V and H moves
        out = ''
        for i in range(x+y):
		    # the number of combinations if the next element is H
            split = self.max_k(x-1, y)
            if k > split:
                out += 'V'
                y -= 1
                k -= split
            else:
                out += 'H'
                x -= 1
        return out",0
"class Solution:
    def __init__(self):
        self.nums = [0, 1]
        for i in range(2, 101):
            d, r = divmod(i, 2)
            if r == 0:
                self.nums.append(self.nums[d])
            else:
                p = int(i/2)
                self.nums.append(self.nums[d] + self.nums[d+1])
                
        
    def getMaximumGenerated(self, n: int) -> int:
        '''
        0 1 2 3 4 5 6 7 8 9 ...
        0 1 1 2 1 3 2 3 1 4 ...
        '''
        return max(self.nums[:n+1])",1
"class Solution:
    def minDeletions(self, s: str) -> int:
        
        cnt_dict = {}
        
        for c in s:
            if c in cnt_dict:
                cnt_dict[c]+=1
            else:
                cnt_dict[c]=1                                   #Store the frequency of each character in a dictionary
                
        cnt_dict = {k: v for k, v in sorted(cnt_dict.items(), reverse=True, key=lambda item: item[1])}  #Sort the dictionary in a non-increasing order of the frequencies
             
        freq_found = []                                         #Store which frequencies have been found till now
        res = 0                                                 #Store how many characters to remove to make frequencies unique
        for c in cnt_dict.keys():
            while cnt_dict[c]>0 and cnt_dict[c] in freq_found:  #Don't reduce the frequency if the frequency is already 0
                cnt_dict[c]-=1
                res+=1
            freq_found.append(cnt_dict[c])                      #Found a unique frequency, append to the list
            
            
        return res",0
"class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True)
        N = len(inventory)
        width = 1
        total = 0
        
        # sum of Arthematic Progression
        def sumAP(startHeight, endHeight):
            sum1 = startHeight * (startHeight + 1) // 2
            sum2 = endHeight * (endHeight + 1) // 2
            return sum1 - sum2
        
        i = 0
        while orders > 0:
            startHeight = inventory[i]
            endHeight = inventory[i+1] if i < N-1 else 0
            if width * (startHeight - endHeight) < orders:
                total += width * sumAP(startHeight, endHeight)
                orders -= width * (startHeight - endHeight)
            else: # enters else only once at the end
                q, r = divmod(orders, width)
                endHeight = inventory[i] - q
                total += width * sumAP(startHeight, endHeight)
                total += r * (startHeight - q)
                return total % (10 ** 9 + 7)
            width += 1
            i += 1",0
"class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        
        s=0
        temp=0
        ans=[]
        
        for i in range(0,len(code)):
        
            temp=k
            s=0
            
            if temp==0:
                ans.append(0)
            
            elif temp>0:
                j=i+1
                while temp>0 and j<len(code):
                    s+=code[j]
                    j=j+1
                    temp=temp-1
                
                if temp>0:
                    j=0
                    while temp>0 and j<len(code):
                        s+=code[j]
                        j=j+1
                        temp=temp-1
                
                ans.append(s)
            
            else:
                temp=temp*(-1)
                j=i-1
                while j>=0 and temp>0:
                    s+=code[j]
                    j=j-1
                    temp=temp-1
                
                if temp>0:
                    j=len(code)-1
                    while j>=0 and temp>0:
                        s+=code[j]
                        j=j-1
                        temp=temp-1
                    
       
                ans.append(s)
        
        return ans",0
"class Solution:
    def minimumDeletions(self, s: str) -> int:
                        
        a_idx = [0] + list(itertools.accumulate([1 if c == 'a' else 0 for c in s]))
        b_idx = [0] + list(itertools.accumulate([1 if c == 'b' else 0 for c in s]))
        
        result = float('inf')
        
        for idx in range(len(s)):
            result = min(
                result,
                a_idx[-1] - a_idx[idx+1] +  b_idx[idx] - b_idx[0]
            )
        
        return result",1
"class Solution:
    def minimumJumps(self, forbidden, a, b, x):
        limit, visited = max(x,max(forbidden)) + a + b, set()

        stack = [(0,0,False)]

        while stack:
            val, steps, par = stack.pop(0)

            if val > limit or val < 0 or val in forbidden or (val,par) in visited:
                continue
            else:
                visited.add((val,par))

            if val == x:
                return steps

            stack.append((val+a,steps+1,False))

            if not par:
                stack.append((val-b,steps+1,True))

        return -1",1
"class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        
        arr=[0]*(1001)
        for i in nums:
            arr[i]+=1
            
        arr.sort(reverse=True)
        #print(arr)
        arr=arr[:10]
        dict={}
        def dfs(ind,arr):
            if ind==m:
                return True
            if (ind,tuple(arr)) in dict:
                return dict[(ind,tuple(arr))]
            
            for i in range(0,10):
                if arr[i]>=quantity[ind]:
                    arr[i]-=quantity[ind]
                    a=dfs(ind+1,arr)
                    arr[i]+=quantity[ind]
                    if a:
                        dict[(ind,tuple(arr))]=True
                        
                        return True
                    
            dict[(ind,tuple(arr))]=False
            return False
        m=len(quantity)
        return dfs(0,arr)",0
"class Solution(object):
    def closeStrings(self, word1, word2):
        def ans(word):
            dict1 ={}
            for i in word:
                if i not in dict1:dict1[i]=1
                else:dict1[i]+=1
            return sorted(dict1.values())
        return ans(word1)==ans(word2) and set(word1)==set(word2)",1
"class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        total_sum = sum(nums)
        
        left, right = 0, 0
        max_len_win = -1
        current_win_sum = 0
        
        while right < len(nums):
            current_win_sum += nums[right]
            
            while current_win_sum > total_sum - x and left <= right:
                current_win_sum -= nums[left]
                left += 1
            
            if current_win_sum == total_sum - x:
                max_len_win = max(max_len_win, right - left + 1)
        
            right += 1

        return len(nums) - max_len_win if max_len_win != -1 else -1",0
"class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        
        @cache
        def fn(prev, i, j, intro, extro): 
            """"""Return max grid happiness at (i, j).""""""
            if i == m: return 0 # no more position
            if j == n: return fn(prev, i+1, 0, intro, extro)
            if intro == extro == 0: return 0 
            
            prev0 = prev[:j] + (0,) + prev[j+1:]
            ans = fn(prev0, i, j+1, intro, extro)
            if intro: 
                val = 120 
                if i and prev[j]: # neighbor from above 
                    val -= 30 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: # neighbor from left 
                    val -= 30 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (1,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro-1, extro))
            if extro: 
                val = 40 
                if i and prev[j]: 
                    val += 20 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: 
                    val += 20 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (2,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro, extro-1))
            return ans 
        
        return fn((0,)*n, 0, 0, introvertsCount, extrovertsCount)",0
"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return """".join(word1) == """".join(word2)",0
"class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        # set all 'a' char
        res = ['a' for _ in range(n)]
        k -= n
        
        idx = n - 1
        while k > 0:
            k += 1 # return num value of current 'a' char
            char_num_val = min(k, 26) # 26 - num value of 'z' char
            
            k -= char_num_val
            res[idx] = chr(char_num_val + 97 - 1) # '97' ascii code of 'a', but 1-indexed, so we must remove 1
            idx -= 1 # move idx
            
        return ''.join(res)",1
"class Solution:
    def waysToMakeFair(self, nums: List[int]) -> int:
        
        even=[]
        odd=[]
        e=0
        o=0
        
        for i in range(len(nums)):
            if i%2==0:
                e+=nums[i]
                
            else:
                o+=nums[i]
            
            even.append(e)
            odd.append(o)
            
        ans=0
        
        for i in range(len(nums)):
            if i%2==0:
                
                e1=even[i]
                e1-=nums[i]
                e1+= odd[len(nums)-1]
                e1-=odd[i]
                
                o1=odd[i]
                o1+=even[len(nums)-1]
                o1-=even[i]
                
                if e1==o1:
                    ans+=1
            else:
                o1=odd[i]
                o1-=nums[i]
                o1+=even[len(nums)-1]
                o1-=even[i]
                
                e1=even[i]
                e1+=odd[len(nums)-1]
                e1-=odd[i]
                
                if o1==e1:
                    ans+=1
        return ans",0
"class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        energy=0
        remain=0
        ar=[]
        
        for task in range(len(tasks)):
            ar.append((tasks[task][1]-tasks[task][0],task))
        ar.sort()

        for task in ar[::-1]:
            if tasks[task[1]][1]>remain:
                energy+=(tasks[task[1]][1]-remain)
                remain=task[0]
            else:
                remain-=tasks[task[1]][1]
                remain+=task[0]
                
        return energy",1
"class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        if word in sequence:
            replaced = sequence.replace(word, '0')
        else:
            return 0
        
        flag, ans = 0, 0
        for char in replaced:
            if char == '0':
                flag += 1
            else:
                ans = max(ans, flag)
                flag = 0
        ans = max(ans, flag)
        
        return ans",1
"class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        head=list1
        c=0
        while(c<=b):
            if c==a-1:
                prev=list1
                list1=list1.next
                prev.next=list2
            else:
                list1=list1.next
            c+=1
        while(list2.next):
            list2=list2.next
        list2.next=list1
        return head",1
"class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        
        def fn(nums): 
            """"""Return length of LIS (excluding x) ending at x.""""""
            ans, vals = [], []
            for i, x in enumerate(nums): 
                k = bisect_left(vals, x)
                if k == len(vals): vals.append(x)
                else: vals[k] = x
                ans.append(k)
            return ans 
        
        left, right = fn(nums), fn(nums[::-1])[::-1]
        
        ans = inf
        for i in range(1, len(nums)-1): 
            if left[i] and right[i]:
                ans = min(ans, len(nums) - left[i] - right[i] - 1)
        return ans",0
"class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        maxwealth=0
        for i in range(len(accounts)):
            maxwealth=max(maxwealth,sum(accounts[i]))
        return maxwealth",1
"class Solution:   # time limit
    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        return min(combinations(nums, k))",0
"class Solution:
    def minMoves(self, nums: List[int], limit: int) -> int:
        freq = {} # frequency table 
        lower, upper = [], []
        
        for i in range(len(nums)//2): 
            x = nums[i] + nums[~i]
            freq[x] = 1 + freq.get(x, 0)
            lower.append(min(nums[i], nums[~i]))
            upper.append(max(nums[i], nums[~i]) + 1 + limit)
        
        lower.sort()
        upper.sort()
        
        ans = inf
        for x in freq: 
            k = len(lower) - bisect_left(lower, x)
            kk = bisect_right(upper, x)
            val = len(nums)//2 - freq[x] + k + kk
            ans = min(ans, val)
        return ans",1
"class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if nums[i]%2!=0:
                nums[i]*=2
        minVal=min(nums)
        nums=[-val for val in nums]
        nums,ans=nums,float('inf')
        heapify(nums)
        while nums and abs(nums[0])%2==0:
            maxVal=abs(heappop(nums))
            ans=min(ans,abs(maxVal-minVal))
            maxVal=maxVal//2
            minVal=min(minVal,maxVal)
            heappush(nums,-maxVal)
        return min(ans,abs(min(nums))-abs(max(nums)))",0
"class Solution:
    def interpret(self, command: str) -> str:
        res = """"
        i = 0
        while i < len(command):
            if command[i] == ""G"":
                res += ""G""
                i += 1
            elif command[i] == ""("" and command[i+1] == "")"":
                res += ""o""
                i += 2
            else:
                res += ""al""
                i += 4
        return res",1
"class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        ans = 0
        if not nums or len(nums) == 1:
            return ans
        nums.sort()
        l = 0
        r = len(nums) - 1
        while l < r:
            s = nums[l] + nums[r]
            if s == k:
                ans += 1
                l +=1
                r -=1
            elif s > k:
                r -= 1
            else:
                l += 1
        return ans",1
"class Solution:
    def concatenatedBinary(self, n: int) -> int:
        s=''
        for i in range(1, n+1):
            s+=bin(i).replace(""0b"", """")
            # print(s)
        return int(s,2)%1000000007",1
"class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
                        
        partition_len = len(nums) // k        
                
        @functools.lru_cache(maxsize=None)
        def recurse(nums):            
            if not nums: return 0      
            
            result = float('inf')
            
            for combo in itertools.combinations(nums, partition_len):                
                
                if len(set(combo)) < partition_len: continue
                                                 
                updated_nums = list(nums) 
                for i in combo:
                    updated_nums.remove(i)
                                    
                result = min(
                    result,
                    max(combo) - min(combo) + recurse(tuple(updated_nums))
                )
                
            return result
        
        result = recurse(tuple(nums))
        
        return result if result != float('inf') else -1",1
"class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        
        consistentStringCount = 0
        setAllowed = set(allowed)
        
        for word in words:
            setWord = set(word)
            if len(setWord - setAllowed) == 0:
                consistentStringCount +=1
        return consistentStringCount",1
"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = []
        for i, x in enumerate(nums): 
            ans.append(prefix[-1] - 2*prefix[i] + (2*i - len(nums)) * nums[i])
        return ans",1
"class Solution:
    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:
        pq = [(-x-y, x, y) for x, y in zip(aliceValues, bobValues)]
        heapify(pq)
        
        s0 = s1 = i = 0
        while pq: 
            _, x, y = heappop(pq)
            if i: s1 += y
            else: s0 += x
            i ^= 1
        if s0 > s1: return 1
        if s0 < s1: return -1
        return 0",1
"class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        dp = [0] + [inf]*len(boxes)
        trips = 2
        ii = 0
        for i in range(len(boxes)):
            maxWeight -= boxes[i][1]
            if i and boxes[i-1][0] != boxes[i][0]: trips += 1
            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:
                maxWeight += boxes[ii][1]
                if boxes[ii][0] != boxes[ii+1][0]: trips-=1
                ii += 1
            dp[i+1] = dp[ii] + trips
        return dp[-1]",0
"class Solution:
    def numberOfMatches(self, n: int) -> int:
        matches=0
        while n > 1:
            if n%2==0:
                matches+=int(n/2)
                n = n/2
            else:
                matches+=int((n-1)/2)
                n = (n+1)/2
        return matches",1
"class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))",1
"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        n=len(stones)
        total=[stones[0]]
        for i in stones[1:]:
            total.append(total[-1]+i)
        new=[[0 for i in range(0,n)] for i in range(0,n)]
        for gap in range(1,n):
            for j in range(gap,n):
                i=j-gap
                if gap==1:
                    new[i][j]=max(stones[i],stones[j])
                else:
                    s1=total[j]-total[i]
                    if i==0:
                        s2=total[j-1]
                    else:
                        s2=total[j-1]-total[i-1]
                    new[i][j]=max(s1-new[i+1][j],s2-new[i][j-1])
        return new[0][-1]",0
"class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        cuboids = sorted((sorted(x, reverse=True) for x in cuboids), reverse=True)
        
        @lru_cache(None)
        def fn(i, h, l, w): 
            """"""Return max heights of stacking cuboids[i:].""""""
            if i == len(cuboids): return 0 # no cuboids left 
            hi, li, wi = cuboids[i]
            if hi <= h and li <= l and wi <= w: 
                return max(hi + fn(i+1, hi, li, wi), fn(i+1, h, l, w))
            else:
                return fn(i+1, h, l, w)
            
        return fn(0, inf, inf, inf)",0
"class Solution:
    def reformatNumber(self, number: str):
        pure_digits = number.replace(' ', '').replace('-', '')
        pure_digits_lengh = len(pure_digits)
        if pure_digits_lengh > 2:
            new_array = []
            count = 0
            temp = """"
            for d in pure_digits:
                if pure_digits_lengh - len("""".join(new_array)) == 4 and temp == """":
                    new_array.append(pure_digits[-4:-2])
                    new_array.append(pure_digits[-2:])
                    break
                count += 1
                temp += d
                if count == 3:
                    count = 0
                    new_array.append(temp)
                    temp = """"
            if temp:
                new_array.append(temp)

            return '-'.join(new_array)

        else:
            return pure_digits",0
"class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        
        res = 0
        start = 0
        cur = 0
        d = defaultdict(int)
        
        for end in range(len(nums)):
            item = nums[end]
            cur += item
            d[item] += 1
            while d[item] > 1:
                d[nums[start]] -= 1
                cur -= nums[start]
                if d[nums[start]] == 0:
                    del d[nums[start]]
                start += 1
            res = max(res, cur)
        return res",1
"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        t = [0 for _ in range(n)]
        t[n-1] = nums[n-1]
        for i in range(n-2, -1, -1):
            start = i+1
            end = min(n-1, i+k)
            temp = max(t[start:end+1])
            t[i] = nums[i] + temp
        return t[0]",1
"class Solution:
    def distanceLimitedPathsExist(self, n: int, A: List[List[int]], B: List[List[int]]) -> List[bool]:
        par = {}
        A.sort(key = lambda x: x[2])
        
        for i, query in enumerate(B):
            query.append(i)
        B.sort(key = lambda x: x[2])
        
        def find(a):
            par.setdefault(a, a)
            if par[a] != a:
                par[a] = find(par[a])
            return par[a]
        
        def union(a, b):
            par.setdefault(a, a)
            par.setdefault(b, b)
            par[find(a)] = par[find(b)]
        
        ans = [False]*len(B)
        i = 0
        for a, b, lim, idx in B:
            while i < len(A) and A[i][2] < lim:
                union(A[i][0], A[i][1])
                i += 1
            
            if find(a) == find(b):
                ans[idx] = True
        return ans",0
"class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int: 
        counts = [len(students) - sum(students), sum(students)]        
        for s in sandwiches:
            if not counts[s]:
                return sum(counts)
            counts[s] -= 1            
        return 0",1
"class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        next_wt = customers[0][0]+customers[0][1]
        time = []
        
        time.append(next_wt-customers[0][0])
        
        for i  in range(1,len(customers)):
            arr = customers[i][0]
            dep = customers[i][1]
            if arr < next_wt:
                wt = (next_wt-arr)+(arr+dep)
            else:
                wt = arr+dep
            time.append(wt  - arr)
            next_wt = wt
        #print(time)
        return sum(time)/len(time)",1
"class Solution:
    def maximumBinaryString(self, binary: str) -> str:
        if binary.count(""0"") <= 1: return binary 
        ones = binary.count(""1"", binary.index(""0""))
        return (len(binary)-ones-1)*""1"" + ""0"" + ones*""1""",0
"class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        loc = [i for i, x in enumerate(nums) if x]
        prefix = [0]
        for x in loc: prefix.append(prefix[-1] + x)
        
        ans = inf
        for i in range(len(loc)-k+1): 
            ans = min(ans, (prefix[i+k] - prefix[i+(k+1)//2]) - (prefix[i+k//2] - prefix[i]))
        return ans - (k//2)*((k+1)//2)",1
"class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        return sum(1 if i < len(s)//2 else -1 for i, c in enumerate(s) if c in 'aeiouAEIOU') == 0",0
"class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        n=len(days)
        l=[]
        le=0
        for i in range(n):
            if days[i]!=0 or apples[i]!=0:
                l.append([apples[i],days[i]+i])
                le+=1
        l.sort(key=lambda x:x[1])
        day=0
        res=0
        i=0
        while(i<le):
            A=l[i][0]
            D=l[i][1]
            if day<D:
                diff_days=D-day
  
                mn=min(diff_days,A)
                day+=mn
                res+=mn
            i+=1
  
        return res",1
"class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        def DFS(rows, columns, cur_row, cur_column):
            //Base Case
            if cur_row == rows:
                return cur_column
            //If direction is Right
            if cur_column < columns - 1 and (grid[cur_row][cur_column] == 1 and grid[cur_row][cur_column + 1] == 1):
                return DFS(rows, columns,  cur_row + 1, cur_column + 1)
            //If direction if Left
            elif 0 < cur_column and (grid[cur_row][cur_column] == -1 and grid[cur_row][cur_column - 1] == -1):
                return DFS(rows, columns,  cur_row + 1, cur_column - 1)
            //If direction is invalid
            else:
                return ""X""

        rows = len(grid)
        columns = len(grid[0])
        res = deque([])
        for i in range(columns):
            temp = DFS(rows, columns, 0, i)
            res.append(-1) if temp == ""X"" else res.append(temp)
        return res",0
"class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))
        ans = [-1]*len(queries)
        
        trie = {}
        k = 0
        for m, x, i in queries: 
            while k < len(nums) and nums[k] <= m: 
                node = trie
                val = bin(nums[k])[2:].zfill(32)
                for c in val: node = node.setdefault(int(c), {})
                node[""#""] = nums[k]
                k += 1
            if trie: 
                node = trie
                val = bin(x)[2:].zfill(32)
                for c in val: node = node.get(1-int(c)) or node.get(int(c))
                ans[i] = x ^ node[""#""]
        return ans",0
"class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        res = 0
        q = deque(sorted(boxTypes, key=lambda b: b[1], reverse=True))
        
        while q and truckSize:
            boxes, units = q.popleft()
            while boxes:
                if boxes <= truckSize:
                    res += boxes * units
                    truckSize -= boxes
                    boxes = 0
                else:
                    boxes -= 1
                    
        return res",0
"class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        """"""
        
            A + B == 1 << i
        
            A = 2 << i - B
        """"""
        
        result = 0
        seen = defaultdict(int)
        deliciousness.sort()
        
        for d in deliciousness:
            n = 1
            
            # because it is a sorted array. 
            # the maximum sum it can get by i-th number is deliciousness[i] + deliciousness[i]
            while n <= d + d:
                result = (result + seen[n-d]) % (10 ** 9 + 7)
                n = n << 1
                
            seen[d] += 1
        
        return result",1
"class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        pre_sum = [0]
        for n in nums:
            pre_sum.append(pre_sum[-1] + n)
        length = len(nums)
        ret, mid_l, mid_r = 0, 0, 0
        for i in range(1, length): 
            mid_l = max(mid_l, i + 1)
            while mid_l < length and 2 * pre_sum[i] > pre_sum[mid_l]:
                mid_l += 1
            mid_r = max(mid_r, mid_l)
            while mid_r < length and 2 * pre_sum[mid_r] <= pre_sum[i] + pre_sum[-1]:
                mid_r += 1
            ret += mid_r - mid_l
        return ret % 1_000_000_007",0
"class Solution(object):
    def minOperations(self, target, arr):
        d = {num: idx for idx, num in enumerate(target)}
        arr = [d.get(num, -1) for num in arr]
        res = []
        for num in arr:
            if num == -1: continue
            else:
                pos = bisect.bisect_left(res, num)
                if pos == len(res):
                    res.append(num)
                else:
                    res[pos] = min(res[pos], num)
        return len(target) - len(res)",0
"class Solution:
    def totalMoney(self, n: int) -> int:
        return n//7*28 + n//7*(n//7-1)//2*7 + (n%7)*(n//7+1) + (n%7-1)*(n%7)//2
            

class Solution2:
    def totalMoney(self, n: int) -> int:
        fullWeeks=n//7
        reminder=n%7
        totalMoney=28*fullWeeks + 7*(fullWeeks-1)*fullWeeks//2 + reminder*(fullWeeks+1) + (reminder-1)*reminder//2
        return totalMoney
            

class Solution1:
    def totalMoney(self, n: int) -> int:
        fullWeeks=0
        totalMoney=0
        for day in range(n):
            if day%7==0: fullWeeks+=1
            totalMoney+=fullWeeks+day%7
        return totalMoney",1
"class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        a, b = ""a"", ""b""
        if x < y: 
            x, y = y, x
            a, b = b, a
        ans = cnt0 = cnt1 = 0
        for c in s: 
            if c not in ""ab"": 
                ans += min(cnt0, cnt1) * y
                cnt0 = cnt1 = 0 
            elif c == b:
                if cnt0: 
                    cnt0 -= 1
                    ans += x
                else: cnt1 += 1
            else: cnt0 += 1
        return ans + min(cnt0, cnt1) * y",0
"class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
		# to check what all numbers have been used
        vis = [False] * (n + 1)
		
		# intermediate array to build the final sequence
        curr_list = [-1] * (2*n - 1)
        li, ans_list = self.recur(vis, curr_list, 0, n, n)
        return ans_list
        
    def recur(self, vis, curr_list, curr_ind, n, rem):
		# base conditon which is to check that we have used all the 'n' numbers
        if rem == 0:
            return True, curr_list
		
		# check what index we have to fill in the intermediate array
        while(curr_list[curr_ind] != -1 and curr_ind < 2 * n - 1):
            curr_ind += 1
        ans = False
        ans_list = None
        for i in range(len(vis) - 1, 0, -1):
			addition = i
			
			# special handling of '1'
            if i == 1:
                addition = 0
				
			# only numbers that are not already used and check for feasibility using the constraints given
           if not vis[i] and self.check_feasible(curr_list, curr_ind, addition, n):
                vis[i] = True
                curr_list[curr_ind] = i
                curr_list[curr_ind + addition] = i
                is_list, li = self.recur(vis, curr_list, curr_ind + 1, n, rem - 1)
                if is_list:
                    ans = True
                    ans_list = li
                    break
                curr_list[curr_ind] = -1
                curr_list[curr_ind + addition] = -1
                vis[i] = False
        return ans, ans_list
    
    def check_feasible(self, curr_list, curr_ind, addition, n):
        if curr_ind + addition < 2*n - 1 and curr_list[curr_ind] == -1 and curr_list[curr_ind + addition] == -1:
            return True
        return False",0
"class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        nodes = set()
        graph = {}
        degree = {}
        for x, y in pairs: 
            nodes |= {x, y}
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)
            degree[x] = 1 + degree.get(x, 0)
            degree[y] = 1 + degree.get(y, 0)
        
        if max(degree.values()) < len(nodes) - 1: return 0 # no root
        for n in nodes: 
            if degree[n] < len(nodes)-1: 
                nei = set()
                for nn in graph[n]: 
                    if degree[n] >= degree[nn]: nei |= graph[nn] # brothers &amp; childrens
                if nei - {n} - graph[n]: return 0 # impossible
        
        for n in nodes: 
            if any(degree[n] == degree[nn] for nn in graph[n]): return 2 # brothers 
        return 1",0
"class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for i in range(len(encoded)):
            arr.append(arr[i]^encoded[i])
        return arr",1
"class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        fast = head
        slow = head
        for i in range(1,k):
            fast = fast.next
        beg = fast
        while fast.next:
            fast = fast.next
            slow = slow.next
        
        tmp = beg.val
        beg.val = slow.val
        slow.val = tmp
        return head",1
"class Solution:
    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
        
        # idx to group id
        idx_to_group = {}
        # group id to index set
        group_to_idx = {}
        global_group_id = 0
        
        for swap in allowedSwaps:
            foundGroups = set()
            
            for idx in swap:
                if idx in idx_to_group:
                    foundGroups.add(idx_to_group[idx])
            
            if foundGroups:
                pivot = min(foundGroups)
                for group_id in foundGroups:
                    if pivot != group_id:
                        group_to_idx[pivot].update(group_to_idx[group_id])
                        group_to_idx.pop(group_id)

                group_to_idx[pivot].update(swap)

                for idx in group_to_idx[pivot]:
                    idx_to_group[idx] = pivot
            else:
                for idx in swap:
                    idx_to_group[idx] = global_group_id
                group_to_idx[global_group_id] = set(swap)
                global_group_id += 1
                
        ans = 0
        if group_to_idx == {}:
            for i in range(len(source)):
                if source[i]!=target[i]:
                    ans += 1
        else:
            for group_id in group_to_idx:
                src = {}
                tgt = {}
                for idx in group_to_idx[group_id]:
                    if source[idx] not in src:
                        src[source[idx]] = 0
                    src[source[idx]] += 1

                    if target[idx] not in tgt:
                        tgt[target[idx]] = 0
                    tgt[target[idx]] += 1

                for key in src:
                    if key in tgt:
                        if src[key] > tgt[key]:
                            ans += src[key] - tgt[key]
                    else:
                        ans += src[key]
            
            for i in range(len(source)):
                if i not in idx_to_group and source[i]!=target[i]:
                    ans += 1
            
        return ans",0
"class Solution:    
    def minimumTimeRequired(self, jobs: List[int], num_workers: int) -> int:
        n = len(jobs)
        worker_cost = [0] * (1 << n)
        for state in range(1 << n):
            for i in range(n):
                if state &amp; (1 << i):
                    worker_cost[state] += jobs[i]
                    
        @functools.cache
        def compute_time(state: int, curr_workers: int) -> int:
            if curr_workers == 1:
                return worker_cost[state]
            
            best = float(""inf"")
            worker_state = state
            while worker_state:
                if worker_cost[worker_state] < best:
                    best = min(best, max(compute_time(state ^ worker_state, curr_workers - 1), worker_cost[worker_state]))
                worker_state = (worker_state - 1) &amp; state
            
            return best
            
        return compute_time((1 << n) - 1, num_workers)",0
"class Solution:
    def countGoodRectangles(self, r: List[List[int]]) -> int:
        
        an=0
        ans=0
        for j in r:
            a=min(j)
            if a > an:
                an= a
                ans=1
            elif a==an:
                ans+=1
                
            
        return ans",1
"class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        hmap = {}
        output = 0
        for i in range(len(nums)):
            for j in range(i):
				# Skip if same number
                if i == j:
                    continue
                candidate = nums[i] * nums[j]
                if candidate in hmap:
                    output += hmap[candidate] * 8
                    hmap[candidate] += 1
                else:
                    hmap[candidate] = 1
        return output",1
"class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions
        ans = 0
        hist = [0] * n
        for i in range(m): 
            for j in range(n): 
                hist[j] = hist[j] + 1 if matrix[i][j] else 0
            for i, x in enumerate(sorted(hist, reverse=True)): 
                ans = max(ans, x*(i+1))
        return ans",1
"class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        m, n = len(grid), len(grid[0]) # dimensions 
        walls = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""F"": food = (i, j)
                elif grid[i][j] == ""C"": cat = (i, j)
                elif grid[i][j] == ""M"": mouse = (i, j)
                elif grid[i][j] == ""#"": walls.add((i, j))
                    
        @lru_cache(None)
        def fn(cat, mouse, turn): 
            """"""Return True if mouse wins.""""""
            if cat == food or cat == mouse or turn >= m*n*2: return False 
            if mouse == food: return True  # mouse reaching food
            
            if not turn &amp; 1: # mouse moving 
                x, y = mouse
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, mouseJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if fn(cat, (xx, yy), turn+1): return True 
                return False 
            else: # cat moving
                x, y = cat
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, catJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if not fn((xx, yy), mouse, turn+1): return False
                return True
                    
        return fn(cat, mouse, 0)",0
"class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        return max(0,max(itertools.accumulate(gain)))",0
"class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        
        languages = [None] + list(map(set, languages))
        friendships = [[u, v] for u, v in friendships if not languages[u] &amp; languages[v]]
        
        # teach whoever needs it
        return min([len({u
                        for pair in friendships
                        for u in pair
                        if lan not in languages[u]})
                   for lan in range(1, n+1)])",1
"class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        x = reduce(xor, list(range(1, len(encoded) + 2)))
        for i in range(1, len(encoded), 2): x ^= encoded[i]
        ans = [x]
        for x in encoded: ans.append(ans[-1] ^ x)
        return ans",1
"class Solution:
    def __init__(self):
        self.dp = {}
        
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        mod = 10 ** 9 + 7
        
        def dfs(n, val):
            if (n, val) not in self.dp:
                if n == 1: return 1
                temp = 1
                for k in range(val//2, 0, -1):
                    if val % k == 0:
                        temp += dfs(n-1, val // k)
                self.dp[n, val] = temp % mod
            return self.dp[n, val]
        
        res = []
        for n, val in queries:
            res.append(dfs(n, val))
        return res",0
"class Solution:
    def maximumTime(self, time: str) -> str:
        maxValues = {
            '0': '2',
            '1': {'0': '9', '1': '9', '2': '3'},
            '3': '5',
            '4': '9'
        }

        result = []
        for i, char in enumerate(time):
            if char == '?':
                if i == 0 and time[i + 1] != '?' and time[i + 1] >= '4':
                    result.append('1')
                elif i == 1:
                    result.append(maxValues['1'][result[i - 1]])

                else:
                    result.append(maxValues[str(i)])
            else:
                result.append(char)

        return ''.join(result)",0
"class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        pa, pb = [0]*26, [0]*26
        for x in a: pa[ord(x)-97] += 1
        for x in b: pb[ord(x)-97] += 1
        
        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3
        for i in range(25): 
            pa[i+1] += pa[i]
            pb[i+1] += pb[i]
            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2
            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1
        return ans",1
"class Solution:
    def kthLargestValue(self, matrix, k: int) -> int:
        large = [matrix[0][0]]
        n = len(matrix)
        m = len(matrix[0])
        for i in range(1, n):
            matrix[i][0] ^= matrix[i - 1][0]
            large.append(matrix[i][0])

        for j in range(1, m):
            matrix[0][j] ^= matrix[0][j - 1]
            large.append(matrix[0][j])

        for i in range(1, n):
            for j in range(1, m):
                matrix[i][j] ^= matrix[i][j - 1] ^ matrix[i - 1][j] ^ matrix[i - 1][j - 1]
                large.append(matrix[i][j])

        large.sort()
        return large[-k]",1
"class Solution:
    def minimumBoxes(self, n: int) -> int:
        boxesPlaced = 0
        maxFloor = 1
        boxesOnFloor = 0
        while boxesPlaced < n:
            for i in range(1, maxFloor + 1):
                boxesPlaced += i
                boxesOnFloor += 1
                if boxesPlaced >= n:
                    break
            maxFloor += 1
        return boxesOnFloor",1
"class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        d = {}
        for i in range(lowLimit, highLimit+1):
            d[sum(list(map(int,list(str(i)))))] = d.get(sum(list(map(int,list(str(i))))),0) + 1
        return max(d.values())",0
"class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        # map the relations between two elements using dictionary
        # key=element, value=[elements it is paired with]
        dict1={}
        for ii in adjacentPairs:
            if ii[0] in dict1.keys():
                dict1[ii[0]].append(ii[1])
            if ii[0] not in dict1.keys():
                dict1[ii[0]]=[ii[1]]
            if ii[1] in dict1.keys():
                dict1[ii[1]].append(ii[0])
            if ii[1] not in dict1.keys():
                dict1[ii[1]]=[ii[0]]
                
                
        # 1st and last element of series will have only pairing element in the list
        # finding those 2 elements
        #temp array to store those 2 elements
        gajab=[]  
        for ii in dict1.keys():
            if len(dict1[ii])==1:    # if len==1 it can be start or ending elemnt of list
                gajab.append(ii)
                
        # Initializing Solution array with all elemnts as Zero
        # len of solution array = len(pairs)+1
        ans=[0]*((len(adjacentPairs))+1)
        
        #Placing 1st and last element in array.You can make any of two element as STARTING or ENDING
        ans[0]=gajab[0]
        ans[-1]=gajab[1]
        
        #using 1st element in ANS array to find its relation element and then so on...
        for ii in range(len(ans)-1):
            pp=dict1[ans[ii]][0]
            dict1[pp].remove(ans[ii]) # removing the element relation that is already in ANS array
            ans[ii+1]=pp              # adding the element in ANS array at correct position
    
        return(ans)",0
"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum 
        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",0
"class Solution:
    def checkPartitioning(self, s: str) -> bool:
        n=len(s)
        pal=[[False]*n for i in range(n)]
        for i in range(n):
            pal[i][i]=True

        for i in range(n-1,-1,-1):
            for j in range(i+1,n):
                if i+1==j and s[i]==s[j]:
                    pal[i][j]=True
                if pal[i+1][j-1] and s[i]==s[j]:
                    pal[i][j]=True

        dp=[[False for i in range(4)] for j in range(n+1)]
        dp[n][3]=True     
        for ind in range(n-1,-1,-1):
            for i in range(ind,n):
                if pal[ind][i]:
                    dp[ind][2] |= dp[i+1][3]
                    dp[ind][1] |= dp[i+1][2]
                    dp[ind][0] |= dp[i+1][1]
        return dp[0][0]",0
"class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        c = Counter(nums)
        return sum(n for n, c in c.items() if c == 1)",1
"class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        
        def kadane(x):
            cmax = 0
            gmax = 0
            
            for i in x:
                if cmax < 0:
                    cmax = i
                else:
                    cmax+=i
                gmax = max(cmax, gmax)
            return gmax
        
        return max(kadane(nums), kadane(-i for i in nums))",1
"class Solution:
    def minimumLength(self, s: str) -> int:
        left = 0
        right = len(s)-1
        if len(s) == 1:
            return 1
        while left < right and s[left] == s[right] :
            while left < right and s[left] == s[left + 1]:
                left+=1
            if left == right:
                return 0
            left+=1
            while left < right and s[right] == s[right - 1]:
                right-=1
            right-=1
        return right - left + 1
		
``",0
"class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        n=len(events)
        events.sort()
        @lru_cache(None)
        def dfs(ind,k):
            if ind==n or k==0:
                return 0
            ans=dfs(ind+1,k)
            nextInd=bisect.bisect_left(events,[events[ind][1]+1])
            ans=max(ans,events[ind][2]+dfs(nextInd,k-1))
            return ans
        return dfs(0,k)",1
"class Solution:
    
    def check(self, nums: List[int]) -> bool:
        res = 0
        n = len(nums)
        for i in range(n):
            if nums[i] > nums[(i+1) % n]:
                res += 1
        return res <= 1",1
"class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        a, b, c = sorted((a, b, c))
        
        if a + b <= c:
            return a + b
        
        return a + (b + c - a) // 2",1
"class Solution:
    def largestMerge(self, w1: str, w2: str) -> str:
        
        def dfs(m, w1, w2):
            if not w1 or not w2:
                return m + (w1 if w1 else w2)
            if w1 >= w2:
                return dfs(m+w1[0], w1[1:], w2)
            elif w1 < w2:
                return dfs(m+w2[0], w1, w2[1:])
            #else:
                #return max(dfs(m+w1[0], w1[1:], w2), dfs(m+w2[0], w1, w2[1:]))
        return dfs("""", w1, w2)",0
"class Solution:
    def solve(self, nums, i, val, sums):
        if i == len(nums):
            sums.append(val)
            return
        self.solve(nums, i+1, val+nums[i], sums)
        self.solve(nums, i+1, val, sums)
        
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        n = len(nums)
        sum1, sum2 = [], []
        self.solve(nums[:n//2], 0, 0, sum1)
        self.solve(nums[n//2:], 0, 0, sum2)
        
        sum2 = sorted(sum2)
        #print(sum1, sum2)
        n2 = len(sum2)
        ans = float(""inf"")
        for s in sum1:
            rem = goal-s
            i = bisect_left(sum2, rem)
            if i < n2:
                ans = min(ans, abs(rem-sum2[i]))
            if i > 0:
                ans = min(ans, abs(rem-sum2[i-1]))
        return ans",0
"class Solution:
    def minOperations(self, s: str) -> int:
        return min((cnt := s[::2].count('1') + s[1::2].count('0')), len(s) - cnt)",0
"class Solution:
    def countHomogenous(self, s: str) -> int:
        cnt = 0
        i = 0
        j = 1
        
        while j < len(s):
            if s[i] != s[j]:
                diff = j-i
                cnt += ((diff) * (diff+1)) // 2
                i = j
                j += 1
            
            else:
                j += 1
        
        diff = j-i
        cnt += ((diff) * (diff+1)) // 2
        
        return cnt % ((10**9) + 7)",1
"class Solution:
    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        l = 1
        r = max(nums)
        
        while l < r:
            mid = l + (r-l) // 2
            count = self.count(mid,nums)
            if count <= maxOperations:
                r = mid
            else:
                l = mid+1
        return r  # or l
    
    
    def count(self,n,arr):
        return sum((a-1) // n for a in arr)",1
"class Solution:
    def getAdjLists(self, edges):
        adj = defaultdict(list)
        for u,v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return adj
    def getAdjSets(self, edges):
        adj = defaultdict(set)
        for u,v in edges:
            adj[u].add(v)
            adj[v].add(u)
        return adj
    
    def minTrioDegree1TLE(self, n: int, edges: List[List[int]]) -> int:
        # somehow compress the trio so it is considered a single node?
        # O(N^3) keep picking random three points, check if trio and 
        res = math.inf

        adj = self.getAdjLists(edges)
        adjSet = self.getAdjSets(edges)
        
        for u in range(1,n+1):
            for v in adj[u]:
                for choice in adj[v]:
                    if choice in adjSet[u] or u in adjSet[choice]: 
                        # it is a common point!
                        res = min(res, len(adj[u]) + len(adj[v]) + len(adj[choice]) - 3)
        return res if res < math.inf else -1
    
    def minTrioDegree2TLE(self, n: int, edges: List[List[int]]) -> int:
        # O(EN) pick any random two connected points(edge), search for 
        # possible third points e.g. [1,2] is an edge so adj[1] intersect adj[2]
        res = math.inf
        # after getting this how to get the degree?
        # len(adj[1]) + len(adj[2]) + len(adj[3]) - 6 (the trio edges)
        adj = self.getAdjSets(edges)
        for u,v in edges:
            # search for all the 'trio' points
            for trio_point in adj[u] &amp; adj[v]:
                res = min(res, len(adj[u]) + len(adj[v]) + len(adj[trio_point]) - 3 - 3)
                
        return res if res < math.inf else -1
    
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        # O(N^3) pick any random two connected points(edge), search for 
        res = math.inf
        adj = self.getAdjSets(edges)

        for u in range(1,n+1):
            for v in range(u+1, n+1):
                for trio_point in range(v+1, n+1):
                    if v in adj[u] and trio_point in adj[u] and trio_point in adj[v]:
                        res = min(res, len(adj[u]) + len(adj[v]) + len(adj[trio_point]) - 3 - 3)
        
        return res if res < math.inf else -1",0
"class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        def isNice(s):
            pivot = -1
            if len(s) < 2:
                return ["""", 0]
            unorderedSet = set([x for x in s])
            for i in range(len(s)):
                if ord(s[i])<96:
                    if s[i].lower() not in unorderedSet:
                        pivot = i
                else:
                    if s[i].upper() not in unorderedSet:
                        pivot = i                        
            if pivot>=0:
                if pivot == len(s)-1:
                    return isNice(s[:pivot])
                a = isNice(s[:pivot])
                b = isNice(s[pivot+1:])            
                return a if a[1]>=b[1] else b
            else:
                print(s, len(s))
                return [s, len(s)]
        [x1, x2] = isNice(s)
        return x1",0
"class Solution:
    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        groups_n = sum(len(group) for group in groups)
        nums_n = len(nums)
        
        if groups_n > nums_n:
            return False
        
        i = 0
        for group in groups:
            n = len(group)
            while nums_n - i >= n:
                if nums[i:i+n] == group:
                    break
                i += 1
            if nums_n - i < n:
                return False
            else:
                i += n
        return True",1
"class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        queue = deque()
        rows = len(isWater)
        cols = len(isWater[0])
        
        for i in range(rows):
            for j in range(cols):
                if isWater[i][j] == 1:
                    queue.append((i,j))
                    isWater[i][j] = 0 # set height of water as 0
                else:
                    isWater[i][j] = '$' # mark the land
                    
        while queue:
            row, col = queue.popleft()
            
            for x, y in [(0,1),(1,0),(0,-1),(-1,0)]:
                nRow = row + x
                nCol = col + y
                
                if 0<=nRow<rows and 0<=nCol<cols and isWater[nRow][nCol] == '$':
                    isWater[nRow][nCol] = isWater[row][col]+1
                    queue.append((nRow, nCol))
                    
        return isWater",0
"class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        
        gcdset = [set() for i in range(51)]
        for i in range(1,51):
            for j in range(1,51):
                if math.gcd(i,j) == 1:
                    gcdset[i].add(j)
                    gcdset[j].add(i)
        
        graph = defaultdict(list)
        for v1, v2 in edges:
            graph[v1].append(v2)
            graph[v2].append(v1)
        
        ans = [-1]*len(nums)
        q = [[0, {}]]
        seen = set([0])
        depth = 0
        while q:
            temp = []
            for node, ancestors in q:
                index_depth = (-1,-1)
                for anc in list(ancestors.keys()):
                    if anc in gcdset[nums[node]]:
                        index, d = ancestors[anc]
                        if d > index_depth[1]:
                            index_depth = (index,d)
                ans[node] = index_depth[0]
                
                copy = ancestors.copy()
                copy[nums[node]] = (node,depth)
                
                for child in graph[node]:
                    if child not in seen:
                        seen.add(child)
                        temp.append([child, copy])
            q = temp
            depth += 1
        return ans
'''

**:)**",0
"class Solution(object):
    def mergeAlternately(self, word1, word2):
        """"""
        :type word1: str
        :type word2: str
        :rtype: str
        """"""
        # edge cases - 
        if word1 is None:
            return word2
        if word2 is None:
            return word1
        if word1 is None and word2 is None:
            return """"
        else:
            strr = """"
            l1 = len(word1)
            l2 = len(word2)
            for (i,j) in zip(range(l1), range(l2)):
                strr +=word1[i]
                strr +=word2[j]
            if i!=l1-1:
                strr += word1[i+1:]
            if j!=l2-1:
                strr += word2[j+1:]
            #print(strr)
            return strr",1
"class Solution:
    def minOperations(self, b: str) -> List[int]:
        l=[]
        for i in range(len(b)):
            a=0
            for j in range(len(b)):
                if(i!=j and b[j]==""1""):
                    a+=abs(j-i)
            l.append(a)
        return l",1
"class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        m, n = len(multipliers), len(nums)
        # let dp[i][j] denote the maximum score using the first i elements
        # and last j elements from nums
        dp = [[-float(""inf"")]*(m+1) for _ in range(m+1)]
        
        # initialization, populate the first row and column of the
        # dp table
        dp[0][0] = 0
        for i in range(1, m+1):
            dp[i][0] = dp[i-1][0]+multipliers[i-1]*nums[i-1]
            dp[0][i] = dp[0][i-1]+multipliers[i-1]*nums[-i]
        
        # state transition, populate the dp table inward
        # dp[n_left][n_right] = max(score if the last num used was from the left,
        #                           score if the last num used was from the right)
        ret = -float(""inf"")
        for n_used in range(1, m+1):
            for n_left in range(n_used+1):
                n_right = n_used-n_left
                dp[n_left][n_right] = max(dp[n_left-1][n_right]+multipliers[n_used-1]*nums[n_left-1],
                                          dp[n_left][n_right-1]+multipliers[n_used-1]*nums[-n_right])
                if n_used == m:
                    ret = max(ret, dp[n_left][n_right])
                    
        return ret",0
"class Solution(object):
  def countMatches(self, items, ruleKey, ruleValue):
    output = 0
    itemsi = [""type"",""color"",""name""]
    ruleKey = itemsi.index(ruleKey)
    for i in items:
      if i[ruleKey] == ruleValue:
        output += 1
    return output",1
"class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:        
        @lru_cache(None)
        def dp(t, i):
            if t <= 0 or i == len(toppingCosts):
                return t
            
            useOne = dp(t - toppingCosts[i], i + 1)
            if useOne == 0:
                return 0
            useTwo = dp(t - toppingCosts[i] * 2, i + 1)
            if useTwo == 0:
                return 0
            useNone = dp(t, i + 1)
            if useNone == 0:
                return 0
            
            minimum = min((abs(useOne), -useOne), (abs(useTwo), -useTwo), (abs(useNone), -useNone))
            return -minimum[1]
        
        minimum = float('inf')
        for b in baseCosts:
            toFind = target - b
            res = b + toFind - dp(toFind, 0)
            minimum = min((abs(target - minimum), minimum), (abs(target - res), res))[1]
            if minimum == target:
                return minimum
        
        return minimum",0
"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
                        
        # Get the delta
        # We want sum(nums1) > sum(nums2) so we can use logic below
        delta = sum(nums1) - sum(nums2) 
        if delta < 0:
            nums1, nums2 = nums2, nums1
            delta = -delta
            
        # Dumb edge case
        if delta == 0: return 0
            
        # Their ranges do not overlap, impossible to return result
        if len(nums1)*1 > len(nums2)*6: return -1
        
        # Calculate the max subtractions
        max_subtract = collections.defaultdict(int)        
        for i in nums1: max_subtract[i-1] += 1
        for j in nums2: max_subtract[6-j] += 1
            
        # Greedily subtract from delta
        result = 0
        for val, count in sorted(max_subtract.items(), key = lambda x: x[0], reverse=True):
            for _ in range(count):                
                delta -= min(val, delta)
                result += 1       
                if delta == 0:
                    return result
                    
        return result",0
"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        times = [float(-1) for _ in range(len(cars))]
        for i in range(1, len(cars)):
            if cars[i-1][1] > cars[i][1]:
                times[i-1] = self.timeToCollide(cars, i-1, i)
        for i in range(len(cars)-3, -1, -1):
            if times[i+1] == - 1.0: continue
			# if car[i+1] collided before car[i], then we have to adjust times[i]
            if times[i] > times[i+1]:
                times[i] = self.correctTime(cars, times, i)
                cars[i+1][1] = cars[i+2][1]
			# if car[i+1] collided and speed became slower than cars[i], then we also have to adjust times[i]
            elif cars[i][1] <= cars[i+1][1] and times[i+1] > 0.0:
                if cars[i][1] > cars[i+2][1]:
                    times[i] = self.timeToCollide(cars, i, i+2)
        return times
        
    def timeToCollide(self, cars, i, j): 
        return (cars[j][0]-cars[i][0])/(cars[i][1] - cars[j][1])
    def correctTime(self, cars, times, i):
        return times[i+1] + (times[i]-times[i+1])*(cars[i][1] - cars[i+1][1])/(cars[i][1] - cars[i+2][1])",0
"class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        
		def manhattan_dist(x1, y1, x2, y2):
            return abs(x1-x2) + abs(y1-y2)
        
		# It's always handy to initialize using float('inf') or float('-inf') if you want really
		# large or small numbers! :)
        min_dist = float('inf')
        min_idx = -1
        
        for i in range(len(points)):
			# If coordinate is valid, then do checks on manhattan_dist
            if points[i][0] == x or points[i][1] == y:
			
				# If the valid coordinate is smaller, then update the index and min_dist
				dist = manhattan_dist(x, y, points[i][0], points[i][1])
                if min_dist > dist:
                    min_dist = dist
                    min_idx = i
                
        return min_idx",0
"class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        
        '''
        Here we make a ternary representation of given n
        If n has '2' in it return False, else return True
        [See: hint]
        '''
        
        ternary = ''                       #ternary string is the reverse representation of original ternary
        
        while n>0:
            ternary+=str(n%3)              #ternary means base 3
            n=n//3
            
        if '2' in ternary:
            return False
        return True",1
"class Solution(object):
    def beautySum(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        res = 0
        h = [0 for _ in range(26)]
        for i in range(len(s)):
            h = [0 for _ in range(26)]
            for j in range(i, len(s)):
                h[ord(s[j]) - ord('a')] += 1
                minv, maxv = 501, -1
                for x in h:
                    if x > 0:
                        minv = min(minv, x)
                        maxv = max(maxv, x)
                res += maxv - minv
        return res",1
"class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0]*n
        freq = defaultdict(int)
        for u, v in edges: 
            degree[u-1] += 1
            degree[v-1] += 1
            freq[min(u-1, v-1), max(u-1, v-1)] += 1
        
        vals = sorted(degree)
        
        ans = []
        for query in queries: 
            cnt = 0 
            lo, hi = 0, n-1
            while lo < hi: 
                if query < vals[lo] + vals[hi]: 
                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid
                    hi -= 1
                else: lo += 1
            for u, v in freq: 
                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1
            ans.append(cnt)
        return ans",0
"class Solution:
def checkOnesSegment(self, s: str) -> bool:
    flag=0
    for i in s:
        if i=='1' and flag==1:
            return False 
        elif i=='0':
            flag=1
            
    return True",1
"class Solution:
def minElements(self, nums: List[int], limit: int, goal: int) -> int:
    return abs(goal-sum(nums))//limit+(abs(goal-sum(nums))%limit!=0)*1",0
"class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        # Dijkstra's algorithm
        distances = {i: float('inf') for i in range(1, n+1)}
        distances[n] = 0
        graph = defaultdict(list)
        for edge in edges:
            graph[edge[0]].append((edge[1], edge[2]))
            graph[edge[1]].append((edge[0], edge[2]))
        pq = [(0, n)]
        while len(pq) > 0:
            curDistance, curVertex = heapq.heappop(pq)
			# skip the following steps if we've already visited the vertex
            if curDistance > distances[curVertex]:
                continue
            for edge in graph[curVertex]:
                neighbor = edge[0]
                weight = edge[1]
                distance = curDistance + weight
                # update neighbor's distance if the path via cur node has a shorter distance
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
		# Bottom-up DP
        # initialize dp array, which stores how many restricted paths between endnode and curnode
        dp = [0]*(n+1)
        dp[n] = 1
        dist = sorted(list(distances.keys()), key=lambda item:distances[item])
        for index in dist:
            neighbors = [edge[0] for edge in graph[index]]
            for neighbor in neighbors:
                if distances[neighbor] < distances[index]:
                    dp[index] += dp[neighbor]
                    dp[index] = int(dp[index]%(1e9+7))
            # when we've reached node 1 (start node), we could return the result
            if index == 1:
                return dp[1]
        return -1",0
"class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        freq = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row
        
        n = 1 << 10
        dp = [0] + [-inf]*(n-1)
        for i in range(k): 
            mx = max(dp)
            tmp = [0]*n
            for x, c in enumerate(dp): 
                for xx, cc in freq[i].items(): 
                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)
            dp = tmp 
        return len(nums) - dp[0]",0
"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if not set(s1) == set(s2):
            return False
        return sum(1 for i in range(len(s1)) if not s1[i] == s2[i]) < 3",0
"class Solution:
    def findCenter(self, edge: List[List[int]]) -> int:
        if edge[0][0] in edge[1]:
            return edge[0][0]
        else:
            return edge[0][1]",1
"class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        heap_classes = []
        for p, t in classes:
            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))
        for _ in range(extraStudents):
            diff, p, t = heappop(heap_classes)
            p += 1
            t += 1
            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))
        return sum(p / t for d, p, t in heap_classes) / len(classes)",0
"class Solution:
    def maximumScore(self, n: List[int], kk: int) -> int:
        
        vmin = n[kk]
        for i in range(kk,-1,-1):
            if n[i]<vmin:
                vmin = n[i]
            else:
                n[i] = vmin

        vmin = n[kk]
        for i in range(kk,len(n)):
            if n[i]<vmin:
                vmin = n[i]
            else:
                n[i] = vmin

        good = 0
        li = 0
        ri = len(n)-1
        while li<=kk and ri>= kk:
            vmin = min(n[li],n[ri])
            if vmin*(ri-li+1)>good:
                good = min(n[li],n[ri])*(ri-li+1)
            
            if li == ri:
                break
                
            while li<kk and n[li]==vmin:
                li += 1
                
            while ri>kk and n[ri]==vmin:
                ri -= 1
            
        
        return good",0
"class Solution:
    def secondHighest(self, s: str) -> int:
        seen = set()
        for c in s: 
            if c.isdigit(): 
                seen.add(int(c))
        return -1 if len(seen) < 2 else sorted(seen)[-2]",1
"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1
        for x in sorted(coins): 
            if ans < x: break 
            ans += x
        return ans",1
"class Solution:
    def maxScore(self, nums: List[int]) -> int:
        def combination(count=1, bitmask=0):
            if count==size//2+1:
                return 0
            max_ = 0
            for i in range(size):
                if bitmask>>i&amp;1:
                    continue
                newBitmask = bitmask|1<<i
                for j in range(size):
                    if newBitmask>>j&amp;1:
                        continue
                    newBitmask = bitmask|1<<i|1<<j
                    if dp[newBitmask]:
                        max_ = max(max_, table[i][j]*count+dp[newBitmask])
                    else:
                        max_ = max(max_, table[i][j]*count+combination(count+1, newBitmask))
            dp[bitmask] = max_
            return max_
        size = len(nums)
        dp = [0]*(2**size)
        table = [[0]*size for i in range(size)]
        for i in range(size):
            for j in range(i+1, size):
                table[i][j] = table[j][i] = math.gcd(nums[i], nums[j])
        return combination()",0
"class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        total = 0
        max_total = 0
        i = 0

        while i < len(nums):
            if nums[i] <= nums[i-1]:
                total = 0
            total += nums[i]
            max_total = max(total, max_total)
            i += 1
        return max_total",1
"class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        backlog = defaultdict(list)
        for price, amount, ordertype in orders:
            #sell
            if ordertype == 1:
                if backlog[0]:
                    condition = True
                    while condition and backlog[0]:
                        bp, ba = heapq.heappop(backlog[0])
                        if -bp >= price:
                            if amount < ba:
                                ba -= amount
                                amount = 0
                                heapq.heappush(backlog[0], [bp, ba])
                                condition = False
                            elif amount > ba:
                                amount -=ba 
                            else:
                                amount = 0
                        else:
                            heapq.heappush(backlog[0], [bp,ba])
                            heapq.heappush(backlog[1], [price, amount])
                            amount = 0
                            condition = False
                    if amount:
                        heapq.heappush(backlog[1], [price, amount])
                else:
                    heapq.heappush(backlog[1], [price, amount])
            #buy
            if ordertype == 0:
                if backlog[1]:
                    condition = True
                    while condition and backlog[1]:
                        sp, sa = heapq.heappop(backlog[1])
                        if sp <= price:
                            if amount < sa:
                                sa -= amount
                                amount = 0
                                heapq.heappush(backlog[1], [sp, sa])
                                condition = False
                            elif amount > sa:
                                amount -=sa
                            else:
                                amount = 0
                        else:
                            heapq.heappush(backlog[1], [sp, sa])
                            heapq.heappush(backlog[0], [-price, amount])
                            amount = 0
                            condition = False
                    if amount:
                        heapq.heappush(backlog[0], [-price, amount])
                else:
                    heapq.heappush(backlog[0], [-price, amount])
            #print(backlog[0], backlog[1])
        res = 0
        for i,j in backlog[0]:
            res += j
        for i,j in backlog[1]:
            res += j
        return res % (10**9 + 7)",0
"class Solution:

    @classmethod
    def min_area(cls, len_arr, idx, target):
        if target + idx >= len_arr:
            sum_r = (2 * target - len_arr + idx) * (len_arr - 1 - idx) // 2
        else:
            sum_r = target * (target - 1) // 2 + len_arr - idx - target
        if target - idx >= 1:
            sum_l = (2 * target - 1 - idx) * idx // 2
        else:
            sum_l = target * (target - 1) // 2 + idx - target + 1
        return sum_l + sum_r + target

    def maxValue(self, n: int, index: int, maxSum: int) -> int:
        left, right = 1, maxSum - n + 2
        while left + 1 < right:
            middle = (left + right) // 2
            if Solution.min_area(n, index, middle) <= maxSum:
                left = middle
            else:
                right = middle
        return left",0
"class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        nums = ""0123456789""
        for i in range(len(word)):
            if word[i] not in nums:
                word = word.replace(word[i], "" "")
    
        w = word.split()
        for i in range(len(w)):
            w[i] = int(w[i])
        w = set(w)
       return len(w)",1
"class Solution:
    def reinitializePermutation(self, n: int) -> int:
        perm=[i for i in range(n)]
        op=list(perm)
        arr=[0]*n
        c=0
        nn=n//2
        
        while arr!=op:
            for i in range(n):
                if i%2 == 0:
                    arr[i] = perm[i // 2]
                else:
                    arr[i] = perm[int(nn + (i - 1) // 2)]
            perm = list(arr)

            c+=1
        return c",1
"class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        answers = {}
        keys = [n.split('(')[-1] for n in s.split(')')][:-1]
        
        for k, v in knowledge:
            answers[k] = v

        for key in keys:
            s = s.replace(f'({key})', answers.get(key, '?'))

        return s",1
"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        mod = 1_000_000_007
        if primeFactors % 3 == 0: return pow(3, primeFactors//3, mod)
        if primeFactors % 3 == 1: return 1 if primeFactors == 1 else 4*pow(3, (primeFactors-4)//3, mod) % mod
        return 2*pow(3, primeFactors//3, mod) % mod",0
"class Solution:
    def squareIsWhite(self, c: str) -> bool:
        return True if (ord(c[0])-96 + int(c[1]))%2!=0 else False",0
"class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        # this is the solution for comparing char-wise, but the question is asking for word-wise :(
        #############################################################################
        # According to the 'similarity' definition given, 
        # if we can insert some chars (could be empty) to make 
        # inserted sentence1 == sentence2 (assume len(sentence1) <= len(sentence2))
        #############################################################################
        # Idea: 
        #       view sentence 1 as prefix + arbitrary sentence to insert (possibly empty) + suffix 
        #       view sentence 2 as prefix + middle chars + suffix 
        # 1. compare sentence1 and sentence2 until they are not matched (it is prefix)
        # 2. rest of sentence2 is suffix -> if this suffix exists in sentence1 -> similar (otherwise not)
        ''' this is the solution for comparing char-wise, but the question is asking for word-wise :(
        if len(sentence1) == len(sentence2):
            return sentence1 == sentence2 
        
        # make sure sentence1 has shorted length 
        if len(sentence1) > len(sentence2):
            sentence1, sentence2 = sentence2, sentence1

        # find the end of prefix 
        # if char is unmatched => compare suffix
        for idx, c in enumerate(sentence1):
            if not (c == sentence2[idx]):
                return sentence1[idx:] == sentence2[-(len(sentence1)-idx):]
        return True 
        '''
        
        # adjust from our char-wise solution
        # w for word 
        s1 = sentence1.split() 
        s2 = sentence2.split() 
        if len(s1) == len(s2):
            return all([w1==w2 for (w1, w2) in zip(s1, s2)])
        
        # make sure sentence1 has shorted length 
        if len(s1) > len(s2):
            s1, s2 = s2, s1 

        # find the end of prefix &amp; compare suffix 
        for idx, w in enumerate(s1):
            if not (w == s2[idx]):
                return all([w1==w2 for (w1, w2) in zip(s1[idx:], s2[-(len(s1)-idx):])])
        return True",0
"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        ans = 0 
        freq = defaultdict(int)
        for x in nums: 
            x -= int(str(x)[::-1])
            ans += freq[x]
            freq[x] += 1
        return ans % 1_000_000_007",1
"class Solution:
    def maxHappyGroups(self, bs: int, gs: List[int]) -> int:
        c = {i: 0 for i in range(bs)}
        for g in gs:
            c[g % bs] += 1
        ret = c[0]
        c[0] = 0
        
        
        def get_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        def get_diff_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] - 1 if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        for tc in range(2, bs):
            for keys in get_diff_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
        tc = 2
        while True:
            for keys in get_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
            if tc > sum(c.values()): break
            tc += 1
        return ret + bool(sum(c.values()))
            
        ```",0
"class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        return ' '.join(s.split()[0:k])",1
"class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        log = defaultdict(set)
        for x, y in logs:
            log[x].add(y)
        
        output = [0]*k
        for i in log.values():
            output[len(i)-1] += 1
        
        return output",1
"class Solution:
    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
        
        n = len(nums1)
        MOD = 10**9+7
        
        # Maintain a MAX heap defined as structure - (abs_diffi, nums1[i], nums[j])
        heap = []
        abs_sum = 0
        for i in range(n):
            abs_diff = abs(nums1[i]-nums2[i])
            abs_sum = (abs_sum+abs_diff)%MOD
            heapq.heappush(heap,(-abs_diff, nums1[i], nums2[i])) # note the -ve sign to make it max_heap
        
        print(heap)
        
        # Get the element with max absolute difference from heap
        top = heapq.heappop(heap)
        abs_sum -= abs(top[0]) # subtract previous abs_diff as we'll update it below
        k = top[2]
        
        # find a new_val closest to k
        # and min_diff is the new absoulte diff with k
        min_diff = abs(top[0])
        new_val = 0
        for num1 in nums1:
            new_diff = abs(num1-k)
            if new_diff<min_diff:
                min_diff = new_diff
                new_val = num1
        
        # add the new diff to calculate updated sum
        abs_sum = (abs_sum+min_diff)%MOD
        
        return abs_sum",0
"class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        nums = set(nums)
        
        ans = 0
        m = max(nums)
        for x in range(1, m+1): 
            g = 0
            for xx in range(x, m+1, x): 
                if xx in nums: 
                    g = gcd(g, xx)
            if g == x: ans += 1
        return ans",1
"class Solution:
    def arraySign(self, nums: List[int]) -> int:
        if 0 in nums:
            return 0
        count = 1
        for i in nums:
            if i < 0:
                count *= -1
        return count",1
"class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        class Node:
            def __init__(self,val):
                self.prev = None
                self.next = None
                self.val = val
        
        head = Node(1)
        temp = head
        i = 2
        while i<n:
            nnode = Node(i)
            temp.next = nnode
            nnode.prev = temp
            temp = temp.next
            i += 1
        lastnode = Node(n)
        temp.next = lastnode
        lastnode.prev = temp
        lastnode.next = head
        head.prev = lastnode
        
        
        ##game
        start,prevnode = head,head.prev
        while start:
            if start == start.next:                             #case to check if this node is the winner
                return start.val
            i = 1
            while i<k:                                             #move k number of steps 
                prevnode = start
                start = start.next
                i += 1
            
            #delete this node
            p = start.next
            prevnode.next = p
            p.prev = prevnode
            start = p",0
"class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        lanes = [1, 0, 1]
        for obstacle_id in obstacles:
            if obstacle_id == 0:
                lanes[0] = min(lanes[0], lanes[1] + 1, lanes[2] + 1)
                lanes[1] = min(lanes[1], lanes[0] + 1, lanes[2] + 1)
                lanes[2] = min(lanes[2], lanes[0] + 1, lanes[1] + 1)
            elif obstacle_id == 1:
                lanes[0] = inf
                lanes[1] = min(lanes[1], lanes[2] + 1)
                lanes[2] = min(lanes[1] + 1, lanes[2])
            elif obstacle_id == 2:
                lanes[1] = inf
                lanes[0] = min(lanes[0], lanes[2] + 1)
                lanes[2] = min(lanes[2], lanes[0] + 1)
            elif obstacle_id == 3:
                lanes[2] = inf
                lanes[0] = min(lanes[0], lanes[1] + 1)
                lanes[1] = min(lanes[1], lanes[0] + 1)
        return min(lanes)",0
"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        minimumOperations = 0
        
        for i in range(1, len(nums)): # Note that for loop starts with index 1 (we skip the index 0)
            if nums[i] <= nums[i-1]:
                oldNumber = nums[i]
                nums[i] = nums[i-1] + 1 # update the current number to new number in the input list
                newNumber = nums[i]
                
                minimumOperations += (newNumber - oldNumber)
                
        return minimumOperations",1
"class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        
        res = []
        for x,y,r in queries:
            rsq = pow(r,2)
            count = 0
            for px,py in points:
                ans = pow(px-x,2)+pow(py-y,2)
                if ans<= rsq:
                    count += 1
            res.append(count)
        return res",1
"class Solution:
    '''
    Step 1: Building a xor array.
    eg :[0,1,1,3]
    xor = [0]
    now 0 xor 1 [0,1]
    now 1 xor 1 [0,1,0]
    finally 0 xor 3 [0,1,0,3]
    
    step 2:
    Now to find the value of k at each query we just want to take the len(2^maxbit-1 )so here its 2 digit(maxBit =2 so 2^2 = 4 ) .
    no.of bits in 3 are 2
    value of k will be inverse of xor value[i]
    eg :
    when i = 0 xor[i] = 0 what will be the value of k in this case when bits are 2
    00 xor inverse(00)
    inverse(00) = 11
    hence k = 3
    
    '''
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        xor = []
        maxb = len(bin(pow(2,maximumBit)-1)[2:])
        
        n = len(nums)
        xor.append(nums[0])
        for i in range(1,n):                                        #step 1
            xor.append(nums[i]^xor[i-1])
        
        res = []
        for xor_val in xor: 
            bin_xor_val = list(bin(xor_val)[2:])
            temp = []
            for i in range(maxb-len(bin_xor_val)):                  
                temp.append('1')
            
            for bit in bin_xor_val:                                 #performing inverse of the xor value
                if bit == '0':
                    temp.append('1')
                else:
                    temp.append('0')
            res.append(int(''.join(temp),2))
        
        res.reverse()
        return res",0
"class Solution:
    def makeStringSorted(self, s: str) -> int:
        freq = [0]*26
        for c in s: freq[ord(c) - 97] += 1
        
        MOD = 1_000_000_007
        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)
        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))
        
        ans, n = 0, len(s)
        for c in s: 
            val = ord(c) - 97
            mult = fac(n-1)
            for k in range(26): mult *= ifac(freq[k])
            for k in range(val): ans += freq[k] * mult
            n -= 1
            freq[val] -= 1
        return ans % MOD",0
"class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        s=set(sentence)
        if len(s)==26:
            return True
        return False",1
"class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        if min(costs) > coins:
            return 0
        if sum(costs) < coins:
            return len(costs)
        costs.sort()
        count = 0
        for i in costs:
            if coins < i:
                break
            count += 1
            coins -= i
        return count",1
"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        for i in range(len(tasks)):
            tasks[i] = [tasks[i][0],tasks[i][1],i]   #add index into tasks array
        tasks.sort(key = lambda x: (x[0],x[1]))   #sort task according to arrival time and burst time
        cpu_timestamp = tasks[0][0] + tasks[0][1]  #save the current cpu time arrival + burst
        temp = []   #array for heapq operations
        res = [tasks[0][2]] #store the starting index result, this is final since we have sorted and got the optimal
        i = 1
        while i<len(tasks):
            if cpu_timestamp < tasks[i][0]: #cant use a time which is less than current cpu time
                if temp: #process already stored items in heap
                    burst,index,arri = heapq.heappop(temp)
                    res.append(index)
                    cpu_timestamp += burst
                else: #if heap is empty, we need to jump to the next value . This is for case like [100,100],[1000000000,100000000]
                    heapq.heappush(temp, [tasks[i][1],tasks[i][2],tasks[i][0]])
                    i+=1
            if i < len(tasks) and cpu_timestamp >=tasks[i][0]: #store all times that are greater than current cpu time
                heapq.heappush(temp, [tasks[i][1],tasks[i][2],tasks[i][0]])
                i+=1
        while temp: # if we reached the end of tasks array, but still have items in heap, pop one by one
            burst,index,arri = heapq.heappop(temp)
            res.append(index)
        return res",0
"class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        """"""
        (a^b) &amp; (d^e^f) = a&amp;d ^ a&amp;e ^ a&amp;f ^ b&amp;d ^ b&amp;e ^ b&amp;f
        """"""
        N1 = len(arr1)
        N2 = len(arr2)
        tmp1 = 0
        tmp2 = 0
        for i in range(max(N1, N2)):
            if i < N1:
                tmp1 = tmp1^arr1[i]
            if i < N2:
                tmp2 = tmp2^arr2[i]
        return tmp1 &amp; tmp2",1
"class Solution:
    def sumBase(self, num: int, base: int) -> int:
            tot = 0
            base_num = """"
            while num>0:
                dig = int(num%base)
                if dig<10:
                    base_num += str(dig)
                else:
                    base_num += chr(ord('A')+dig-10)  
                num //= base

            base_num = base_num[::-1]  
            tot = 0
            for i in base_num:
                tot += int(i)
            return tot",1
"class Solution:        
    def maxFrequency(self, nums: List[int], k: int) -> int:
        def freqExists(freq):
            for i in range(freq, n):
                if freq * nums[i-1] - (prefix_sum[i] - prefix_sum[i-freq]) <= k:
                    return True
            return False
        
        nums.sort()
        prefix_sum = [0] + list(accumulate(nums))             
		n = len(prefix_sum)
        l, r = 1, len(nums)+1
        ret = 1

        while l < r:
            mid = (l+r)//2
            if freqExists(mid):
                ret = mid
                l = mid + 1
            else:
                r = mid
                
        return ret",1
"class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        if word == 'aeiou':
            return 5
        def check(s):
            res = ''
            ind = []
            for i,c in enumerate(s):
                if res =='':
                    res+=c
                    ind.append(i)
                elif c == 'a' and res[-1] != c:
                    res+=c
                    ind.append(i)
                elif c == 'u' and res[-1] == c:
                    ind[-1] = i
                elif res[-1] != c:
                    res+=c
                    ind.append(i)
            return ind
        ind = check(word)
        #print(ind)
        mx = 0
        for i in range(len(ind)):
            for j in range(i,i+5):
                if j+4 <len(ind):
                    if (word[ind[j]],word[ind[j+1]],word[ind[j+2]],word[ind[j+3]],word[ind[j+4]]) == ('a','e','i','o','u'):
                        mx = max(mx, ind[j+4]-ind[j]+1)
                        #print(ind[j+4], ind[j])
        return mx",0
"class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        if not restrictions:
            return n - 1
        restrictions.append([1, 0])  # Add the restriction for the initial position
        restrictions.sort(key=lambda x: x[1] + x[0])  # Sort by increasing i + h
        idx = 0  # The index in the restrictions array
        max_height = 0
        while idx < len(restrictions):
            pos, h = restrictions[idx]
            idx += 1
            while idx < len(restrictions) and restrictions[idx][1] - restrictions[idx][0] >= h - pos:
				# skip the next restriction if it is ""above"" the line starting from the current one
                idx += 1
            if idx == len(restrictions):
				# Handles the last restriction: fill the line until the last position at n
                max_height = max(max_height, h + n - pos)
                break
            next_pos, next_h = restrictions[idx]
			# A bit of maths gives us the formula for the maximum height between two consecutive
			# restrictions
            max_height = max(max_height, (h + next_h + next_pos - pos) // 2)
        return max_height",0
"class Solution:
    def replaceDigits(self, s: str) -> str:
        o=''
        for i in range(0,len(s),2):
            if i!= len(s)-1:
                o+=s[i]+chr((ord(s[i])+int(s[i+1])))
            else:
                o+=s[i]
        return o",1
"class Solution:
    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        arr.sort() # sort the elements
        if arr[0] == 1: # if arr[0] is 1 then simply give pass as it satisfies the 1st condition
            pass
        else: # else make arr[0] to 1 to satisfy condition 1
            arr[0] = 1
        for i in range(len(arr)-1): #run the loop upto length of the array -1 times
            arr[i+1] = min(arr[i+1],arr[i]+1)# assign arr[i+1] to minimum value of arr[i+1], arr[i]+1
        return arr[-1]#return max(arr)",0
"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans",0
"class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        mini = 10**9
        for i,num in enumerate(nums):
            if num == target:
                mini = min(mini,abs(i-start))
        return mini",1
"class Solution:
    def splitString(self, s: str) -> bool:
        
        def fn(i, x): 
            """"""Return True if s[i:] can be split following x.""""""
            if i == len(s): return True 
            if x == 0: return False 
            ans = False 
            for ii in range(i, len(s) - int(i == 0)):
                if x is None or int(s[i:ii+1]) == x - 1: 
                    ans = ans or fn(ii+1, int(s[i:ii+1]))
            return ans 
        
        return fn(0, None)",0
"class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        nums = [int(i) for i in num]
        orig = [int(i) for i in num]
        right = len(nums) - 1

        ans = 0
        for _ in range(k):
            for x in range(right, 0, -1):
                if nums[x] > nums[x-1]:
                    iter = x
                    mini = (float('inf'), -1)
                    while iter <= right:
                        # Number should be greater than nums[x-1]
                        # Number should be closer to nums[x-1] than the temp value at mini[0]
                        if nums[iter] > nums[x-1] and (mini[0] - nums[x-1]) > (nums[iter] - nums[x-1]):
                            mini = (nums[iter], iter)
                        iter += 1

                    # Swap the item found at index that is immediately greater than number at x-1
                    nums[x-1], nums[mini[1]] = nums[mini[1]], nums[x-1]
                    ans += (mini[1] - (x-1))

                    # Sort the numbers to the right of swapped number
                    nums[x:] = sorted(nums[x:])
                    # print ("""".join([str(i) for i in nums]))
                    break

        # print (nums, orig)

        i = 0
        count = 0
        
        # minimum number of adjacent swaps to get to nums from orig. 
        # check where the number differs in the array and count the number of swaps to get the right number in the slot. 
        while i < len(nums):
            if nums[i] == orig[i]:
                i+=1
            else:
                j = i
                while nums[i] != orig[j]:
                    j+=1

                while j > i:
                    ## swap the number so that the calculations are correct as you traverse!
                    orig[j-1], orig[j] = orig[j], orig[j-1]
                    j -= 1
                    count += 1

        return count",0
"class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        
        # sort queries from small to large
        q = deque(sorted([(x, i) for i, x in enumerate(queries)]))
        
        # answer to queries, initial state set to -1
        ans = [-1] * len(queries)

        # sort intervals by low, high and size
        ivals = deque(sorted([(a, b, b - a + 1) for a, b in intervals]))
        
        # available intervals
        cands = []

        
        while q:
            x, i = q.popleft()
            
            # if lower bound of intervals on the top of stack <= current query
            while ivals and x >= ivals[0][0]:
                a, b, c = ivals.popleft()
                # if higher bound of intervals also meets the requirements
                # if not then discard the interval
                if x <= b:
                    heappush(cands, (c, b, a))
            
            # udpate available intervals by removing old ones which no longer has a eligible higher bound
            while cands:
                c, b, a = heappop(cands)
                if x <= b:
                    ans[i] = c
                    heappush(cands, (c, b, a))
                    break

        return ans",0
"class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        
        
        u=[0]*(3000)
        
        
        for j in logs:
            u[j[0]]+=1
            
            u[j[1]]-=1
            
        p=[u[0]]
        
        for j in range(1,len(u)):
            p.append(p[-1]+u[j])
            
        return p.index(max(p))",1
"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        ###################################################################
        # Assumption/Requirement
        ###################################################################
        # nums1 and nums2 are both decreasing 
        # return max distance (j-1) where j >= i and nums2[j] >= nums1[i]
        ###################################################################
        
        ###################################################################
        # Explanation 
        ###################################################################
        # 1. if i is fixed, we want to find out the largest j 
        # --> keep increase j if the condition ""nums2[j] >= nums1[i]"" is valid 
        # 2. if (i, j) is valid, but (i, j+1) is not valid, 
        # --> start with (i+1, j+1) instead of (i+1, i+1)
        # --> since (i, j) is valid, it indicates (i+1, j) must be also valid (nums1[i] >= nums1[i+1])
        # --> we will start with (i+1, j+1) to test whether it is valid ornot 
        ###################################################################
        
        res = 0 
        i, j = 0, 0 
        while i < len(nums1) and j < len(nums2):
            if nums2[j] >= nums1[i]:
                res = max(res, j-i)
                j += 1 
            else: 
                i += 1
            
        return res",0
"class Solution:
    def maxSumMinProduct(self, nums: List[int]) -> int:
        n = len(nums)
        s = list(accumulate(nums)) # sum
        t = sorted([(v, i) for i, v in enumerate(nums)], reverse=True) # to greedily iterate over values
        j = [i for i in range(n)] # jump array, at first one can only jump in it's own position
        seen = [False] * n # to keep check if already seen a position(i.e. index) or not
        mx = 0 # keep the maximum
        for v, p in t:
            if seen[p]: # if already seen position `p`, then just skip
                continue
            l, r = p, p # we start from position p
            while l >= 0 and nums[l] >= v: # jump left as long as we found values >= v
                seen[l] = True # marked the position as seen
                l = j[l] - 1;
            l += 1
            while r < n and nums[r] >= v: # jump right as long as we find values >= v
                seen[r] = True # marked the position as seen
                r = j[r] + 1
            r -= 1
            ls = 0 if l == 0 else s[l-1]
            rs = s[r]
            mx = max(mx, v * (rs - ls)) # now update the maximum min-product
            j[l], j[r] = r, l # update the jump pointers for position  l and r
        return mx % (10**9+7)",0
"class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        d = defaultdict(list)
        for v1, v2 in edges:
            d[v1].append(v2)
        visited = {}
        counts = [[0] * 26 for _ in range(len(colors))]
        stack = []
        global_max = 0
        for root in d.keys():
            if root in visited:
                continue
            stack.append(root)
            while stack:
                v1 = stack[-1]
                if v1 in visited:
                    if visited[v1] == 1:
                        visited[v1] = 2
                        stack.pop()
                        if v1 in d:
                            for v2 in d[v1]:
                                for c in range(26):
                                    counts[v1][c] = max(counts[v1][c], counts[v2][c])
                        counts[v1][ord(colors[v1])-ord('a')] += 1
                else:
                    visited[v1] = 1
                    if v1 in d:
                        for v2 in d[v1]:
                            if v2 in visited:
                                if visited[v2] == 1:
                                    return -1
                            else:
                                stack.append(v2)
            global_max = max(global_max, max(counts[root]))
        if global_max == 0 and len(d) < len(colors): # in case input is like (""abcde"", [])
            global_max = 1
        return global_max",0
"class Solution:
    def sortSentence(self, s: str) -> str:
        
        words = s.split(' ')
		
		# sort based on last char ex. is2 this1 nice3
        words.sort(key=lambda x: x[-1])
                
        return ' '.join(i[:-1] for i in words)",1
"class Solution(object):
    def memLeak(self, m1, m2):
        i=1
        while(1):
            if(m1>=m2):
                if(m1>=i):
                    m1-=i
                else:
                    break
            else:
                if(m2>=i):
                    m2-=i
                else:
                    break
            i+=1
        return [i,m1,m2]",1
"class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        rows=[]
        for i in box:
            row = """".join(i).split(""*"")
            for j in range(len(row)):
                row[j]="""".join(sorted(row[j], reverse=True))
            row=""*"".join(row)
            rows.append(row)
        return zip(*rows[::-1])",1
"class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        ans, hi, n, c = 0, max(nums)+1, len(nums), Counter(nums)
        pre = [0] * hi
        for i in range(1, hi):
            pre[i] = pre[i-1] + c[i]
        for num in set(nums):
            for i in range(num, hi, num):
                ans += c[num] * (pre[-1] - pre[i-1])
        return ans % (10**9 + 7)",0
"class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n = len(nums)
        def helper(i):
            if i == n:
                return [0]
            
            xors = helper(i + 1)
            return xors + [nums[i] ^ xor for xor in xors]     
        
        return sum(helper(0))",1
"class Solution:
    def minSwaps(self, s: str) -> int:
        if abs(s.count('1') - s.count('0')) > 1:
            return -1
        
        ln = len(s)
        x, y = ""10""*(ln//2), ""01""*(ln//2)
        cnt = 0
        
        if s.count('1') > s.count('0'):
            x = x + ""1""
            for i in range(ln):
                if s[i]!=x[i]: cnt+=1
            
        elif s.count('1') < s.count('0'):
            y = y + ""0""
            for i in range(ln):
                if s[i]!=y[i]: cnt+=1
        else:
            cntx = cnty = 0
            for i in range(ln):
                if s[i]!=x[i]: cntx+=1
            for i in range(ln):
                if s[i]!=y[i]: cnty+=1
            cnt = min(cntx, cnty)
        
        return cnt//2",0
"class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        
        @cache 
        def fn(n, k): 
            """"""Return number of ways to rearrange n sticks to that k are visible.""""""
            if n == k: return 1
            if k == 0: return 0
            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007
        
        return fn(n, k)",1
"class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        
        numOnes = s.count('1')
        numZeros = s.count('0')
        
        while True:
            if '1'*numOnes in s:
                break
            else:
                numOnes -= 1
        
        while True:
            if '0'*numZeros in s:
                break
            else:
                numZeros -= 1
        return numOnes > numZeros",1
"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        len_dist = len(dist)
        if sum(dist) <= hour:
            return 1
        elif len_dist - 1 > hour:
            return -1
        elif len_dist - 1 == int(hour):
            if int(hour) == hour:
                return -1
            return max(max(dist), ceil(round(dist[-1] / (hour - int(hour)), 2)))
        left, right = 1, max(dist)
        while left + 1 < right:
            middle = (left + right) // 2
            travel_time = (sum(ceil(d / middle) for d in dist[:-1])
                           + dist[-1] / middle)
            if travel_time > hour:
                left = middle
            else:
                right = middle
        return right",0
"class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(i): 
            """"""Return max score difference.""""""
            if i+1 == len(stones): return prefix[-1]
            return max(fn(i+1), prefix[i+1] - fn(i+1))
        
        return fn(1)",1
"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        substring = []
        for i in range(0,len(s)-2):
            a = s[i:i+3]
            substring.append(a)

        ans = 0
        for i in substring:
            if len(set(i)) == 3:
                ans += 1
        return ans",1
"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        start, end = 0, len(nums) - 1
        max_sum = 0
        while start <= end:
            curr_sum = nums[start] + nums[end]
            max_sum = max(max_sum,curr_sum)
            start += 1
            end -= 1
        return max_sum
    #TC -> O(n*logn)
    #SC -> O(1)",1
"class Solution:
    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0]) # dimensions 
        anti, diag = {}, {}
        for i in range(m):
            for j in range(n): 
                key = i+j
                if key not in anti: anti[key] = [0]
                anti[key].append(anti[key][-1] + grid[i][j])
                
                key = i-j 
                if key not in diag: diag[key] = [0]
                diag[key].append(diag[key][-1] + grid[i][j])
        
        def fn(i, j, k): 
            """"""Return sum of k diagonal elements starting from (i, j)""""""
            if i >= j: return diag[i-j][j+k] - diag[i-j][j]
            return diag[i-j][i+k] - diag[i-j][i]
        
        def gn(i, j, k):
            """"""Return sum of k anti-diagonal elements starting from (i, j)""""""
            if i+j < n: return anti[i+j][i+k] - anti[i+j][i]
            return anti[i+j][n-1-j+k] - anti[i+j][n-1-j]
        
        ans = set()
        for i in range(m):
            for j in range(n): 
                ans.add(grid[i][j])
                for ii in range(i+2, m, 2): 
                    r = (ii-i)//2
                    if j-r < 0 or j+r >= n: break 
                    val = 0 
                    val += fn(i, j, r+1)
                    val += gn(i, j, r+1)
                    val += fn((ii+i)//2, j-r, r+1)
                    val += gn((ii+i)//2, j+r, r+1)
                    val -= grid[i][j] + grid[(ii+i)//2][j-r] + grid[(ii+i)//2][j+r] + grid[ii][j]
                    ans.add(val)
        return sorted(ans, reverse=True)[:3]",0
"class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        
        @cache 
        def fn(mask, k): 
            """"""Return min xor sum.""""""
            if not mask: return 0 
            ans = inf 
            for i in range(n): 
                if mask &amp; (1<<i): 
                    ans = min(ans, (nums1[i]^nums2[k]) + fn(mask^(1<<i), k+1))
            return ans 
        
        return fn((1<<n)-1, 0)",1
"class Solution:
    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
        d1={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9}
        a=0
        x=[0]
        y=[0]
        z=[0]
        for i,v in enumerate(firstWord):
            if d1[v]==0 and a==0:
                continue
            x.append(d1[v])
            a=1
        b=0
        for i,v in enumerate(secondWord):
            if d1[v]==0 and b==0:
                continue
            y.append(d1[v])
            b=1
        c=0
        for i,v in enumerate(targetWord):
            if d1[v]==0 and c==0:
                continue
            z.append(d1[v])
            c=1
        if a==1:
            x=int("""".join(map(str,x)))
        else:
            x=0
        if b==1:
            y=int("""".join(map(str,y)))
        else:
            y=0
        if c==1:
            z=int("""".join(map(str,z)))
        else:
            z=0
        print(x,y,z)
        if(x+y==z):
            return True
        return False",0
"class Solution:
    def maxValue(self, n: str, x: int) -> str:
        x = str(x)
        if n[0] == ""-"": 
            for i in range(1, len(n)): 
                if x < n[i]: return n[:i] + x + n[i:]
        else: 
            for i in range(0, len(n)): 
                if x > n[i]: return n[:i] + x + n[i:]
        return n + x",0
"class Solution:
    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
        ans = [0] * len(tasks)
        free_servers = []
        busy_servers = []
        for idx, weight in enumerate(servers):
            heappush(free_servers, (weight, idx))
        for sec, task_len in enumerate(tasks):
            if busy_servers:
                sec_free, weight, idx = heappop(busy_servers)
                while sec_free <= sec:
                    heappush(free_servers, (weight, idx))
                    if busy_servers:
                        sec_free, weight, idx = heappop(busy_servers)
                    else:
                        break
                if sec_free > sec:
                    heappush(busy_servers, (sec_free, weight, idx))
            if free_servers:
                weight, idx = heappop(free_servers)
                ans[sec] = idx
                heappush(busy_servers, (sec + task_len, weight, idx))
            else:
                sec_free, weight, idx = heappop(busy_servers)
                ans[sec] = idx
                heappush(busy_servers, (sec_free + task_len, weight, idx))
        return ans",0
"class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        if sum(dist)/speed > hoursBefore: return -1 # impossible 
        
        @cache
        def fn(i, k): 
            """"""Return min time (in distance) of traveling first i roads with k skips.""""""
            if k < 0: return inf # impossible 
            if i == 0: return 0 
            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))
        
        for k in range(len(dist)):
            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k",0
"class Solution:
    def twoEggDrop(self, n: int) -> int:
        N = 0
        res = 0
		# find k = 1+2+3+...+i , where i is the maximum number that allows k <= n then return k
        while res < n:
            N += 1
            res += N
        return N",1
"class Solution:
def findRotation(self, matrix: List[List[int]], target: List[List[int]]) -> bool:
    
    def transpose(mat):
        n=len(mat)
        for i in range(n):
            for j in range(i,n):
                mat[i][j],mat[j][i]=mat[j][i],mat[i][j]
    
    def reverse(mat):
        n=len(mat)
        for i in range(n):
            for j in range(n//2+n%2):
                mat[i][j],mat[i][n-j-1]=mat[i][n-j-1],mat[i][j]
        
    if target==matrix:
        return True
    # Rotating 1st time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True
    # Rotating 2nd time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True
    # Rotating 3rd time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True

    return False",0
"class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        return sum(i * len(tuple(g)) for i, (_, g)
                   in enumerate(groupby(sorted(nums))))",0
"class Solution:
    def minFlips(self, s: str) -> int:
        n = len(s)

        s = s+s
        fip1 = [('0' if i%2==0 else '1') for i in range(len(s))]
        fip2 = [('1' if i%2==0 else '0') for i in range(len(s))]
        i = 0
        min1 = 0
        min2 = 0
        final = len(s)
        for j in range(len(s)):
            
            if fip1[j]!=(s[j]):
                min1+=1
            if fip2[j]!= (s[j]):
                min2+=1

            if (j-i+1) == n:
                final = min(final,min1,min2)
                if (s[i]) != fip1[i]:
                    min1-=1
                if (s[i]) != fip2[i]:
                    min2-=1
                i+=1
        return final",0
"class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        # prefix sum to save time
        acc = [0] + [*accumulate(packages)]
        packages.sort()

        ans = float('inf')
        for box in boxes:
            tmp = 0
            # deal with smallest box first
            box.sort()
            
            # record number of packages already dealt with
            start = 0
            
            for b in box:
                loc = bisect.bisect(packages, b)
                if loc == 0: continue
                tmp += b * (loc - start) - (acc[loc] - acc[start])
                
                # all are packaged
                if loc == len(packages):
                    ans = min(ans, tmp)
                    break
                    
                start = loc
        
        return ans % (10 **9+7) if ans != float('inf') else -1",1
"class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        
        seen = set()
        
        for interval in ranges:
            
            start = interval[0]
            end = interval[1]
            
			# adds all numbers in range to the seen numbers
            for x in range(start, end+1):
                seen.add(x)
            
		# make sure all numbers from left to right have been seen
        for x in range(left, right+1):
            if x not in seen:
                return False
        
        return True",1
"class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        k %= sum(chalk)
        n = len(chalk)
        for i in range(n):
            if chalk[i] > k:
                return i
            k -= chalk[i]",1
"class Solution:

    @staticmethod
    def is_magic(mat: List[List[int]]):
        n, s = len(mat), sum(mat[0])
        for r in range(1, n):
            if sum(mat[r]) != s:
                return False
        if any(sum(col) != s for col in zip(*mat)):
            return False
        d1 = d2 = 0
        n1 = n - 1
        for i in range(n):
            d1 += mat[i][i]
            d2 += mat[n1 - i][i]
        return d1 == d2 == s

    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        max_size = 1
        for r in range(rows):
            if rows - r < max_size:
                break
            for c in range(cols):
                if cols - c < max_size:
                    break
                max_len = min(rows - r, cols - c) + 1
                for size in range(max_size + 1, max_len):
                    sub_mat = [grid[row_id][c: c + size]
                               for row_id in range(r, r + size)]
                    if Solution.is_magic(sub_mat):
                        max_size = size
        return max_size",0
"class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        loc = {}
        stack = []
        for i in reversed(range(len(expression))):
            if expression[i] == "")"": stack.append(i)
            elif expression[i] == ""("": loc[stack.pop()] = i 
        
        def fn(lo, hi): 
            """"""Return value and min op to change value.""""""
            if lo == hi: return int(expression[lo]), 1
            if expression[hi] == "")"" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis 
            mid = loc.get(hi, hi) - 1 
            v, c = fn(mid+1, hi)
            vv, cc = fn(lo, mid-1)
            if expression[mid] == ""|"": 
                val = v | vv 
                if v == vv == 0: chg = min(c, cc)
                elif v == vv == 1: chg = 1 + min(c, cc)
                else: chg = 1 
            else: # expression[k] == ""&amp;""
                val = v &amp; vv
                if v == vv == 0: chg = 1 + min(c, cc)
                elif v == vv == 1: chg = min(c, cc)
                else: chg = 1
            return val, chg
                    
        return fn(0, len(expression)-1)[1]",0
"class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        x = {}
        for word in words:
            for i in word:
                if i in x:
                    x[i]+=1
                else:
                    x[i]=1
        return all(i%len(words) == 0 for i in x.values())",1
"class Solution:
    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        indices = {}
        for i in range(len(removable)):
            indices[removable[i]] = i
        
        def check(mid):
            i, j = 0, 0
            while i < len(s) and j < len(p):
                if s[i] == p[j] and (i not in indices or indices[i] > mid):
                    j += 1
                i += 1
            
            if j == len(p):
                return True
            else:
                return False
        
        l, r = 0, len(removable) - 1
        ans = -1
        
        while l <= r:
            mid = (l + r) // 2
            if check(mid):
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
                
        return ans + 1",0
"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        x = y = z = -inf 
        for a, b, c in triplets: 
            if a <= target[0] and b <= target[1] and c <= target[2]: 
                x, y, z = max(x, a), max(y, b), max(z, c)
        return [x, y, z] == target",0
"class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed
        
        @cache
        def fn(k, mask): 
            """"""Return earliest and latest rounds.""""""
            can = deque()
            for i in range(n): 
                if mask &amp; (1 << i): can.append(i)
                    
            cand = [] # eliminated player
            while len(can) > 1: 
                p1, p2 = can.popleft(), can.pop()
                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest 
                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated 
                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated 
                else: cand.append([p1, p2]) # both could be elimited 
            
            minn, maxx = inf, -inf
            for x in product(*cand): 
                mask0 = mask
                for i in x: mask0 ^= 1 << i
                mn, mx = fn(k+1, mask0)
                minn = min(minn, mn)
                maxx = max(maxx, mx)
            return minn, maxx
        
        return fn(1, (1<<n)-1)",0
"class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        M = len(mat)
        N = len(mat[0])
        @cache
        def rmax(r):
            return max(mat[r])
        l,r = 0,M
        while r-l>1:
            m = l+(r-l)//2
            assert(m>0)
            if rmax(m)>rmax(m-1):
                l = m
            else:
                r = m
        return [l, mat[l].index(rmax(l))]",1
"class Solution:
    def largestOddNumber(self, num: str) -> str:
        val, idx = '', len(num) - 1
        
        while idx > -1:
            odd = int(num[idx]) % 2
            while odd and idx > -1:
                val = num[idx] + val
                idx -= 1
            idx -= 1
        return val",1
"class Solution:
    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        start_time = sum(t if i else 60 * t
                         for i, t in enumerate(map(int, startTime.split("":""))))
        finish_time = sum(t if i else 60 * t
                          for i, t in enumerate(map(int, finishTime.split("":""))))
        if finish_time < start_time:
            finish_time += 1440
        return (floor(finish_time / 15) - ceil(start_time / 15)
                if finish_time - start_time >= 15 else 0)",0
"class Solution:
    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        
        rows = len(grid1)
        cols = len(grid1[0])
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        
        islands = 0
        
        for row in range(rows):
            for col in range(cols):
                if grid2[row][col] == 1 and grid1[row][col] == 1:
                    grid2[row][col] = '#'
                    q = collections.deque([])
                    q.append((row, col))
                    is_island = True
                    while q:
                        r, c = q.popleft()
                        for y, x in directions:
                            nr = r + y
                            nc = c + x
                            if 0 <= nr < rows and 0 <= nc < cols and grid2[nr][nc] == 1:
                                if grid1[nr][nc] != 1:
                                    is_island = False
                                grid2[nr][nc] = '#'
                                q.append((nr, nc))
                                
                    if is_island:
                        islands += 1
                    
        return islands",0
"class Solution:
    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        loc = {}
        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)
        keys = sorted(loc)
        
        ans = []
        for l, r in queries: 
            prev, val = 0, inf
            for x in keys: 
                i = bisect_left(loc[x], l)
                if i < len(loc[x]) and loc[x][i] <= r: 
                    if prev: val = min(val, x - prev)
                    prev = x 
            ans.append(val if val < inf else -1)
        return ans",0
"class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            x = nums[:i]+nums[i+1:]
            if sorted(x)==x and len(set(x))==len(x): return True
        return False",1
"class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        if part in s:
            a = s.index(part)
            return self.removeOccurrences(s[:a] + s[a+len(part):], part)
        else:
            return s",1
"class Solution:
    def maxAlternatingSum(self, nums: List[int]) -> int:
        n = len(nums)
        dp_odd = [0]*n
        dp_even = [0]*n
        dp_even[0] = nums[0]
        max_even = nums[0]
        max_odd = 0
        ans = nums[0]
        i = 1
        while i<n:
            dp_odd[i] = max_even - nums[i]
            dp_even[i] = max_odd + nums[i]
            max_even = max(max_even, dp_even[i])
            max_odd = max(max_odd,dp_odd[i] )
            ans = max(ans, dp_odd[i], dp_even[i])
            i += 1
        return ans",1
"class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums.sort()
        return nums[-1] * nums[-2] - nums[0] * nums[1]",1
"class Solution:
    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = [[0] * n for _ in range(m)]
        # x, y is starting point; m, n is desired length and width of the layer
        def helper(x, y, l, w):
            tmp = deque([grid[x][y]])
            a, b = 0, 0
            # extract all number in the layer
            while len(tmp) < 2 * (l + w) - 4:
                if a == 0 and b < w - 1:
                    b += 1
                elif b == w - 1 and a < l - 1:
                    a += 1
                elif a == l - 1 and b > 0:
                    b -= 1
                elif b == 0 and a > 0:
                    a -= 1
                tmp.append(grid[x + a][y + b])
            
            # rotate counter-clockwise
            tmp.rotate(len(tmp) - k % len(tmp))

            # reassign
            a, b = 0, 0
            ans[x][y] = tmp.popleft()
            while tmp:
                if a == 0 and b < w - 1:
                    b += 1
                elif b == w - 1 and a < l - 1:
                    a += 1
                elif a == l - 1 and b > 0:
                    b -= 1
                elif b == 0 and a > 0:
                    a -= 1
                ans[x + a][y + b] = tmp.popleft()
        
        x, y = 0, 0
        while m >= 2 and n >= 2:
            helper(x, y, m, n)
            x += 1
            y += 1
            m -= 2
            n -= 2
        
        return ans",0
"class Solution:
    def wonderfulSubstrings(self, word: str) -> int:
        n = len(word)
        mask = 0
        prefix = defaultdict(int)
        prefix[0] += 1
        ans = 0
        for w in word:
            mask ^= 1 << (ord(w) - ord('a'))
            # no difference
            ans += prefix[mask]
            for i in range(10):
                # only differed by one digit 
                tmp = mask ^ (1 << i)
                ans += prefix[tmp]
            prefix[mask] += 1
        return ans",1
"class Solution:
    def waysToBuildRooms(self, prevRoom: List[int]) -> int:
        tree = defaultdict(list)
        for i, x in enumerate(prevRoom): tree[x].append(i)
        
        def fn(n): 
            """"""Return number of nodes and ways to build sub-tree.""""""
            if not tree[n]: return 1, 1 # leaf 
            c, m = 0, 1
            for nn in tree[n]: 
                cc, mm = fn(nn)
                c += cc
                m = (m * comb(c, cc) * mm) % 1_000_000_007
            return c+1, m
        
        return fn(0)[1]",1
"class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        x=[nums[nums[i]] for i in range(0,len(nums))]
        return x;",1
"class Solution:
def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
    
    time = [d/s for d,s in zip(dist,speed)]
    time.sort()
    c=0
    for i,t in enumerate(time):
        if i<t:
            c+=1
        else:
            break
    
    return c",1
"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        odds = n // 2
        return (pow(5, n - odds, 1_000_000_007) * pow(4, odds, 1_000_000_007)
                % 1_000_000_007)",1
"class Solution:
    cache = {1:0, 2:0, 3:0, 4:0}
    
    def countTriples(self, n: int) -> int:        
        if n in self.cache.keys():
            return self.cache[n]
        else:
            self.cache[n] = self.findTriples(n) + self.countTriples(n-1)
            return self.cache[n]
        
    def findTriples(self, n: int) -> int:
        count = 0
        
        for a in range(0, n):
            for b in range(a, n):
                if self.isSquareTriple(a, b, n):
                    count += 1
                    
        return count*2
        
    def isSquareTriple(self, a: int, b: int, c: int) -> bool:
        if ((a*a) + (b*b) == (c*c)):
            return True
        else:
            return False",0
"class Solution:
    def nearestExit(self, maze, entrance) -> int:
        '''
        for val in maze:
            print(val)
        '''
        m, n = len(maze), len(maze[0])
        q, ans = [entrance], 0

        while q:
            num = len(q)
            for i in range(num):
                x, y = q[0]
                if (x == 0 or y == 0 or x == m - 1 or y == n - 1) and ans > 0:
                    return ans
                q.pop(0)
                maze[x][y] = '+'
                if x > 0 and maze[x - 1][y] == '.':
                    q.append([x - 1, y])
                if y > 0 and maze[x][y - 1] == '.':
                    q.append([x, y - 1])
                if x < m - 1 and maze[x + 1][y] == '.':
                    q.append([x + 1, y])
                if y < n - 1 and maze[x][y + 1] == '.':
                    q.append([x, y + 1])
            ans += 1

        return -1",0
"class Solution:
    def sumGame(self, num: str) -> bool:
        diff = qm = 0 
        for i, ch in enumerate(num): 
            if ch == ""?"": qm += 1 if i < len(num)//2 else -1
            else: diff += int(ch) if i < len(num)//2 else -int(ch)
        return diff * 2 + qm * 9 != 0",0
"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], fee: List[int]) -> int:
        g = defaultdict(lambda: defaultdict(lambda: float('inf')))
        n = len(fee)
        
        # select edges with minimal time
        for u, v, t in edges:
            if t < g[u][v]:
                g[u][v] = t
            if t < g[v][u]:
                g[v][u] = t
        
        
        vis = defaultdict(tuple, {0: (0, fee[0])})
        
        q = [(fee[0], 0, 0)]
        while q:
            f, t, cur = heappop(q)
            if cur == n - 1:
                return f
            for nei in g[cur]:
                nf = f + fee[nei]
                nt = t + g[cur][nei]
                if nt > maxTime: continue
                    
                # global vis set (either less time or fare)
                if not vis[nei] or (nt < vis[nei][0] or nf < vis[nei][1]):
                    if not vis[nei]: 
                        vis[nei] = (nt, nf)
                    else:
                        vis[nei] = (min(nt, vis[nei][0]), min(nf, vis[nei][1]))
                    heappush(q, (nf, nt, nei))
        return -1",0
"class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums * 2",1
"class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        
        first = {}
        last = {}
        
        for i,c in enumerate(s):
            if c not in first:
                first[c] = i
            last[c] = i
            
        ans = 0
        for c in ""abcdefghijklmnopqrstuvwxyz"":
            if c not in last:
                continue
            uniq = set()
            for i in range(first[c]+1,last[c]):
                uniq.add(s[i])
            ans += len(uniq)
            
        return ans",1
"class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        M = 10**9 + 7
        ans = 3
        if m == 1:
            for i in range(n-1):
                ans *= 2
                ans %= M
            return ans % M
        
        def IsValid(a):
            return all ( a[i] != a[i+1] for i in range(len(a) - 1) )
            
        if m >= 2:
            # AllStates contains all colorings of a single row of length m using 3 colors (0, 1, 2), hence of size 3^m
            # For example, m = 2, AllStates = [(0,0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
            AllStates = [[0], [1], [2]]
            colors = [0, 1, 2]
            for j in range(m-1):
                L = len(AllStates)
                for i in range(L):
                    x = AllStates.pop(0)
                    for c in colors:
                        AllStates.append(tuple([*x, c]))
            
            # v contains all valid colorings of a single row of length m using 3 colors
            v = set()
            for a in AllStates:
                if IsValid(a):
                    v.add(a)
            d = {i:a for i, a in enumerate(v)}
            
            # construct a graph where vertices are valid single row colorings
            # an edge is present if two colorings satisfy the constraints
            numStates = len(v)
            def IsValidNeigbor(a, b):
                if a not in v or b not in v:
                    return False
                else:
                    for i in range(len(a)):
                        if a[i] == b[i]:
                            return False
                    return True
            
            adj = {i:[] for i in range(numStates)}
            for i in range(numStates):
                for j in range(i+1, numStates):
                    if IsValidNeigbor(d[i], d[j]):
                        adj[i].append(j)
                        adj[j].append(i)
            
            # then the problem becomes: finding the number of paths of length n in the constructed graph,
            # which can be done by an easy-to-understand dp.
            dp = [[0 for _ in range(n+1)] for _ in range(numStates)]
            for i in range(numStates):
                dp[i][1] = 1
            
            
            for j in range(2, n+1):
                for i in range(numStates):
                    for k in adj[i]:
                        dp[i][j] += dp[k][j-1]
                        dp[i][j] %= M
            return sum(dp[i][n] for i in range(numStates)) % M",0
"class Solution:
    def canMerge(self, trees: List[TreeNode]) -> TreeNode:
        roots, leaves, loners, n = {}, {}, set(), len(trees)
        if n == 1:
            return trees[0]
        for tree in trees:
            if not tree.left and not tree.right:
                loners.add(tree.val)
                continue
            roots[tree.val] = tree
            for node in [tree.left, tree.right]:
                if node:
                    if node.val in leaves:
                        return None
                    leaves[node.val] = node
                
        for loner in loners:
            if loner not in leaves and loner not in roots:
                return None
            
        orphan = None
        for val, tree in roots.items():
            if val not in leaves:
                if orphan:
                    return None
                orphan = tree
        if not orphan:
            return None
        
        def build(node, small, big):
            nonlocal roots
            if not node:
                return True
            if small >= node.val or node.val >= big:
                return False
            
            if node.val in roots:
                node.left, node.right = roots[node.val].left, roots[node.val].right
                del roots[node.val]
            return build(node.left, small, node.val) and build(node.right, node.val, big)
        del roots[orphan.val]
        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)
        return orphan if result and not roots.keys() else None",0
"class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        t=text.split("" "")
        b=list(brokenLetters)
        print(t,b)
        ans=[]
        for i in range(len(t)):
            c=0
            for j in range(len(b)):
                if(b[j] in t[i]):
                    c+=1
                    break
            if(c==0):
                ans.append(t[i])
        return len(ans)",1
"class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        n = len(rungs)
        count = 0
        if dist == 1:
            if rungs[0]>1:
                count += rungs[0]-1
            for i in range(n-1):
                if rungs[i+1]-rungs[i] > 1:
                    count+= rungs[i+1]-rungs[i] - 1
            return count
        else:
            if rungs[0] > dist:
                count += (rungs[0]-1)//dist
            for i in range(n-1):
                if rungs[i+1] - rungs[i] > dist:
                    count += (rungs[i+1] - rungs[i] -1)//dist
            return count",0
"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        for i in range(1, m): 
            for j in range(n-2, -1, -1): 
                points[i-1][j] = max(points[i-1][j], points[i-1][j+1]-1)
            prefix = 0 
            for j in range(n): 
                points[i][j] += max(prefix, points[i-1][j])
                prefix = max(prefix, points[i-1][j]) - 1
        return max(points[-1])",0
"class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        counts = list(Counter(s).values())
        return all(count == counts[0] for count in counts)",1
"class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
      #track the friend of interest since we are going to 
      #sort the array later
      target_start, target_end = times[targetFriend]
	  
      #sort array by the time each friend arrive
      times.sort(key = lambda x : x[0])
	  
      #preallocate the maximum num of chairs needed
      #priority queue 1 - chairs, since we always want to
      #get the chair with smallest index
      chairs = list(range(len(times)+1))
      heapify(chairs)
	  
      #priority queue 2 - occupied, we release chairs by
      #the time they are done occupied
      occupied = []
      heapify(occupied)
	  
      for start, end in times:
        #release the chairs that has no one sitting on 
        while occupied and occupied[0][0] <= start:
          time, release = heappop(occupied)
          heappush(chairs, release)
		  
        #get the chair with smallest index
        target_chair = heappop(chairs)
		
        #if friend of interest if found, return chair index
        if start == target_start and end == target_end:
          return target_chair
        #otherwise, label this chair as occupied
        heappush(occupied, (end, target_chair))",0
"class Solution:
    def splitPainting(self, segment: List[List[int]]) -> List[List[int]]:
        f=[]
        for a,b,c in segment:
            f.append([a,c])
            f.append([b,-c])
        f.sort()
        s=0
        ft=[]
        n=len(f)
        for i in range(n-1):
            s+=f[i][1]
            if(f[i][0]!=f[i+1][0] and s!=0):
                ft.append([f[i][0],f[i+1][0],s])
        
        return ft",1
"class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        stk=[heights[-1]]
        ans=[0]*len(heights)
        for i in range(len(heights)-2,-1,-1):
            h=heights[i]
            cansee=0
            while stk and h>stk[0]:
                cansee+=1
                stk.pop(0)
            ans[i]=cansee+1 if stk else cansee
            stk.insert(0,h)
        return ans",1
"class Solution:
    def getLucky(self, s: str, k: int) -> int:
        al = {""a"":1,""b"":2,""c"":3,""d"":4,""e"":5,""f"":6,""g"":7,""h"":8,""i"":9,""j"":1,""k"":2,""l"":3,""m"":4,""n"":5,""o"":6,""p"":7,""q"":8,""r"":9,""s"":10,""t"":2,""u"":3,""v"":4,""w"":5,""x"":6,""y"":7,""z"":8}
        res, tmp = 0, 0
        for c in s:
            res += al[c]
        for _ in range(k-1):
            tmp = str(res)
            res = 0
            for char in tmp:
                res += int(char)
        return res",0
"class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        
        res = ''
        startChange = False
        for idx,i in enumerate(num):
            val = int(i)
            if change[val] > val:
                startChange = True
                res += str(change[val])
            else:
                if startChange and not change[val] == val:
                    break
                res += str(val)
        
        return res + num[idx:] if len(res) < len(num) else res",1
"class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        return self.mySoldfs(students, mentors, set(), 0)
        
    def mySoldfs(self, students, mentors, hashSet, indS):
        if indS>=len(students):
            return 0
        res=0
        maxx=0
        for i in range(len(mentors)):
            if i not in hashSet:
                res = self.match(students[indS], mentors[i])
                hashSet.add(i)
                maxx = max(maxx, res+self.mySoldfs(students, mentors, hashSet, indS+1))
                hashSet.remove(i)
        return maxx
    
    def match(self, x, y):
        res=0
        i=j=0
        while(i<len(x)and j<len(y)):
            if x[i]==y[j]:
                res+=1
            i+=1;
            j+=1;
        return res",0
"class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        leaves = []
        trie_lambda = lambda: collections.defaultdict(trie_lambda)
        trie = trie_lambda()
        trie['*'] = trie['**'] = '*'
        
        for p in paths:
            t = trie
            for f in p:
                parent, t = t, t[f]
                t['*'] = parent
                t['**'] = f
        
        def traverse(t):
            if len(t) == 2:
                leaves.append(t)
            else:
                for k, v in t.items():
                    if k[0] != '*':
                        traverse(v)
        traverse(trie)
        
        leaf_ids = set(id(leaf) for leaf in leaves)
        candidates = {id(leaf['*']):leaf['*'] for leaf in leaves}
        
        while candidates:
            new = {}
            dup = collections.defaultdict(list)
            for cand in candidates.values():
                if any(id(v) not in leaf_ids for k, v in cand.items() if k[0] != '*'):
                    continue
                dup[','.join(sorted(cand.keys()))].append(cand)
            for k, v in dup.items():
                if len(v) > 1:
                    for cand in v:
                        f = cand['**']
                        parent = cand['*']
                        del parent[f]
                        leaf_ids.add(id(parent['*' + f]))
                        new[id(parent)] = parent
            candidates = new
        path = []
        ans = []
        def dfs(t):
            for f in t:
                if f[0] != '*':
                    path.append(f)
                    ans.append(list(path))
                    dfs(t[f])
                    path.pop()
        dfs(trie)
        return ans",0
"class Solution:
    def isThree(self, n: int) -> bool:
        is_div = [i * (n//i) == n for i in range(2, int(math.sqrt(n))+1)]
        return sum(is_div) == 1 and is_div[-1] == 1",0
"class Solution(object):
    def numberOfWeeks(self, milestones):
        """"""
        :type milestones: List[int]
        :rtype: int
        """"""
        milestones.sort()
        s = sum(milestones[:-1])
        if milestones[-1] > s:
            return s * 2 + 1
        else:
            return s + milestones[-1]",1
"class Solution:
    def minimumPerimeter(self, neededApples: int) -> int:
        total=0
        for i in range(neededApples):
            total+=12*(i+1)*(i+1)
            if total>=neededApples:
                return 8*(i+1)",1
"class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        MOD = 1_000_000_007 
        s0 = s1 = s2 = 0 
        for x in nums: 
            if x == 0: s0 = (1 + 2*s0) % MOD
            elif x == 1: s1 = (s0 + 2*s1) % MOD
            else: s2 = (s1 + 2*s2) % MOD
        return s2",1
"class Solution:
    def makeFancyString(self, s: str) -> str:
        fancy = []
        for idx in range(len(s)):
            if idx < 2 or not s[idx] == s[idx-1] == s[idx-2]:
                fancy.append(s[idx])
        return """".join(fancy)",1
"class Solution:
    def maxProduct(self, s: str) -> int:
        n = len(s)
        
        # Manacher's algo
        hlen = [0]*n # half-length
        center = right = 0 
        for i in range(n): 
            if i < right: hlen[i] = min(right - i, hlen[2*center - i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: 
                hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]
        
        prefix = [0]*n
        suffix = [0]*n
        for i in range(n): 
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)
        
        for i in range(1, n): 
            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)
            suffix[i] = max(suffix[i], suffix[i-1]-2)
        
        for i in range(1, n): 
            prefix[i] = max(prefix[i-1], prefix[i])
            suffix[~i] = max(suffix[~i], suffix[~i+1])
        
        return max(prefix[i-1]*suffix[i] for i in range(1, n))",0
"class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        n = len(s)
        m = 0
        c = """"
        for i in words:
            m+=len(i)
            c+=i
            if m > n:
                return False
            elif m == n and s == c:
                return True
        return False",1
"class Solution:
def minStoneSum(self, piles: List[int], k: int) -> int:
    
    local = [-p for p in piles]
    heapq.heapify(local)
    for i in range(k):
        tmp = -1*heapq.heappop(local)
        tmp = (tmp+1)//2
        heapq.heappush(local,-tmp)
    
    return -sum(local)",1
"class Solution:
    def minSwaps(self, s: str) -> int:
        return (reduce(lambda mismatch, ch: mismatch + (-1 if (mismatch > 0 and ch == ']') else 1), s, 0) + 1) // 2",0
"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        ans, vals = [], []
        for i, x in enumerate(obstacles): 
            k = bisect_right(vals, x)
            ans.append(k+1)
            if k == len(vals): vals.append(x)
            else: vals[k] = x
        return ans",1
"class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        count=0
        for i in range(len(patterns)):
            if patterns[i] in word:
                count+=1
        return count",1
"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)-1): 
            if nums[i-1] < nums[i] < nums[i+1] or nums[i-1] > nums[i] > nums[i+1]: 
                nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums",0
"class Solution:
    def minNonZeroProduct(self, p: int) -> int:
        MOD = 10 ** 9 + 7
        res = pow(pow(2, p, MOD) - 2, pow(2, (p - 1)) - 1, MOD) * (pow(2, p, MOD) - 1)
        return int(res) % MOD",0
"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        _board = [[0 for _ in range(col)] for _ in range(row)]
        board = None
        
        def search(days):
            def dfs(x, y):
                res = False
                for _x, _y in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if not (0 <= _x < row and 0 <= _y < col):
                        continue
                    if board[_x][_y]:
                        continue
                    if _x == row - 1:
                        return True
                    board[_x][_y] = 1
                    res |= dfs(_x, _y)
                return res
            
            flood(days)
            for j in range(col):
                if not board[0][j]:
                    board[0][j] = 1
                    if dfs(0, j):
                        return True
            return False
        
        def flood(days):
            nonlocal board
            board = deepcopy(_board)
            for i in range(days):
                board[cells[i][0] - 1][cells[i][1] - 1] = 1
        
        l, r = 0, len(cells)
        while l < r:
            mid = l + (r - l) // 2
            if search(mid):
                l = mid + 1
            else:
                r = mid
        return l - 1",0
"class Solution:
    def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:
        if start == end: return True
        if len(edges) == 0: return False
        
        adj = [set() for _ in range(n)]
        seen = set()
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        queue = []
        queue.append(start)
        while len(queue)>0:
            st = queue.pop(0)
            if st == end:
                return True
            if st not in seen: 
                queue += list(adj[st])
            seen.add(st)
        return False",0
"class Solution:
def minTimeToType(self, word: str) -> int:
    count = 0
    curr = ""a""
    
    for i in word:
        t = abs(ord(i)-ord(curr))
        if t <= 12:
            count += 1 + t
            curr = i
        else:
            count += 1 + 26 - t
            curr = i
    
    return count",1
"class Solution(object):
    def maxMatrixSum(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: int
        """"""
        n = len(matrix)
        s = 0 
        s_abs = 0 
        neg = 0 
        maxneg = float('-inf')
        minabs = float('inf')
        for i in range(n):
            for j in range(n):
                s += matrix[i][j]
                s_abs += abs(matrix[i][j])
                if matrix[i][j] <= 0:
                    neg += 1
                if abs(matrix[i][j]) < abs(minabs):
                    minabs = matrix[i][j]
       
        if neg % 2 == 0:
            return s_abs
        else:
            return s_abs - 2*abs(minabs)",1
"class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        g = defaultdict(set)
        deg = [0] * n
        for u, v, t in roads:
            if u > v:
                u, v = v, u
            g[u].add((v, t))
            deg[v] += 1

        vis = defaultdict(lambda: float('inf'), {0: 0})
        q = [(0, 0)]
        ways = [0] * n
        ways[0] = 1
        while q:
            t, cur = heappop(q)
            for nei, nei_t in g[cur]:
                deg[nei] -= 1
                if vis[nei] > t + nei_t:
                    vis[nei] = t + nei_t
                    ways[nei] = ways[cur]
                elif vis[nei] == t + nei_t:
                    ways[nei] += ways[cur]
                
                # only traverse if degree = 0 or spent time starts to exceed minimum
                if deg[nei] == 0 or vis[nei] < t + nei_t:
                    if nei == n - 1 and deg[nei] == 0:
                        return ways[-1] % (10 ** 9 + 7)
                    heappush(q, (vis[nei], nei))
        
        return ways[-1]",0
"class Solution:
    def numberOfCombinations(self, num: str) -> int:
        n = len(num)
        lcs = [[0]*(n+1) for _ in range(n)]
        for i in reversed(range(n)): 
            for j in reversed(range(i+1, n)): 
                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]
        
        def cmp(i, j, d): 
            """"""Return True if """"""
            m = lcs[i][j]
            if m >= d: return True 
            return num[i+m] <= num[j+m]
        
        dp = [[0]*(n+1) for _ in range(n)]
        for i in range(n): 
            if num[i] != ""0"": 
                for j in range(i+1, n+1): 
                    if i == 0: dp[i][j] = 1
                    else: 
                        dp[i][j] = dp[i][j-1]
                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]
                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]
        return sum(dp[i][n] for i in range(n)) % 1_000_000_007",0
"class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        n = len(nums[0])
        for i in range(len(nums)):
            nums[i] = int(nums[i],2)
        for i in range(2**n):
            if i not in nums:
                return bin(i)[2:].zfill(n)",1
"class Solution:
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        mask = 0b1
        for row in mat: 
            temp = 0
            for x in row: temp |= mask << x
            mask = temp 
        
        for x in range(5000): 
            if mask >> (target+x) &amp; 1 or x <= target and mask >> (target-x) &amp; 1: return x",0
"class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        ans = []
        for _ in range(n): 
            diff = sums[1] - sums[0]
            ss0, ss1 = [], []
            freq = defaultdict(int)
            on = False 
            for i, x in enumerate(sums): 
                if not freq[x]: 
                    ss0.append(x)
                    freq[x+diff] += 1
                    if x == 0: on = True 
                else: 
                    ss1.append(x)
                    freq[x] -= 1
            if on: 
                ans.append(diff)
                sums = ss0 
            else: 
                ans.append(-diff)
                sums = ss1
        return ans",0
"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        

        minimal=float('inf')
        
        counter=defaultdict(int)

        maximum=float('-inf')
        minimum=float('inf')
        sortedArray=[]
        for num in nums:
            counter[num]+=1
            maximum=max(num,maximum)
            minimum=min(num,minimum)

        for i in range(minimum, maximum+1):
            if i in counter:
                while counter[i]:
                    sortedArray.append(i)
                    counter[i]-=1

        first=0
        second=k-1
        
        while second < len(sortedArray):
            minimal=min(minimal,sortedArray[second]-sortedArray[first])
            first+=1
            second+=1
            
        return minimal",1
"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        for i in range(len(nums)):
            nums[i] = int(nums[i])
        nums.sort()
        nums.reverse()
        return str(nums[k-1])",1
"class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        n = len(tasks)

        @lru_cache(None)
        def dp(mask, t):
            if mask == (1 << n) - 1:
                return 0
            ans = n
            for i in range(n):
                if mask &amp; (1 << i): continue
                if tasks[i] > t:
                    ans = min(ans, 1 + dp(mask ^ (1 << i), sessionTime - tasks[i]))
                else:
                    ans = min(ans, dp(mask ^ (1 << i), t - tasks[i]))
            return ans

        return dp(0, 0)",0
"class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        f0 = f1 = 0
        for ch in binary: 
            if ch == ""0"": f0 += f1
            else: f1 += f0 + 1
        return (f0 + f1 + int(""0"" in binary)) % 1_000_000_007",1
"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        right = sum(nums)
        left = 0 
        for i in range(len(nums)):
            right -= nums[i]
            if left == right:
                return i
            left += nums[i]

        return -1",1
"class Solution:
def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
    
    m=len(land)
    n=len(land[0])
    def dfs(i,j,ei,ej):
        nonlocal ex,ey
        if i<0 or j<0 or i>=m or j>=n or land[i][j]==0:
            return
        ex=max(i,ei)
        ey=max(j,ej)
        land[i][j]=0
        dfs(i+1,j,ex,ey)
        dfs(i,j+1,ex,ey)
        dfs(i,j-1,ex,ey)
        dfs(i-1,j,ex,ey)
        
    res=[]
    for x in range(m):
        for y in range(n):
            if land[x][y]==1:
                ex,ey = x,y
                dfs(x,y,ex,ey)
                res.append([x,y,ex,ey])
    
    return res",0
"class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

        cands = {}
        for x in range(1, 31):
            orig = x
            mask = 0
            for p in primes:
                if x % p: continue
                if p > x: break
                x //= p
                mask ^= (1 << p)
            if x == 1:
                cands[orig] = mask


        cnt = {k: v for k, v in Counter(nums).items() if k in cands}
        cnt_key = list(filter(lambda x: x> 1, sorted(cnt)))
        n = len(cnt_key)
        M = 10**9 + 7
        
        @lru_cache(None)
        def dp(i, mask):
            if i == n:
                return mask > 0
            ans = dp(i+1, mask)
            if mask &amp; cands[cnt_key[i]] == 0:
                ans += cnt[cnt_key[i]] * dp(i+1, mask ^ cands[cnt_key[i]])
            return ans % M
        
        return (dp(0, 0) * pow(2, cnt.get(1, 0))) % M",0
"class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        idx = defaultdict(list)
        for i, n in enumerate(nums):
            idx[n].append(i)
        
        count = 0 
        for i in range(len(nums)-3):
            for j in range(i+1, len(nums)-2):
                for k in range(j+1, len(nums)-1):
                    s = nums[i] + nums[j] + nums[k]
                    count += sum(l > k for l in idx[s])
                        
        return count",1
"class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        if not properties:
            return 0
        
        properties.sort(key = lambda x: (x[0], -x[1]))
        
        stack = []
        size = len(properties)
        
        for i in range(size):
            defen = properties[i][-1]
            if not stack:
                stack.append(defen)
            else:
                while stack and defen > stack[-1]:
                    stack.pop()
                    
                stack.append(defen)
        
        return size - len(stack)",1
"class Solution:
    def firstDayBeenInAllRooms2(self, next_visit: List[int]) -> int:
        p = 10**9 + 7
        n = len(next_visit)
        dp = [0]*n

        for i in range(1,n):
            dp[i] = (2 * dp[i-1] - dp[next_visit[i-1]] + 2) % p

        return dp[-1]

    def firstDayBeenInAllRooms(self, next_visit: List[int]) -> int:
        p = 10**9 + 7
        n = len (next_visit)
        not_visited = set(range(n))

        visits = [0] * n
        last_day = [float('-inf')] * n

        def simulate (room, day):
            not_visited.discard(room)
            while not_visited:
                visits[room] += 1
                last_day[room] = day
                if visits[room] &amp; 1:
                    # This room has been visited an odd number of times.
                    day = (2*day - last_day[next_visit[room]] + 1) % p

                # This room has been visited an even number of times.
                day += 1
                room = (room + 1) % n
                not_visited.discard(room)

            return day

        return simulate (0, 0) % p",1
"class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        
        idx = word.find(ch)
        if idx==-1:
            return word
        else:
            res = list(word)
            first = res[idx::-1]
            last = res[idx+1:]
            ans = first+last
            return ''.join(ans)",1
"class Solution:
    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        counts = {}
        for i in range(len(rectangles)):
            rectangles[i] = rectangles[i][0]/rectangles[i][1]
            if rectangles[i] in counts:
                counts[rectangles[i]] += 1
            else:
                counts[rectangles[i]] = 1
        tc = 0
        for c in counts:
            tc += (counts[c]*(counts[c]-1))//2
        return tc",1
"class Solution:
    def maxProduct(self, s: str) -> int:
        if len(s) < 2:
            return 0
        if len(s) == 2:
            return 1
        self.ans = -1
        visited = set()
        def dfs(arr1, arr2, idx):
            if tuple(sorted([arr1, arr2]) + [idx]) in visited:
                return
            visited.add(tuple(sorted([arr1, arr2]) + [idx]))
            if arr1 == arr1[::-1] and arr2 == arr2[::-1]:
                self.ans = max(self.ans, len(arr1) * len(arr2))
            if idx == len(s):
                return
            dfs(arr1+s[idx], arr2, idx+1)
            dfs(arr1, arr2+s[idx], idx+1)
            dfs(arr1, arr2, idx+1)
        dfs("""", """", 0)
        return self.ans",0
"class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        ans = [1] * len(parents)
        if 1 in nums: 
            tree = {}
            for i, x in enumerate(parents): 
                tree.setdefault(x, []).append(i)
                
            k = nums.index(1)
            val = 1
            seen = set()
            
            while k != -1: 
                stack = [k]
                while stack: 
                    x = stack.pop()
                    seen.add(nums[x])
                    for xx in tree.get(x, []): 
                        if nums[xx] not in seen: 
                            stack.append(xx)
                            seen.add(nums[xx])
                while val in seen: val += 1
                ans[k] = val
                k = parents[k]
        return ans",0
"class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        ans = 0 
        freq = defaultdict(int)
        for x in nums: 
            ans += freq[x - k] + freq[x + k]
            freq[x] += 1
        return ans",1
"class Solution:
    def findOriginalArray(self, changed: List[int]) -> List[int]:
        # first check if array is even
        # create counter map
        # sort the array and iterate from beginning by crossing off doubled value
        # Time: O(n log n)
        # Space: O(n)
        
        if len(changed) % 2 != 0:
            return []

        counter = defaultdict(int)
        for val in changed:
            counter[val] += 1
        
        changed.sort()
        ans = []
        for val in changed:
            if val in counter and counter[val] != 0:
                if val*2 not in counter or counter[val*2] == 0:
                    return []
                counter[val] -= 1
                counter[val*2] -= 1
                ans.append(val)
        return ans",1
"class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:

        rides_from_start = defaultdict(list)
        for start, end, tip in rides:
            rides_from_start[start].append((end, tip))
            
        @cache
        def recursive(actual_position):
            if actual_position == n: # We are at the end
                return 0
            elif actual_position in rides_from_start:
                maximum = 0
                # take any of the rides starting at actual_position
                for end, tip in rides_from_start[actual_position]:
                    maximum = max(maximum, end - actual_position + tip + recursive(end))
                    
                # dont take the ride and check the next position
                maximum = max(maximum, recursive(actual_position + 1))
                
                return maximum
            else:
                # check the next position
                return recursive(actual_position+1)
        
        return recursive(0)",0
"class Solution:
    def minOperations(self, nums: List[int]) -> int:
                
        n = len(nums)
        ans = n
        nums.sort()
        cnt = Counter(nums)
        
        # build key for repeated occurance
        repeat = sorted(k for k in cnt if cnt[k] > 1)
        
        # build prefix sum for repeated occurance need to be changed
        repeat_change = list(accumulate([cnt[x] - 1 for x in repeat], initial=0))


        for i in range(n):
            # numbers left side all need to be changed
            left = i
            
            # numbers right side all need to be changed
            loc = bisect.bisect(nums, nums[i] + n - 1)
            right = n - loc
            
            # calculate occurance of repeated number within [nums[i], nums[i] + n - 1]
            repeat_l = bisect.bisect_left(repeat, nums[i])
            repeat_r = bisect.bisect(repeat, nums[i] + n - 1)
            ans = min(ans, left + right + repeat_change[repeat_r] - repeat_change[repeat_l])
        
        return ans",1
"class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        X=0
        for i in operations:
            X= X+1 if i[1]==""+""  else X-1
        return X",1
"class Solution:
    def sumOfBeauties(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        maxPre = nums[0]
        minNums = nums[-1]
        minPost = [0]*(n-1)
        for i in range(n-2, 0, -1):
            minPost[i] = minNums
            if nums[i] < minNums:
                minNums = nums[i]
        for i in range(1, n-1):
            if nums[i] > maxPre and nums[i] < minPost[i]:
                ans += 2
            elif nums[i] > nums[i-1] and nums[i] < nums[i+1]:
                ans += 1
            if nums[i] > maxPre:
                maxPre = nums[i]
        return ans",0
"class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        def helper(subString, string):
            string = iter(string)
            return all(c in string for c in subString)
        
        counter = defaultdict(lambda: 0)
        
        for char in s: 
            counter[char] += 1
            
        chars = """"
        for key in counter: 
            if counter[key]//k: 
                chars += key*(counter[key]//k)
                
        for i in range(len(chars), 0, -1):
            possibilities = set()        
            for comb in combinations(chars, i):
                for perm in permutations(comb):                    
                    subString = """".join(perm)
                    possibilities.add(subString)
                    
            possibilities = sorted(possibilities, key = lambda item: (len(item), item), reverse = True)
        
            for pos in possibilities: 
                if helper(pos*k, s):
                    return pos
                    
        return """"",0
"class Solution:
    
    def maximumDifference(self, nums: List[int]) -> int:
        
		# <2 elements in nums seq
		if not nums or len(nums) <= 1:
            return -1
		
		# initialize current min el (val, index) and max diff
        current_min = (float('inf'), -1)
        current_diff = nums[1]-nums[0] # min 2 el's in sequence
		
		# O(n) iterations
        for i in range(0, len(nums)):
		
            if nums[i] < current_min[0]:
                current_min = (min(nums[i], current_min[0]), i) # update min elem
			
            current_diff = max(current_diff, nums[i] - nums[current_min[1]]) # update max diff
        
		return current_diff if current_diff else -1",1
"class Solution:
def gridGame(self, grid: List[List[int]]) -> int:
    
    res = float('inf')
    top_right_sum = sum(grid[0][1:])
    bottom_left_sum = 0
    
    n =  len(grid[0])
    for i in range(n):
        res = min(res,max(top_right_sum,bottom_left_sum))
        if i+1<n:
            top_right_sum -= grid[0][i+1]
        bottom_left_sum += grid[1][i]
    
    return res",1
"class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        abc='abcdefghijklmnopqrstuvwxyz'
        n=len(board)
        m=len(board[0])
        def check(a,b):
            la=len(a)
            lb=len(b)
            b_=b[::-1]
            start=[]
            n=0
            for i in range(la):
                if i==0 and (a[i]=="" "" or a[i] in abc):
                    start.append(i)
                    n+=1
                elif i>0 and (a[i]=="" "" or a[i] in abc) and a[i-1]==""#"":
                    start.append(i)
                    n+=1
                elif i>0 and a[i]=='#' and (a[i-1]==' ' or a[i-1] in abc):
                    start.append(i)
                if i==la-1 and (a[i]==' ' or a[i] in abc):
                    start.append(i+1)
            for i in range(n):
                flag=0
                flag1=0
                if start[2*i+1]-start[2*i] == lb:
                    
                    for j in range(start[2*i],start[2*i+1]):
                        k=j-start[2*i]
                        if not (a[j]==' ' or a[j]==b[k]):
                            # print(a[j],b[k])
                            flag=1
                            break
                    for j in range(start[2*i],start[2*i+1]):
                        k=j-start[2*i]
                        if not (a[j]==' ' or a[j]==b_[k]):
                            # print(a[j],b[k])
                            flag1=1
                            break                   
                    if flag==0 or flag1==0:
                        return True
            return False                          
        new=[["""" for _ in range(n)] for _ in range(m)]
        for i in range(n):
            for j in range(m):
                new[j][i]=board[i][j]
        s=set()
        for i in range(n):
            s.add("""".join(board[i]))
        for i in range(m):
            s.add("""".join(new[i]))
        for i in s:
            if check(i,word):
                return True
        return False",0
"class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        @lru_cache(None)
        def allEval(x):
            lo = eval(x)
            if lo > 1000:
                return set()
            ans = set([lo])
            if '*' not in x or '+' not in x or lo==1000:
                return ans
            for pos, char in enumerate(x):
                if char not in ['+', '*']:
                    continue
                left, right = allEval(x[:pos]), allEval(x[pos+1:])
                if char == '+':
                    ans |= {a + b for a in left for b in right if a+b<=1000}
                if char == '*':
                    ans |= {a * b for a in left for b in right if a*b<=1000}
            return ans
        S = allEval(s)
        correct = eval(s)
        return sum(5 if x==correct else (2 if x in S else 0) for x in answers)",0
"class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if m*n != len(original):
            return []
        a1 = []
        for i in range(0, m):
            a2 = []
            for j in range(0, n):
                a2.append(original[i*n + j])
            a1.append(a2)
        return a1",1
"class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        count=0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if(i!=j):
                    if(nums[i] + nums[j] == target):
                        count+=1
        return count",1
"class Solution:
    def maxConsecutiveAnswers(self, nums: str, k: int) -> int:
        n = len(nums)
        
        def util(char, K):
            ans, l = 0, 0
            for r in range(n):
                if nums[r] == char:
                    if K == 0:
                        while nums[l] != char: 
                            l += 1
                        l += 1
                    else : 
                        K-= 1
                        
                ans = max(ans, r - l + 1)
            return ans
        
        return max(util('F', k), util('T', k))",0
"class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        """"""This is a good problem. It's not difficult, but is quite complex.

        The idea is that once we change a position at i, for all the pivots at
        1...i, the sum of the left half stay the same whereas the sum of
        the right half changes by delta = k - nums[i]. Similarly, for all the
        pivots at i + 1...n - 1, the left half changes by delta, whereas the
        right half stay the same.

        We can pre-compute all the differences at each pivot position and make
        that into a diffs = [d1, d2, .... , dn-1]

        Then after a change at i, if we want the pivots at 1...i to form a good
        partition, we must have left - (right + delta) = 0 => delta = left - right
        In other words, the number of good partitions is the count of d1, d2, ...
        di that are equal to delta. Similarly, if we want the pivots at i + 1...
        n - 1 to form a good partition, we must have left + delta - right = 0
        => left - right = -delta. In other words, the number of good partitions
        is the count of di+1, ...., dn-1 that are equal to -delta.

        Based on this, we progressively build a left sum and right sum to
        compute the diffs array. And then progressively build a left counter
        and right counter to compute the number of matches to delta and -delta.

        The difficulty is in the implementation, especially with the indices.

        O(N), 7339 ms, faster than 32.20%
        """"""
        N = len(nums)
        diffs = []
        sl, sr = 0, sum(nums)
        for i in range(N - 1):
            sl += nums[i]
            sr -= nums[i]
            diffs.append(sl - sr)
        diffs.append(math.inf)  # to prevent error in the counter arithemtic
        
        cl, cr = Counter(), Counter(diffs)
        res = cl[0] + cr[0]
        for i in range(N):
            d = k - nums[i]
            res = max(res, cl[d] + cr[-d])
            cl[diffs[i]] += 1
            cr[diffs[i]] -= 1
        return res",0
"class Solution:

    def safe_val_by_index(self, arr, start, end):
        try:
            val = arr[start:end]
        except IndexError:
            return []
        return val
    
    def minimumMoves(self, s: str) -> int:
        
        a = list(s)
        n = len(a)
        p = 'X'
        
        template = ['O']*3
        ans = 0
        
        idx = a.index(p) if p in a else -1
        
        while idx >= 0:
            
            # possible substring
            # idx-2 .. idx, idx-1 .. idx+1, idx .. idx + 2
            moves = [
                [(max(0, idx), min(len(a), idx+3)), -1],
                [(max(0, idx-1), min(len(a), idx+2)), -1],
                [(max(0, idx-2), min(len(a), idx+1)), -1]   
            ]
            
            # default
            best_move = moves[0]
            
            for move in moves:
                # find susbstring with the most 'X's
                move[1] = self.safe_val_by_index(a, *move[0]).count('X')
                if move[1] >= best_move[1]:
                    best_move = move
            
            a[best_move[0][0]:best_move[0][1]] = template   
            ans += 1
            
            idx = a.index(p) if p in a else -1
        
        return ans",0
"class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        #finding the equal distribution of remaining sum
        temp = mean*(n+len(rolls)) - sum(rolls)
        each = temp//n
        rem = temp%n
        
        #return empty if out of dice range
        if (not (1<=(each + 1)<=6) and rem>0) or not (1<=each<=6):
            return []
        
        res = [each]*n
        i = 0
        #adding the remainder to each possible
        while rem > 0 and i<n:
            res[i] += 1
            rem -= 1
            i += 1
            
        return res",1
"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False",0
"class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        rest = sum(x == letter for x in s)
        stack = []
        for i, x in enumerate(s): 
            while stack and stack[-1] > x and len(stack) + len(s) - i > k and (stack[-1] != letter or repetition < rest): 
                if stack.pop() == letter: repetition += 1
            if len(stack) < k and (x == letter or len(stack) + repetition < k): 
                stack.append(x)
                if x == letter: repetition -= 1
            if x == letter: rest -= 1
        return """".join(stack)",0
"class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        return [v for v, c in Counter(itertools.chain(set(nums1), set(nums2), set(nums3))).items() if c >=2]",0
"class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        m,n = len(grid),len(grid[0])
        count = 0
        li = []
        
        for i in range(m):
            for j in range(n):
                li.append(grid[i][j])
                
        li.sort()
        med = li[len(li)//2]
        
        for num in li:
            if num < med or num > med: 
                need = abs( (med - num)//x)
                if need == 0:
                    return -1
                count += need
        return count",1
"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 2;
        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);
        psum1, psum2 = [{0}], [{0}];
        
        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):
            for i, x in enumerate(ns):
                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});
                
                for j in range(len(ps) - 1, 0, -1):
                    ps[j] = ps[j].union({s + x for s in ps[j-1]});
                    
        target = sum1 - sum2;
        answer = abs(target);

        # 2p1 - 2p2 ~ sum1 - sum2
        
        for i in range(len(psum1)):
            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));
            idx1, idx2 = 0, 0;
            len1, len2 = len(p1), len(p2);
            
            while idx1 < len1 and idx2 < len2:
                diff = p1[idx1] - p2[idx2];
                offset = 2 * diff - target;
                
                answer = min(answer, abs(offset));
                if offset < 0: idx1 += 1;
                else: idx2 += 1;
                    
        return answer;",0
"class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats = sorted(seats)
        students = sorted(students)
        count = 0
        for i in range(len(seats)):
            count += abs(seats[i] - students[i])
        return count",1
"class Solution:
    def winnerOfGame(self, arr: str) -> bool:
        n = len(arr)
        
        def count(char):
            i, j = 0, 0
            res = 0
            while j < n:
                temp = 0
                while j < n and arr[j] == char:
                    temp += 1
                    j += 1
                    
                res += (temp-2) if temp > 2 else 0
                j += 1
                i = j
            return res
        
        return count('A') > count('B')",1
"class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = collections.defaultdict(list)
        for a, b in edges:                                       # build graph
            graph[a].append(b)
            graph[b].append(a)
        dq = collections.deque([(0, 0)])                         # prepare bfs using deque
        ans, n = 0, 1
        visited = set()
        while dq:
            for _ in range(n):
                cur, step = dq.popleft()
                n -= 1                                           # keep track of size of dq
                visited.add(cur)
                for nei in graph[cur]:
                    if nei in visited: continue
                    visited.add(nei)
                    n += 1
                    dq.append((nei, step+1))
                if cur:
                    time = step * 2                              # first msg round trip time    
                    mod = time % patience[cur]                   
                    finished = patience[cur] if not mod else mod # last msg finished moves
                    total = time + (time - finished)             # total time = time + last_msg_unfinished_moves
                    ans = max(ans, total)
        return ans + 1",0
"class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        result = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                temp = nums1[i]*nums2[j]
                result.append(temp)
        result.sort()
        return result[k-1]",1
"class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        s = s.split(' ')
        last = float('-inf')
        
        for char in s:
            if char.isnumeric():
                if int(char) <= last:
                    return False
                else:
                    last = int(char)
                    
        return True",1
"class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        len_nums = len(nums)
        max_val = 0
        count_max = 0
        for len_c in range(1, len_nums + 1):
            for comb in combinations(nums, len_c):
                val = 0
                for n in comb:
                    val |= n
                if val > max_val:
                    count_max = 1
                    max_val = val
                elif val == max_val:
                    count_max += 1
        return count_max",1
"class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        g = defaultdict(set)
        for u, v in edges:
            g[u].add(v)
            g[v].add(u)              
        
        q = deque([(1, 0)])
        # to store the two minimum node counts for each visited node
        vis = defaultdict(set, {0: {0}})
        minval = set()
        while q:
            node, cnt = q.popleft()
            if node == n:
                minval.add(cnt)
                if len(minval) == 2: break
            for nei in g[node]:
                if len(vis[nei]) > 1 and cnt + 1 >= max(vis[nei]): continue
                vis[nei] = {min(vis[nei])} | {cnt + 1} if vis[nei] else {cnt + 1}
                q.append((nei, cnt + 1))
        
        minval = sorted(minval)
        def helper(nodes):
            t = 0
            while nodes > 0:
                t += time
                nodes -= 1
                if nodes == 0: break
                # if current time exceeds change and change frequency is odd
                if t >= change and (t // change) % 2:
                    t = (t // change + 1) * change
            return t
        
        if len(minval) == 1:
            return helper(minval[0] + 2)
        
        # either use the 2nd minimum path or the 1st path add two more nodes (like example 2)
        return min(helper(minval[0]+2), helper(minval[1]))",0
"class Solution:
    def countValidWords(self, sentence: str) -> int:
        valid = 0
        digits = set(string.digits)
        punctuation = set(['!', '.', ','])
        for token in sentence.split():
            ts = set(token)
            if digits &amp; ts:
                continue
            if p := punctuation &amp; set(ts):
                if len(p) > 1 or token[-1] not in punctuation:
                    continue
                if max(token.count(c) for c in punctuation) > 1:
                    continue
            if token.count('-') > 1:
                continue
            if token.count('-') == 1:
                idx = token.find('-')
                if idx == 0 or idx == len(token) - 1 or not token[idx-1].islower() or not token[idx+1].islower():
                    continue                
            valid += 1
        return valid",0
"class Solution:
    def nextBeautifulNumber(self, n: int) -> int:

        def count(n):
            cnt = [0]*10
            while n:
                cnt[n%10] += 1
                n //= 10
            return cnt
        
        def valid(cnt):
            for i, c in enumerate(cnt):
                if c > 0 and c != i:
                    return False
            return True

        x = n+1
        while True:
            cnt = count(x)
            if valid(cnt):
                return x
            x += 1",1
"class Solution:
    def countHighestScoreNodes(self, parents: List[int]) -> int:
        hmap=defaultdict(list)
        n=len(parents)
        for i in range(n):
            hmap[i]=[]
        for i in range(1,n):
            hmap[parents[i]].append(i)
        self.childCount=[1 for i in range(n)]
        for i in hmap[0]:
            self.childCount[0]+=self.dfs(i,hmap)
        ans=0
        count=0
        for i in range(n):
            currProd=1
            currSum=0
            for j in hmap[i]:
                currProd*=self.childCount[j]
                currSum+=self.childCount[j]
            rem=(n-1)-(currSum)
            if rem>=1:
                currProd*=rem
            if ans==currProd:
                count+=1
            if ans<currProd:
                count=1
                ans=currProd
        return count
    def dfs(self,curr,hmap):
        if hmap[curr]==[]:
            return 1
        for it in hmap[curr]:
            self.childCount[curr]+=self.dfs(it,hmap)
        return self.childCount[curr]",0
"class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        
        g = defaultdict(set)
        deg = defaultdict(int)
        for a, b in relations:
            deg[b-1] += 1
            g[a-1].add(b-1)
            
        cnt = 0
        
        # time to finish all prerequisites
        prev_max_t = defaultdict(int)
        
        q = [(time[x], x) for x in range(n) if deg[x] == 0]
        heapify(q)
        
        while q:
            t, course = heappop(q)
            cnt += 1
            if cnt == n:
                return t
            for nei in g[course]:
                deg[nei] -= 1
                prev_max_t[nei] = max(prev_max_t[nei], t)
                if deg[nei] == 0:
                    heappush(q, (prev_max_t[nei] + time[nei], nei))",0
"class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str: 
        unique = [v for v, count in Counter(arr).items() if count == 1]
        return unique[k-1] if k <= len(unique) else """"",0
"class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        end_max = defaultdict(int)
        for start, end, val in events:
            end_max[end] = max(end_max[end], val)
        max_val = max(end_max.values())
        lst_ends = sorted(end_max.keys())
        for i in range(1, len(lst_ends)):
            end_max[lst_ends[i]] = max(end_max[lst_ends[i]],
                                       end_max[lst_ends[i - 1]])
        for start, end, val in events:
            idx = bisect_right(lst_ends, start)
            if idx > 0 and start > lst_ends[idx - 1]:
                max_val = max(max_val, end_max[lst_ends[idx - 1]] + val)
            elif idx > 1 and start > lst_ends[idx - 2]:
                max_val = max(max_val, end_max[lst_ends[idx - 2]] + val)
        return max_val",0
"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        pref=[0]
		#prefix sum array for calculating *
        for x in s:
            if x=='*':
                pref.append(pref[-1]+1)
            else:
                pref.append(pref[-1])
        ans=[]
		#array for finding the next |
        nex=[0]*len(s)
        stack=[]
        for x in range(len(s)-1,-1,-1):
            if not stack:
                nex[x]=inf
            elif s[x]=='|':
                nex[x]=x
            else:
                nex[x]=stack[-1]
            if s[x]=='|':
                stack.append(x)
        #array for finding the previous |
		prev=[0]*len(s)
        for x in range(len(s)):
            if not stack:
                prev[x]=-inf
            elif s[x]=='|':
                prev[x]=x
            else:
                prev[x]=stack[-1]
            if s[x]=='|':
                stack.append(x)
            
        for x in queries:
			#if | from both ends coincide or cross
            if nex[x[0]]>=prev[x[1]]:
                ans.append(0)
            else:
                #find the next | and the previous | and calculate the * in between
                ans.append(pref[prev[x[1]]]-pref[nex[x[0]]])
        return ans",0
"class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        n = len(pieces)
        mp = {""bishop"": ((-1, -1), (-1, 1), (1, -1), (1, 1)),
              ""queen"" : ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)), 
              ""rook""  : ((-1, 0), (0, -1), (0, 1), (1, 0))}
        
        dirs = [[]] # directions
        for piece in pieces: dirs = [x+[xx] for x in dirs for xx in mp[piece]]
        
        positions = tuple(map(tuple, positions))
        
        def fn(*args): 
            """"""Return possible moves along given direction.""""""
            stack = [((1<<n)-1, positions)]
            while stack: 
                mask, pos = stack.pop()
                ans.add(pos)
                m = mask
                while m: 
                    p = []
                    for i in range(n): 
                        if m &amp; (1 << i): 
                            p.append((pos[i][0] + args[i][0], pos[i][1] + args[i][1]))
                            if not (1 <= p[i][0] <= 8 and 1 <= p[i][1] <= 8): break 
                        else: p.append(pos[i])
                    else: 
                        cand = tuple(p)
                        if len(set(cand)) == len(cand) and m: stack.append((m, cand))
                    m = mask &amp; (m-1)

        ans = set()
        for d in dirs: fn(*d)
        return len(ans)",0
"class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i, n in enumerate(nums):
            if n == i % 10:
                return i
        return -1",1
"class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        '''
        5->3->1->2->5->1->2
              C     C. C
        c = [2,4,5]
        '''
        if head.next.next is None:
            return [-1,-1]
        
        def calc(head):
            prev = head
            temp = head.next
            while temp:
                next_node = temp.next
                if next_node is not None:
                    if prev.val > temp.val < next_node.val or prev.val < temp.val > next_node.val:
                        break
                    prev,temp = temp,next_node
                else:
                    break
            
            max_dis = 0
            min_dis = pow(10,5)+1
            count = 0
            mi_count = pow(10,5)+1
            while temp:
                next_node = temp.next
                if next_node is not None:
                    if prev.val > temp.val < next_node.val or prev.val < temp.val > next_node.val:
                        max_dis = count
                        min_dis = min(min_dis,mi_count)
                        mi_count = 0
                    count += 1
                    mi_count += 1
                    prev,temp = temp,next_node
                else:
                    break
            
            if max_dis != 0 and min_dis != pow(10,5)+1:        
                return [min_dis,max_dis]
            return [-1,-1]
			
        return calc(head)",0
"class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        nums.sort()
        q = collections.deque([(start, 0)])
        visited = set()
        
        while q:
            for _ in range(len(q)):
                x, step = q.popleft()
                if x == goal:
                    return step
                
                if x < 0 or x > 1000:
                    continue
                
                if x in visited:
                    continue
                visited.add(x)

                for num in nums:
                    q.append((x+num, step+1))
                    q.append((x-num, step+1))
                    q.append((x^num, step+1))
                    
        
        return -1",1
"class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        
        def gg(s): 
            """"""Return possible length.""""""
            ans = {int(s)}
            for i in range(1, len(s)): 
                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}
            return ans
        
        @cache
        def fn(i, j, diff): 
            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit(): 
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]): 
                    if fn(ii, j, diff-x): return True 
            elif j < len(s2) and s2[j].isdigit(): 
                jj = j 
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]): 
                    if fn(i, jj, diff+x): return True 
            elif diff == 0: 
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)
            elif diff > 0: 
                if i < len(s1): return fn(i+1, j, diff-1)
            else: 
                if j < len(s2): return fn(i, j+1, diff+1)
            return False 
            
        return fn(0, 0, 0)",0
"class Solution:
    def countVowels(self, word: str) -> int:
        vowels = [""a"", ""e"", ""i"", ""o"", ""u""]
        res = []
        vowels_cop = set(vowels.copy())

        for j in range(len(word)):
            if word[j] not in vowels:
                continue
            string = """"
            for i in range(j, len(word)):
                flag = False
                if word[i] in vowels:
                    string += str(i)
                    vowels_cop.discard(word[i])
                    if not vowels_cop:
                        res.append(string)
                    flag = True
                if not flag:
                    string = """"
                    vowels_cop = set(vowels.copy())
            string = """"
            vowels_cop = set(vowels.copy())

        print(len(set(res)))",0
"class Solution:
    def countVowels(self, word: str) -> int:
        vowels=""aeiou""
        n=len(word)
        prefix=[0]
        for s in word:
            prefix.append(prefix[-1]+ (s in vowels))
        prefix.pop(0)
        total=sum(prefix)
        diff=0
        res=total
        for i in range(1,n):
            diff+=prefix[i-1]
            res+=total-(n-i)*prefix[i-1]-diff
        
        return res",1
"class Solution:
    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
        left, right = 1, max(quantities)
        while left < right:
            middle = (left + right) // 2
            if sum(ceil(q / middle) for q in quantities) > n:
                left = middle + 1
            else:
                right = middle
        return right",1
"class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        graph = defaultdict(list)
        dist = defaultdict(int)
        parent = defaultdict(int)
        R2Bpath = defaultdict(list)
        for u, v, w in edges:
            graph[u].append( (v, w) )
            graph[v].append( (u, w) )
        
        ## calc Djik: Q[ (time, node, parent) ]
        Q = [ (0, 0, -1) ]
        while Q:
            time, node, par = heapq.heappop(Q)
            if node not in dist:
                dist[node] = time
                parent[node] = par
                for v, w in graph[node]:
                    alt = time + w
                    heapq.heappush(Q, (alt, v, node) )
        
        ## get ancesters of each nodes
        for node in range(len(values)):
            if node in dist:
                curr = node
                while curr != -1:
                    R2Bpath[node].append(curr)
                    curr = parent[curr]
        
        
        def get_score(ancesters: List[int]) -> int:
            score = 0
            for node in set(ancesters):
                score += values[node]
            return score
        
        self.maxScore = 0
        def dfs(curr=0, cost=0, path=[0]):
            self.maxScore = max( self.maxScore, get_score(path+R2Bpath[curr]) )
            for v, time in graph[curr]:
                if cost+time+dist[v] <= maxTime:
                    dfs(v, cost+time, path+[v])
                        
        dfs()
        return self.maxScore",0
"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        f1 = Counter(word1)
        f2 = Counter(word2)
        for ch in string.ascii_lowercase:
            if abs(f1[ch]-f2[ch]) > 3:
                return False
        return True",1
"class Solution:
    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        class Node:
            def __init__(self, key, maximum):
                self.key = key
                self.maximum = maximum
                self.left = None
                self.right = None
        head = Node(items[0][0], items[0][1])
        for i in range(1, len(items)):
            node = head
            new_node = Node(items[i][0], items[i][1])
            while True:
                if new_node.key > node.key:
                    new_node.maximum = max(new_node.maximum, node.maximum)
                    if node.right:
                        node = node.right
                    else:
                        node.right = new_node
                        break
                elif new_node.key < node.key:
                    node.maximum = max(new_node.maximum, node.maximum)
                    if node.left:
                        node = node.left
                    else:
                        node.left = new_node
                        break
                else:
                    node.maximum = max(new_node.maximum, node.maximum)
                    break
            
        answer = []
        for query in queries:
            node = head
            maximum = 0
            while node:
                if query > node.key:
                    maximum = max(maximum, node.maximum)
                    node = node.right
                elif query < node.key:
                    node = node.left
                else:
                    maximum = max(maximum, node.maximum)
                    break
            answer.append(maximum)
        return answer",0
"class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        
        from sortedcontainers import SortedList
        
        tasks.sort()
        workers.sort()
        
        def check_valid(ans):
            
            # _tasks = SortedList(tasks[:ans])
            _tasks = deque(tasks[:ans])
            _workers = workers[-ans:]
            remain_pills = pills
            
            for worker in _workers:
                task = _tasks[0]
                if worker >= task:
                    # the worker can finish the min task without pill, just move on
                    # _tasks.pop(0)
                    _tasks.popleft()
                elif worker + strength >= task and remain_pills:
                    # the worker cannot finish the min task without pill, but can solve it with pill
                    # remove the max task that the strengthened worker can finish instead
                    # remove_task_idx = _tasks.bisect_right(worker + strength)
                    remove_task_idx = bisect.bisect_right(_tasks, worker + strength)
                    # _tasks.pop(remove_task_idx - 1)
                    del _tasks[remove_task_idx - 1]
                    remain_pills -= 1
                else:
                    return False
            return True
        
        lo, hi = 0, min(len(workers), len(tasks))
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if check_valid(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo",0
"class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        total = sum(tickets)
        n = len(tickets)
        idx = 0 
        days = 0     
        
        while total > 0:
            idx = idx % n 
            if tickets[idx] > 0:
                tickets[idx] -= 1
                days += 1
                total -= 1
                if idx == k and tickets[idx] == 0:
                    return days 
            idx += 1
        return days",1
"class Solution:
    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.helper(head, 1)
    
    def helper(self, head, size, lvl = 0):
        
        # check if we should reverse
        count, node = 0, head
        for _ in range(size):
            if not node:
                break
            count += 1
            node = node.next
        
        if count == 0:
            return head
        
        #print(lvl * 2 * ' ', count, size)

        
        if count % 2 == 1:
            # do not reverse
            node = head
            for _ in range(count - 1):
                node = node.next
            node.next = self.helper(node.next, size + 1, lvl + 1)
            return head
        else:
            # perform reverse
            prev, curr = None, head
            for _  in range(count):
                tmp = curr.next  # prepare
                
                curr.next = prev # link
                
                prev = curr     # move
                curr = tmp      # move

            head.next = self.helper(curr, size + 1, lvl + 1)
            return prev",0
"class Solution:
    def decodeCiphertext(self, et: str, rows: int) -> str:
        L = len(et)
        if not L: return et
        
        cols, ans, start = L//rows, et[0], 0
        i, j = 0, start
        while start < cols - 1:
            i, j = i + 1, j + 1
            if i == rows or j == cols:
                start += 1
                i, j = 0, start
                ans += et[start]
                continue
            
            ans += et[cols*i + j]
                    
        return ans.rstrip()",0
"class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        
        result = [False for _ in requests]
        
        connected_components = [{i} for i in range(n)]
        
        connected_comp_dict = {}
        for i in range(n):
            connected_comp_dict[i] = i
        
        banned_by_comps = [set() for i in range(n)]
        for res in restrictions:
            banned_by_comps[res[0]].add(res[1])
            banned_by_comps[res[1]].add(res[0])
        for i,r in enumerate(requests):
            n1, n2 = r[0], r[1]
            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]
            if c1 == c2:
                result[i] = True
            else:
                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):
                    connected_components[c1].update(connected_components[c2])
                    banned_by_comps[c1].update(banned_by_comps[c2])
                    for node in connected_components[c2]:
                        connected_comp_dict[node] = c1
                    result[i] = True
                
        return result",0
"class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        n = len(colors)
        for i in range(n - 1, 0, -1):
            for j in range(n - i):
                if colors[j] != colors[j + i]:
                    return i",1
"class Solution:
    def wateringPlants(self, arr: List[int], capacity: int) -> int:
        n = len(arr)
        cur = capacity
        steps = 0
        
        for i in range(n):
            if arr[i] <= cur:
                steps += 1
            else:
                steps += (2*i+1)  #including forward and return steps
                cur = capacity
                
            cur -= arr[i]
            
        return steps",1
"class Solution:
    def kMirror(self, k: int, n: int) -> int:
        
        # start from single digit base k
        cands = [str(i) for i in range(1, k)]
        ans = 0
        
        while n > 0:
            # check current canddiates to see if base 10 is also mirroring
            for cand in cands:
                b10 = str(int(cand, k))
                if b10 == b10[::-1]:
                    ans += int(b10)
                    n -= 1
                    if n == 0: return ans

            # construct new candidates 
            # if previous cand length is even just insert number between 0 and k - 1 into the middle
            # if previous cand length is odd just insert number after len//2+1 and should be the same with left part end digit
            new_cands = []
            for cand in cands:
                m = len(cand)
                for i in range(k):
                    if m % 2 == 0:
                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])
                    else:
                        left, right = cand[:m//2+1], cand[m//2+1:]
                        if str(i) == left[-1]:
                            new_cands.append(left + str(i) + right)
            cands = new_cands

            
        
        return ans",0
"class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        w1 = set(w for w, c in Counter(words1).items() if c == 1)
        w2 = set(w for w, c in Counter(words2).items() if c == 1)
        return  len(w1 &amp; w2)",0
"class Solution:
    def minimumBuckets(self, street: str) -> int:
        l=list(street.strip())
        c=0
        n=len(street)
        i=1
        while i < len(street)-1:#fill the buckets containg houses on both sides and change H to T
            if l[i-1]==""H"" and l[i+1]==""H"" and l[i]==""."":
                l[i-1]=""T""
                l[i+1]=""T""
                l[i]=""B""
                c+=1

            i+=1
        i=0
        while i<len(street):#fill buckets for remaining houses
            if i-1>=0:
                if l[i-1]==""H"":
                    if l[i]==""."":
                        c+=1
                        l[i-1]=""T""
                        l[i]=""B""
            if i+1<len(l):
                if l[i+1]==""H"":
                    if l[i]==""."":
                        c+=1
                        l[i]=""B""
                        l[i+1]=""T""
            i+=1
        if ""H"" in l:
            return -1
        return c",0
"class Solution:
    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
        
        rm=0
        lm=0
        rm=startPos[0]-homePos[0]# number of ups or downs
        lm=startPos[1]-homePos[1] # number of lefts or rights
        ans=0
        if rm<0:#we need to down
            a=startPos[0]
            while rm!=0:
                rm+=1
                ans+=rowCosts[a+1]#add costs according to the row numbers
                a+=1
        elif rm>0:#up
            a=startPos[0]
            while rm!=0:
                rm-=1
                ans+=rowCosts[a-1]
                a-=1
        if lm<0:#left
            a=startPos[1]
            while lm!=0:
                lm+=1
                ans+=colCosts[a+1]
                a+=1
        elif lm>0:#right
            a=startPos[1]
            while lm!=0:
                lm-=1
                ans+=colCosts[a-1]
                a-=1
        return ans",0
"class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n, res = len(grid), len(grid[0]), 0
        dp = [row[:] for row in grid]
		
        for i, j in product(range(m-2,-1,-1), range(1, n-1)):
            if grid[i][j]:
                dp[i][j] = min(dp[i+1][k] for k in range(j-1, j+2))+1
                res += dp[i][j]-1
				
        dp[0] = grid[0][:]
        for i, j in product(range(1, m), range(1, n-1)):
            if grid[i][j]:
                dp[i][j] = min(dp[i-1][k] for k in range(j-1, j+2))+1
                res += dp[i][j]-1
        return res",0
"class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        nums.sort()
        output = []
        for idx in range(len(nums)):
            if nums[idx] == target:
                output.append(idx)
        return output",1
"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        output = [-1] * len(nums)
        running = 0
        for idx, i in enumerate(nums):
            running += i
            if idx >= k*2:
                output[idx - k] = running // (k*2+1)
                running -= nums[idx - k*2]
                
        return output",1
"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_arr = max_arr = nums[0]
        min_i = max_i = 0
        n = len(nums)
        
		# finding max and min indices
        for i in range(1, n):
            if nums[i] > max_arr:
                max_arr = nums[i]
                max_i = i
                
            if nums[i] < min_arr:
                min_arr = nums[i]
                min_i = i
                
		# checking possibilities
        if min_i <= max_i:
            return min(min_i+1+n-max_i, max_i+1, n-min_i)
        else:
            return min(max_i+1+n-min_i, min_i+1, n-max_i)",1
"class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        secretHolders = set()
        secretHolders.add(0)
        secretHolders.add(firstPerson)
        
        tupleMeetings = {}
        for meeting in meetings:
            time = meeting[2]
            if(time in tupleMeetings):
                tupleMeetings[time].append((meeting[0], meeting[1]))
            else:
                tupleMeetings[time] = [(meeting[0], meeting[1])]
        
        #print(tupleMeetings)
        for key in sorted (tupleMeetings):
            edgeList = tupleMeetings[key]
            adjacencyList = {}
            for edge in edgeList:
                if(edge[0] not in adjacencyList):
                    adjacencyList[edge[0]] = set()
                adjacencyList[edge[0]].add(edge[1])
                if(edge[1] not in adjacencyList):
                    adjacencyList[edge[1]] = set()
                adjacencyList[edge[1]].add(edge[0])
            
            frontier = set()
            for edgeNode in adjacencyList:
                if(edgeNode in secretHolders):
                    frontier.add(edgeNode)

            while(len(frontier) > 0):
                newFrontier = set()
                for item in frontier:
                    if(item in adjacencyList):
                        for neighbor in adjacencyList[item]:
                            if(neighbor not in secretHolders):
                                secretHolders.add(neighbor)
                                newFrontier.add(neighbor)
                frontier = newFrontier
        return list(secretHolders)",0
"class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        n = len(digits)
        res = []
        
        for i in range(n):
            if digits[i] != 0:
                for j in range(n):
                    if j != i:
                        for k in range(n):
                            if digits[k] % 2 == 0 and k not in (i, j):
                                res.append(digits[i]*100+digits[j]*10+digits[k])
                            
        res = list(set(res))
        res.sort()
        return res",1
"class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None:
            return head
        if head.next == None:
            return head.next
        node = head
        n = 0
        while(node != None):
            n+=1
            node = node.next
        mid = n//2
        print(mid)
        n = 0
        node = head
        while(node != None):
            if(n == mid-1):
                node.next = node.next.next
                break
            n += 1
            node = node.next  
        return head",1
"class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        graph = defaultdict(set) # from.val -> (dest_node, 'L')
        
        que = deque([root])

        while que:
            size = len(que)
            for _ in range(size):
                node = que.popleft()
                if node.left:
                    que.append(node.left)
                    graph[node.val].add((node.left, 'L'))
                    graph[node.left.val].add((node, 'U'))
                if node.right:
                    que.append(node.right)
                    graph[node.val].add((node.right, 'R'))
                    graph[node.right.val].add((node, 'U'))
        
        
        
        que = deque([(startValue, '')])
        visited = set([startValue])
        while que:
            cnt, path = que.popleft()
            
            if cnt == destValue:
                return path
            
            for nei, label in graph[cnt]:
                if nei.val in visited:
                    continue
                que.append([nei.val, path + label])
                visited.add(nei.val)",0
"class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        
        # in degree table for each node
        in_degree = defaultdict(int)
        
        # out degree table for each node
        out_degree = defaultdict(int)
        
        # adjacency matrix for each node
        adj_matrix = defaultdict(list)
        
        
        # update table with input edge pairs
        for src, dst in pairs:
            
            in_degree[dst] += 1
            out_degree[src] += 1
            adj_matrix[src].append(dst)
            
        
        ## Case_#1:
        # There is eular circuit in graph, any arbitrary node can be start point, here we use source node of first edge just for convenience
        start_node_idx = pairs[0][0]
        
        
        ## Case_#2
        # There is no eular circuit. But there is eular path, find the start node by indegree and outdegree relation
        for node in adj_matrix:
            
			# find the node whose outdegree is one more than indegree
            if out_degree[node] - in_degree[node] == 1:
                start_node_idx = node
                break
        
        # ------------------------------------------------
        def eular_path( adjMatrix, path, cur_node):
            
            # Keep traverse to next node in DFS until all edges of current node are visited
            while adjMatrix[cur_node]:
                
                # pop one edge and get next visit node
                next_visit_node = adjMatrix[cur_node].pop()
                
                eular_path( adjMatrix, path, next_visit_node )
                
                # post-order style
                # current explorer is finished, record current edge pair 
                path.append([cur_node, next_visit_node])
                
                
        # ------------------------------------------------
        record = []
        eular_path(adj_matrix, record, start_node_idx)
        
        # reversed of post-order record is the answer of eular path        
        return reversed(record)",0
"class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)

        window = nums[:k]

        for i in range(k,n):
            curr_min = min(window)
            
            if nums[i] > curr_min:
                window.remove(curr_min)
                window.append(nums[i])

        return window",1
"class Solution:
    def goodDaysToRobBank(self, sec: List[int], time: int) -> List[int]:
        result = []
        
        n = len(sec) - 1
        
        if time == 0:
            copied = sec
            copied.sort()
            if copied == sec:
                return list(range(n+1))
        
        if n <= time:
            return
        
        else:
            t = time
            while t - time >= 0 and t + time <= n:
                temp = time
                s = t - time
                u = t + time
                flag = True
				
                while temp:
                    if sec[s] < sec[s+1]:
                        flag = False
                        break
                    else:
                        s += 1
        
                    if sec[u] < sec[u-1]:
                        flag = False
                        break
                    else:
                        u -= 1
						
                    temp -= 1
					
                if flag == True:
                    result.append(t)
                t += 1
        
        return result",0
"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        graph = defaultdict(set)
        for i, (x, y, r) in enumerate(bombs):
            for j, (a, b, _) in enumerate(bombs):
                if i != j and pow(x - a, 2) + pow(y - b, 2) <= r * r:
                    graph[i].add(j)
        max_bombs = 1
        for start in graph:
            detonated = set()
            layer = {start}
            while layer:
                new_layer = set()
                for current_bomb in layer:
                    if current_bomb not in detonated:
                        detonated.add(current_bomb)
                        if current_bomb in graph:
                            new_layer.update(graph[current_bomb])
                layer = new_layer
            max_bombs = max(max_bombs, len(detonated))
        return max_bombs",0
"class Solution:
    def countPoints(self, rings: str) -> int:
        colors = {'R': 0, 'G': 1, 'B': 2}
        result = 0
        rods = [0] * 10 
        for i in range(0, len(rings), 2):
            color = rings[i]
            rod = int(rings[i+1])
            if rods[rod] != 7:
                rods[rod] |= 1 << colors[color]
                if rods[rod] == 7:
                    result += 1
                    
        return result",0
"class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        result = 0
        n = len(nums)
        for i in range(n) :
            Min, Max = nums[i], nums[i]
            
            for j in range(i, n, 1) :
                Min = min(Min, nums[j])
                Max = max(Max, nums[j])
                result -= Max - Min
            
        return abs(result)",1
"class Solution:
    def minimumRefill(self, nums: List[int], capacityA: int, capacityB: int) -> int:
        
        
        n = len(nums)
        
        i = 0
        j = n-1
        
        canA = capacityA
        canB = capacityB
        
        count = 0
        
        while(i<j):
    
            # water the left plant
            if canA < nums[i]:
                canA = capacityA   
                count += 1
            canA -= nums[i]
            i += 1
            
            # water the right plant
            if canB < nums[j]:
                canB = capacityB
                count += 1
            canB -= nums[j]
            j -= 1
        
        # if both point to same plant in cases (it'll only happen if n is odd)
        if i==j:
            if canA > canB:
                if canA < nums[i]:
                    canA = capacityA    
                    count += 1
                canA -= nums[i]
            else:
                if canB < nums[j]:
                    canB = capacityB 
                    count += 1
                canB -= nums[j]
                
        
        return count",0
"class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        
        f = [0] * (2 * 10**5 + 1)
        for a, b in fruits:
            f[a] = b

        f_acc = list(accumulate(f, initial=0))
        n = len(f_acc)
        
        startPos += 1
        left_only = f_acc[startPos] - f_acc[max(0, startPos - k - 1)]
        right_only = f_acc[min(n - 1, startPos + k)] - f_acc[startPos - 1]
        ans = max(left_only, right_only)
        
        # turn left and then right
        for i in range(1, (k - 1) // 2 + 1):
            
            first_left = f_acc[startPos] - f_acc[max(0, startPos - i - 1)]
            then_right = f_acc[min(n - 1, startPos + k-2*i)] - f_acc[startPos]
        
            first_right = f_acc[min(n - 1, startPos + i)] - f_acc[startPos - 1]
            then_left = f_acc[startPos - 1] - f_acc[max(0, startPos - (k - 2*i) - 1)]
            ans = max(ans, first_left + then_right, first_right + then_left)
        
        return ans",0
"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]: return word
        return """"",1
"class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        outpur=""""
        rest=0
        for k in range(len(s)):
            if rest<len(spaces) and k == spaces[rest]:
                outpur=outpur+"" ""
                rest=rest+1
            outpur=outpur+s[k]
        return(outpur)",1
"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        lastPrice = None
        counter = 0
        seen = 0
        
        for price in prices:
            if lastPrice and lastPrice - price == 1:
                counter += 1 + seen
                seen += 1
            else:
                seen = 0
                
            counter += 1
            lastPrice = price
            
        return counter",1
"class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        n = len(arr)
        
        def lis(nums):
            '''
            Patience sort
            Time: O(NlogN)
            Space: O(N)
            '''
            n = len(nums)
            if n <= 1:
                return n
            # num, pointer
            c = []
            size = 0

            for x in nums:
			    # bisect as it is non-decreasing
                l = bisect.bisect_right(c, x)
                if l < size:
                    c[l] = x
                else:
                    c.append(x)
                    size = max(size, l+1)

            return size
        
        ans = 0
        for i in range(k):
            sub = []
            for j in range(i, n, k):
                sub.append(arr[j])
            ans += len(sub) - lis(sub)
        
        return ans",1
"class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int: 
        c=0
        m=0
        for i in range(len(sentences)):
            c=sentences[i].count(' ')
            if c+1>m:
                m=c+1
        return m",1
"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        available_ingredients=[]
        
        cook={}
        for ing in supplies:
            available_ingredients.append(ing)
        
        for rec in range(len(recipes)):
            cook[recipes[rec]]=ingredients[rec]
        
        def canCook(recipe,waiting):
            
            
            needed_ingrediants=cook[recipe]
            
            count=0
            for ing in needed_ingrediants:
                if ing in waiting:
                    return False
                if ing in available_ingredients:
                    count+=1
                elif ing in recipes:
                    waiting.append(ing)
                    if canCook(ing,waiting):
                        available_ingredients.append(ing)
                        count+=1
                    
                
            return count==len( needed_ingrediants)
            
        
        result=[]
        for recipe in recipes:

            if canCook(recipe,[]):
                result.append(recipe)
        
        return result",0
"class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        if len(s) % 2 == 1:
            return False
        
        # Left to right, try to balance "")""
        balance = 0
        for i in range(len(s)):
            if s[i] == ""("" or locked[i] == ""0"":
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
                
        # Right to left, try to balance ""(""
        balance = 0
        for i in range(len(s) - 1, -1, -1):
            if s[i] == "")"" or locked[i] == ""0"":
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
        
        return True",0
"class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        ans = 1                                                                  //Initialise the product with 1
        while left <= right:                                               // Start the multiplying numbers in
            if left == right:                                                 // Exception case when left is right else the number will be multiplied 2 times
                ans *= left                                                   //then only multiply either left or right
            else:
                ans *= left * right                                        // Else multiply left and right numbers and multiply with ans
            left += 1                                                         // Increment left by one
            right -= 1                                                        //Decrement right by 1
        count = 0                                                           // Initialise count of trailing zeroes
        ans = str(ans)                                                    // Converting integer to string
        i = len(ans) - 1                                                  // Start the pointer with end of string
        while i >= 0 and ans[i] == '0':                          // Decrement pointer by one while the value at pointer is 0
            count += 1                                                   //and increase the count of trailing zeroes
            i -= 1
        fans = ''                                                            //Empty string which will store the number without the trailing zeroes
        for j in range(i+1):                                            // will use the i pointer which stored the last location of the trailing zero
            fans += ans[j]                                              //store each character until the trailing zero isn't reached
        final = ''                                                           //Final ans which will give the required result 
        if len(fans) > 10:                                              //If the length of the number without the trailing zeroes has a length greater than 10
            temp1 = ''                                                   //Will store the first 5 character of the number
            for j in range(5):                                          // Adding the first 5 characters
                temp1 += fans[j]
            temp2 = ''                                                   //Will store the last 5 characters of the number
            for j in range(-5,0):                                      // Add the last 5 characters
                temp2 += fans[j]
            final = temp1 + '...' + temp2 + 'e' + str(count)           //Final ans with first 5 character, last 5 characters + e + count of trailing zeroes
        else:                                                                    //If length of the number is less than 10
            final = fans + 'e' + str(count)                         // Final ans with number without trailing zeroes + e + count of trailing zeroes
        return final                                                      //Return the final string",0
"class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        return num == 0 or num % 10",1
"class Solution:
    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:
        grid = [[0]*n for _ in range(n)]
        directions = {'R':(0,1),'L':(0,-1),'U':(-1,0),'D':(1,0)}
        l = len(s)
        ans = [0]*l
        temp = startPos.copy()
        for i in range(l):
            step = 0
            startPos = temp.copy()
            for j in range(i,l):
                d = directions[s[j]]
                new_start  = [startPos[0]+d[0],startPos[1]+d[1]]
                if 0<=new_start[0]<n and 0<=new_start[1]<n :
                    step += 1
                    startPos = new_start
                else:
                    break
            ans[i] = step
        
        return ans",0
"class Solution:
    def getDistances(self, arr: List[int]) -> List[int]:
        indices = defaultdict(list)
        prefsum = {}
        for i, a in enumerate(arr):
            indices[a].append(i)
            if a not in prefsum:
                prefsum[a] = [i]
            else:
                prefsum[a].append(i + prefsum[a][-1])
        res = []
        for i, a in enumerate(arr):
            idx = bisect_right(indices[a], i) - 1
            # count of smaller, count of larger
            sc, lc = idx, len(indices[a]) - idx - 1
            ss = prefsum[a][idx - 1] if idx > 0 else 0  # sum of smaller
            ls = prefsum[a][-1] - prefsum[a][idx]  # sum of larger
            res.append(i * sc - ss + ls - i * lc)
        return res",0
"class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        
        def check(k):
            cnt = defaultdict(int)
            ans = []
            for x in nums:
                if cnt[x - 2*k] > 0:
                    cnt[x - 2*k] -= 1
                    ans.append(x - k)
                else:
                    cnt[x] += 1
            if len(ans) == n // 2: return ans
            return []
                       
	    # maximum k should not exceed half of the array
        cand_k = sorted(set((nums[i] - nums[0]) // 2 for i in range(1, n // 2 + 1) if (nums[i] - nums[0]) % 2 == 0))
        for k in cand_k:
            if k == 0: continue
            ans = check(k)
            if ans: return ans",0
"class Solution:
    def checkString(self, s: str) -> bool:
        return ""ba"" not in s",1
"class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        prev, res = 0, 0
        for i in range(len(bank)):
            ones = bank[i].count(""1"")
            if ones == 0: continue  #we can ignore rows without any ""1""
            
            if prev > 0:  #if we have some 1's in prev row we multiply with current ones to get number of lasers
                res += prev * ones
            prev = ones  #storing curr 1's to find lasers from current to next row
            
        return res",0
"class Solution:
    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
      asteroids.sort()
      while asteroids:
        ind = bisect.bisect_right(asteroids, mass)
        if ind == len(asteroids): return True
        elif ind == 0: return False
        else:
          #it can collide with all asteroids before this index
          mass += sum(asteroids[:ind])
          asteroids = asteroids[ind:]",0
"class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        graph = [[] for _ in range(n)]
        for i, x in enumerate(favorite): graph[x].append(i)
        
        def bfs(x, seen): 
            """"""Return longest arm of x.""""""
            ans = 0 
            queue = deque([x])
            while queue: 
                for _ in range(len(queue)): 
                    u = queue.popleft()
                    for v in graph[u]: 
                        if v not in seen: 
                            seen.add(v)
                            queue.append(v)
                ans += 1
            return ans 
        
        ans = 0 
        seen = [False]*n
        for i, x in enumerate(favorite): 
            if favorite[x] == i and not seen[i]: 
                seen[i] = seen[x] = True 
                ans += bfs(i, {i, x}) + bfs(x, {i, x})
                
        dp = [0]*n
        for i, x in enumerate(favorite): 
            if dp[i] == 0: 
                ii, val = i, 0
                memo = {}
                while ii not in memo: 
                    if dp[ii]: 
                        cycle = dp[ii]
                        break
                    memo[ii] = val
                    val += 1
                    ii = favorite[ii]
                else: cycle = val - memo[ii]
                for k in memo: dp[k] = cycle
        return max(ans, max(dp))",0
"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li=title.split()
        ans=[]
        for i in range(0,len(li)):
            if len(li[i])==1 or len(li[i])==2:
                li[i]=li[i].lower()
            else:
                li[i]=li[i].capitalize()

        return "" "".join(li)",1
"class Solution:
    def _findMid(self, head):
        prev = None
        fast = slow = head
        while fast and fast.next:
            prev, slow, fast = slow, slow.next, fast.next.next
        if prev: prev.next = None
        return slow
    
    def _revList(self, head):
        prev = None
        while head:
            head.next, prev, head = prev, head, head.next
        return prev
            
    
    def pairSum(self, head: Optional[ListNode]) -> int:
        # Find 2nd middle node
        mid = self._findMid(head)
        #Reverse list from mid
        tail = self._revList(mid)
        mx = 0
        while head:
            mx = max(mx, head.val + tail.val)
            head, tail = head.next, tail.next
        return mx",0
"class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        
        palindromicPairsFinder = collections.Counter(); count = 0
        for word in words:
            reversedWord = word[::-1]
            if palindromicPairsFinder[reversedWord] > 0:
                count += 1
                palindromicPairsFinder[reversedWord] -= 1
            else:
                palindromicPairsFinder[word] += 1

        return 2 * (2 * count + any(word[0] == word[1] for word in palindromicPairsFinder if palindromicPairsFinder[word] > 0))",0
"class Solution:
    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        m, n = len(grid), len(grid[0])
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = grid[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
        
        seen = [[0]*n for _ in range(m)]
        for i in range(m-stampHeight+1): 
            for j in range(n-stampWidth+1): 
                diff = prefix[i+stampHeight][j+stampWidth] - prefix[i+stampHeight][j] - prefix[i][j+stampWidth] + prefix[i][j]
                if diff == 0: seen[i][j] = 1
                    
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): 
            for j in range(n): 
                prefix[i+1][j+1] = seen[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
                
        for i in range(m):
            ii = max(0, i-stampHeight+1)
            for j in range(n): 
                jj = max(0, j-stampWidth+1)
                if grid[i][j] == 0 and prefix[i+1][j+1] - prefix[i+1][jj] - prefix[ii][j+1] + prefix[ii][jj] == 0: return False 
        return True",0
"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        n=len(matrix)
        
        return all(len(set(row))==n for row in matrix) and all(len(set(col))==n for col in zip(*matrix))",1
"class Solution:
    def minSwaps(self, nums: List[int]) -> int:

        cntone = 0
        
		# First, compute how many 1s here
        for n in nums:
            if n == 1:
                cntone += 1
    
        l, res = 0, float('inf')
		
		# Doing this for circular array
        nums.extend(nums)
        
        need = {0:0, 1:0}
		
		# Start sliding window
        for r, val in enumerate(nums):
            need[val] += 1
             
			# our window should group all 1 together 
            if need[0] + need[1] == cntone:
                res = min(res, need[0])
                need[nums[l]] -= 1
                l += 1
                
        return res if res != float('inf') else 0",1
"class Solution:
    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        # turns word into binary string
        # i.e., 'ab' -> b11
        # 'ac' -> b101
        # 'ad' -> b1001
        # a-z -> b11111111111111111111111111
        def bin_word(word):
            num = 0
            for c in word:
                cn = ord(c) - ord('a')
                mask = 1 << cn
                num ^= mask
            return num
        
        # take out a letter from a binary string
        def bin_take_out(word, letter):
            cn = ord(letter) - ord('a')
            mask = 1 << cn
            return word ^ mask

        starts = set([bin_word(w) for w in startWords])
            
        count = 0
        for t in targetWords:
            t_b = bin_word(t)
            for c in t:
                # try taking out each letter in t
                # and see if the resulting binary
                # in starts
                if bin_take_out(t_b, c) in starts:
                    count += 1
                    break
        return count",0
"class Solution:
    def earliestFullBloom(self, plantTime, growTime):
        PLANT, GROW = 0,1
        #create array of (plant, grow) tuples
        times = list(zip(plantTime, growTime))

        #sort by grow time
        times.sort(key=lambda i:i[GROW], reverse=True)

        prev_plant = prev_bloom = 0
        for time in times:
            cur_bloom = time[PLANT]+time[GROW]

            #get the time of the last bloom
            prev_bloom = max(prev_bloom, prev_plant+cur_bloom)

            prev_plant += time[PLANT]

        return prev_bloom",1
"class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        
		# s = ""abcdefghij"", k = 3, fill = ""x""
		
        res = []
        for i in range(0, len(s), k):
            res.append(s[i:i+k])
            # print(res) ['abc', 'def', 'ghi', 'j']
            
            while len(res[-1]) < k:
                    res[-1] += fill
        return res",1
"class Solution:
    def minMoves(self, target: int, maxDoubles: int) -> int:
        step = 0
        while target != 1  :
            if target % 2 == 1:
                if maxDoubles == 0:
                    step += target -1
                    target = 1
                else:
                    target -= 1
                    step +=1
            else:
                if maxDoubles > 0:
                    target = target/ 2
                    step +=1
                    maxDoubles -=1
                else:
                    step +=1
                    target -=1
        return int(step)",0
"class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        
        # set dp array
        dp = [0]*n
        
        # start from last
        dp [-1] = questions[-1][0]
        
        # start setting the rest
        for i in reversed(range(n-1)):
            points, skip = questions[i]
            
            # dp formula
            if i + skip + 1 < n : dp[i] = max(dp[i+1], points + dp[i + skip + 1])
            else: dp [i] = max(points, dp[i+1])
    
        return dp[0]",1
"class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        l, h = min(batteries), sum(batteries)
        
        batteries.sort()
        cands = batteries[-n:]
        rest = sum(batteries[:-n])
        
        def bs(t):
            tmp = rest
            for x in cands:
			    # all rest batteries on computer can run more than t time
                if x >= t: return True
				# need t - x batteries to fill
                tmp -= t - x
				if tmp < 0: return False
            return True
            
        
        while l < h:
            mid = l + (h - l + 1) // 2
            if bs(mid):
                l = mid
            else:
                h = mid  - 1
        
        return l",1
"class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        res = sum(cost)
        i = 2
        while i < len(cost):
            res -= cost[i]
            i += 3 #skip every 2 elements to eliminate the max possible price
            
        return res",1
"class Solution:
    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int: 
        total_sequences = 0
        sequence = [lower] 
        
        for j in range(len(differences)):
            x = sequence[j] + differences[j]
            sequence.append(x)
        
        minn, maxx = min(sequence), max(sequence)
        
        if lower <= minn <= upper and lower <= maxx <= upper: total_sequences += 1
            
        for i in range(lower + 1, upper+1):
            minn = minn + 1
            maxx = maxx + 1
            
            if lower <= minn <= upper and lower <= maxx <= upper: total_sequences += 1
            
        return total_sequences",0
"class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        q = deque([tuple(start)])
        m, n = len(grid), len(grid[0])
        lower, upper = pricing[0], pricing[1]
        ranked_arr = []
        visited = {tuple(start)}
        adj = [(-1, 0), (0, -1), (0, 1), (1, 0)]
        while q:
            next_q = []
            for _ in range(len(q)):
                cur = q.popleft()
                x, y = cur
                if lower <= grid[x][y] <= upper:
                    ranked_arr.append(list(cur))
                
                for dx, dy in adj:
                    if ((x + dx, y + dy) in visited or
                        not (0 <= x + dx < m and 0 <= y + dy < n) or
                        grid[x + dx][y + dy] == 0
                    ):
                        continue
                    next_q.append((x + dx, y + dy))
                    visited.add((x + dx, y + dy))
            next_q.sort(key=lambda xy: xy[1])
            next_q.sort(key=lambda xy: xy[0])
            next_q.sort(key=lambda xy: grid[xy[0]][xy[1]])
            q = deque(next_q)
        return ranked_arr[:k]",0
"class Solution:
    def numberOfWays(self, corridor: str) -> int:
        n = len(corridor)
        if n==1:
            return 0
        d = defaultdict(int)
        numS = 0
        
        for i in range(n):
            if (numS==0 or numS%2==1) and corridor[i]=='P':
                continue
            if corridor[i]=='P':
                d[numS//2] += 1
            else:
                numS += 1

        if numS==0 or numS%2:
            return 0
        if corridor[-1]=='P':
            d[numS//2] = 0

        ret = 1
        for v in d.values():
            ret *= (v+1)
        return ret%(10**9+7)",0
"class Solution:
    def countElements(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        # sort the num
        nums.sort()
        i = 1
        j = len(nums)-2
        while i < len(nums) and nums[i] == nums[i-1]:
            i+=1
        while j >= 0 and nums[j] == nums[j+1]:
            j-=1
        return max(0,j-i+1)",1
"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        a=[0]*len(nums)
        p=0
        n=1
        for i in nums:
            if i<0:
                a[n]=i
                n+=2
            else:
                a[p]=i
                p+=2
        return a",1
"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        d = {}
        for num in nums:
            d[num] = d.get(num, 0) + 1
        
        ans = []
        for num in nums:
            if d[num] == 1 and (num-1) not in d and (num+1) not in d:
                ans.append(num)
        
        return ans",1
"class Solution:
    def maximumGood(self, s: List[List[int]]) -> int:
        """"""
        brute force: try if all N people are good, if not, try N-1 etc.
        """"""
        N = len(s)
        
        gooddict = defaultdict(set)
        baddict = defaultdict(set)
        
        for r in range(N):
            for c in range(N):
                if s[r][c]==1: 
                    gooddict[r].add(c)
                elif s[r][c] == 0:
                    baddict[r].add(c)
     
        def valid(good):
            bad = set(x for x in range(N) if x not in good)
            for g in good:
                for gg in gooddict[g]:
                    if gg not in good:
                        return False
                for gb in baddict[g]:
                    if gb not in bad:
                        return False
            return True
        
        for t in range(len(s),0,-1):
            choices = set(itertools.combinations(range(N), t))
            for c in choices:
                if valid(c):
                    return t
                
        return 0",0
"class Solution:
    def findFinalValue(self, nums: List[int], x: int) -> int:
        nums = set(nums)
        while True:
            if x in nums:
                x *= 2
            else:
                break
        return x",1
"class Solution:
    def maxScoreIndices(self, nums: List[int]) -> List[int]:
	
        t1 = [0]                                                              #Initialise array for prefix sum
        t2 = [0]*(len(nums)+1)                                      #Initialise array for suffix sum
		
		#Create preffix sum
        for i in nums:
            if not t1:
                t1.append(0)
            else:
                if i == 0:
                    t1.append(t1[-1]+1)
                else:
                    t1.append(t1[-1])
					
		#Create suffix sum
        for i in range(len(nums) - 1, -1, -1):
            t2[i] = nums[i]+t2[i+1]
        ans = []
		
		#Assign score to each index
        for i in range(len(t1)):
            ans.append((t1[i]+t2[i], i))
			
		#Sort in reverse order
        ans.sort(reverse = True)
		
		#Take the max score
        ans1 = ans[0][0]
        t = []
		
		#Check for indexes having the max score
        for i in ans:
            if i[0] == ans1:
                t.append(i[1])
        return t",1
"class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        sol = 0
        powr = 1
        
        for i in range(0, k, 1):
            sol += (ord(s[i]) - ord('a') + 1) * powr
            powr = powr * power
        if sol % modulo == hashValue: 
            return s[:k]
        
        powr = powr // power
        for i in range(1, len(s) - k + 1, 1):
            sol = ((sol - (ord(s[i - 1]) - ord('a') + 1)) // power) + ((ord(s[i + k - 1]) - ord('a') + 1) * powr)
            if (sol % modulo == hashValue):
                return s[i:i + k]
            
        return """"",0
"class Solution:
    def minimumSum(self, num: int) -> int:
        string = str(num)
        arr = [char for char in string]
        arr.sort()
        
        # two possible combination
        result1 = int(arr[0]+ arr[2]) + int(arr[1] + arr[3])
        result2 = int(arr[1]+ arr[2]) + int(arr[0] + arr[3])
        
        return min(result1, result2)",1
"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lessthan = []
        for i in nums:
            if i < pivot:
                lessthan.append(i)
        equal = []
        for i in nums:
            if i == pivot:
                equal.append(i)
        great = []
        for i in nums:
            if i > pivot:
                great.append(i)
        return lessthan + equal + great",1
"class Solution:
    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:   
        mins = targetSeconds // 60
        secs = targetSeconds % 60
        min_cost = math.inf
        
        if mins <= 99:
            cost1 = cost(mins, secs, startAt, moveCost, pushCost)
            min_cost = min(min_cost, cost1)
        if secs <= 39:
            cost2 = cost(mins - 1, secs + 60, startAt, moveCost, pushCost)
            min_cost = min(min_cost, cost2)
            
        return min_cost
        
def cost(mins, secs, startAt, moveCost, pushCost):
    cost = 0
    has_prev = False
    
    for digit in [mins // 10, mins % 10, secs // 10, secs % 10]:
        if has_prev or digit != 0:
            if digit != startAt:
                cost += moveCost
                startAt = digit
            cost += pushCost
            has_prev = True
    
    return cost",0
"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums)//3
        pq0 = [-x for x in nums[:n]]
        pq1 = nums[-n:]
        
        heapify(pq0)
        heapify(pq1)
        
        ans = -sum(pq0) - sum(pq1)
        prefix = [0]
        for i in range(n, 2*n): 
            prefix.append(prefix[-1])
            if nums[i] < -pq0[0]: 
                prefix[-1] += nums[i] + pq0[0]
                heapreplace(pq0, -nums[i])
        extra = prefix[-1]
        suffix = 0 
        for i in reversed(range(n, 2*n)): 
            if nums[i] > pq1[0]: 
                suffix += pq1[0] - nums[i]
                heapreplace(pq1, nums[i])
            extra = min(extra, prefix[i-n] + suffix)
        return ans + extra",0
"class Solution:
    def sortEvenOdd(self, nums: List[int]) -> List[int]:
        return reduce(add, zip_longest(sorted([nums[i] for i in range(0,len(nums),2)]), sorted([nums[i] for i in range(1,len(nums),2)])[::-1]))[:len(nums)]",0
"class Solution:
    def smallestNumber(self, num: int) -> int:
        if num//10==0:
            return num
        if num<0:
            sign=-1
        else:
            sign=1
        num=abs(num)    
        if sign==-1:
            s=sorted(str(num),reverse=True)
            return sign*int("""".join(s))
        else:
            s=sorted(str(num))
            zeros=s.count('0')
            if zeros!=0:
                s[0],s[zeros]=s[zeros],s[0]
            return sign*int("""".join(s))",1
"class Solution:
    def minimumTime(self, s: str) -> int:
        costL2R = [None]*len(s)
        cost = 0 if s[0]=='0' else 1
        costL2R[0]=cost
        for i in range(1,len(s)):
            if s[i]=='1':
                cost = min(cost+2,i+1)
            costL2R[i]=cost           
                
        costR2L = [None]*len(s)
        cost = 0 if s[-1]=='0' else 1
        costR2L[-1] = cost
        for i in range(len(s)-2,-1,-1):
            if s[i]=='1':
                cost = min(cost+2,len(s) - (i+1)+1)
            costR2L[i] = cost
        costR2L.append(0)
            
        minCost = len(s)
        for i in range(len(s)):
            minCost = min(minCost,costL2R[i]+costR2L[i+1])
        return minCost",0
"class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        count = 0
        while num1 > 0 and num2 > 0:
            if num1 >= num2:
                num1 -= num2
            else:
                num2 -= num1
            count += 1
        return count",1
"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        x,y={},{}
        for i in range(0,len(nums),2):         # count the occurence of number 
            x[nums[i]]=x.get(nums[i],0)+1
        for i in range(1,len(nums),2):          # count the occurence of number
            y[nums[i]]=y.get(nums[i],0)+1
        sum1=sum(x.values())                  # count the total occurence of number
        sum2=sum(y.values())                   # count the occurence of number
        l1=[(k,x[k]) for k in x.keys()]           # make list 
        l2=[(k,y[k]) for k in y.keys()]           # make list
        l1=sorted(l1,key=lambda x:x[1],reverse=True)     # sort in reverse order
        l2=sorted(l2,key=lambda x:x[1],reverse=True)
        for i in l1:
            for j in l2:
                if i[0]!=j[0]:        # check the given condition
                    return sum1-i[1]+sum2-j[1]      # convert list into nums[i-1] and nums[i]
        return min(sum1,sum2)     # return minimum occurance",0
"class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        #sort the array
        beans = sorted(beans)
        #create array for dynamic programming
        dp = [0] * len(beans)
        #prefix sum
        for i in range(len(beans)):
            dp[i] = dp[i-1] + beans[i]
        #find the minimum number looping through the dp array 
        res = (dp[-1] - dp[0]) - beans[0] * (len(beans) - 1)
        for i in range(1, len(beans)):
            res = min(res, (dp[-1] - dp[i]) - beans[i] * (len(beans) - i - 1) + dp[i-1] )
        return res",1
"class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        
        @lru_cache(None)
        def dp(i, m1, m2):
            if i == len(nums):
                return 0

            ans = float('-inf')
            for j in range(numSlots):
                if m1 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1 ^ (1 << j), m2))
                elif m2 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1, m2 ^ (1 << j)))
            return ans

        return dp(0, (1<<numSlots)-1, (1<<numSlots)-1)",0
"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count=0
        n=len(nums)
        for i in range(n):
            for j in range(i+1,n):
                if nums[i]==nums[j] and (i*j)%k==0:
                    count+=1
        
        return count",1
"class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        rightHandSide = num - 3
        if rightHandSide % 3 != 0:
            return []
        firstNumber = rightHandSide // 3
        
        return [firstNumber, firstNumber + 1, firstNumber + 2]",1
"class Solution:
    def maximumEvenSplit(self, f: int) -> List[int]:
        if f%2!=0:      # if odd then return 
            return []
        count= (-1 + sqrt(1 + 4 * f)) // 2        # find x
        ans=[]
        i=2
        while len(ans)!=count:
            ans.append(i)          # add even integers in list 
            i=i+2
        if sum(ans)==f:         # check if sum is euqal to finalSum
            return ans
        ans[-1]=ans[-1]+(f-sum(ans))     # else add difference in the last element
        return ans",1
"class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        N = len(nums1)
        BIT = [0] * (N+1)
        nums = [0] * N
        num1 = [0] * N
        num2 = [0] * N
        for i, n in enumerate(nums1):
            num1[n]=i
        for i, n in enumerate(nums2):
            num2[n]=i
        for i, n in enumerate(num1):
            nums[n] = num2[i]
        def lowbit(i):
            return i&amp;(-i)
        def add(i):
            i+=1
            while i <= N:
                BIT[i]+=1
                i+=lowbit(i)
        def query(i):
            i += 1
            re = 0
            while i:
                re += BIT[i]
                i -= lowbit(i)
            return re
        smaller = []
        bigger = []
        for i, n in enumerate(nums):
            smaller.append(query(n))
            bigger.append(N-1-i-n+smaller[-1])
            add(n)
        return sum(i*j for i, j in zip(smaller, bigger))
		```",0
"class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num + 1):
            summetion = 0
            for digit in str(i):
                summetion += int(digit)
                
            if summetion % 2 == 0 :
                count += 1
                
        return count",1
"class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        temp=head.next
        s=0
        
        newHead=dummy=ListNode(-1)
        
        while temp:
            if temp.val==0:
                newHead.next=ListNode(s)
                newHead=newHead.next
                s=0
            else:
                s+=temp.val
            
            temp=temp.next
            
        
        return dummy.next",1
"class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        # MaxHeap method
        arr = [0] * 26
        result = """"
        
        # count the num of each char
        for char in s:
            arr[ord(char) - ord('a')] += 1
        
        # in the maxHeap, the largest char is on the top
        maxHeap = []
        for i in range(26):
            if arr[i] != 0:
                maxHeap.append((-i, arr[i]))
        
        heapq.heapify(maxHeap)
        
        while maxHeap:
            # pop out the largest char
            largestChar, times = heapq.heappop(maxHeap)
            # to make sure we didn't add the same char in the next iteration
            if result and result[-1] == chr(-largestChar + ord('a')):
                return result                         
            if times > repeatLimit:
                result += repeatLimit * chr(-largestChar + ord('a'))
                if maxHeap:
                    SecondLargestChar, times2 = heapq.heappop(maxHeap)
                    result += chr(-SecondLargestChar + ord('a'))
                    if times2 > 1:
                        heapq.heappush(maxHeap, (SecondLargestChar, times2-1))
                heapq.heappush(maxHeap, (largestChar, times-repeatLimit))
            else:
                result += times * chr(-largestChar + ord('a'))
            
            if len(result) == len(s):
                return result",0
"class Solution:
    def coutPairs(self, nums: List[int], k: int) -> int:
        for i in range(len(nums)):
            g = gcd(nums[i], k)
            nums[i] = g if g != k else 0
        
        c = Counter(nums)
        r = 0
		
		# 0 to other number
        for i in c:
            if i == 0: continue
            r += c[i]
        r *= c[0]
		
		# 0 to 0
        r += (c[0] * (c[0]-1)) // 2
        
        del c[0]  # 0 is dealt with
        del c[1]  # 1 is useless
        
		# brute-force check for key pairs
        ckeys = list(c.keys())
        for a in range(len(ckeys)):
            i = ckeys[a]
            for b in range(a, len(ckeys)):
                j = ckeys[b]
                if (i * j) % k: continue
                if j != i:
                    r += c[i] * c[j]
                else:
                    r += (c[i] * (c[i]-1)) // 2
                
        return r",0
"class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        res = 0
        for i in words:
            if i.startswith(pref):
                res += 1
        return res",1
"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        count_s=Counter(s)
        count_t=Counter(t)
        count=0
        
        for i in count_t:
            if i not in count_s:
                count+=count_t[i]
                count_s[i]=count_t[i]
            elif count_t[i]>count_s[i]:
                count+=count_t[i]-count_s[i]
                count_s[i]+=count_t[i]-count_s[i]
                count_s[i]=count_t[i]
            elif count_t[i]<count_s[i]:
                count+=count_s[i]-count_t[i]
                count_t[i]+=count_s[i]-count_t[i]
                count_t[i]=count_s[i]
                
        for i in count_s:
            if i not in count_t:
                count+=count_s[i]
                count_t[i]=count_s[i]
            else:
                count+=abs(count_t[i]-count_s[i])
                count_t[i]=count_t[i]+abs(count_t[i]-count_s[i])
        return count",0
"class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        def condition(mid,nums,totalTrips):
            ans=0
            for num in nums:
                ans+=mid//num
            if ans>=totalTrips:
                return True
            return False
        
        lo=0 #minimum time any truck can take
        hi=totalTrips*min(time)  #maximum time any truck can take
        
        while lo<=hi:
            mid=lo+(hi-lo)//2
            if condition(mid, time,totalTrips):
                hi=mid-1
            else:
                lo=mid+1
        return lo",1
"class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        @cache
        def lapTime(tire,x):
            f,r = tire
            return f*(r**(x-1))
        
        best_laps = {}
        
        for tire in tires:
            tire = tuple(tire)
            time = 0
            # stop at max time for a tire without changing
            for i in range(1,1001):
                currtime = lapTime(tire,i)
                if currtime >= lapTime(tire,1)+changeTime:
                    break
                time += currtime
                
                # update dictionary
                if i in best_laps:
                    best_laps[i] = min(best_laps[i],time+changeTime)
                else:
                    best_laps[i] = time+changeTime
        
        # dynamic programming
        dp = [float('inf') for _ in range(numLaps)]
        for i in range(numLaps):
            # if could get lap i using a single tire
            if i+1 in best_laps:
                dp[i] = best_laps[i+1]
                
            # or get lap i changing from last tire
            for k,v in best_laps.items():
                if i-k>=0:
                    dp[i] = min(dp[i], dp[i-k]+v)
        
		# subtract change time because first tire doesn't need to change
        return dp[numLaps-1] - changeTime",0
"class Solution:
    def mostFrequent(self, nums: List[int], key: int) -> int:
        d={}
        for i in range(len(nums)-1):
            if nums[i]==key:
                if nums[i+1] in d:
                    d[nums[i+1]]+=1
                else:
                    d[nums[i+1]]=1
        m=-1
        for j in d:
            m=max(m,d[j])
        for key, value in d.items():
            if m == value:
                return key",1
"class Solution:
    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        def getMappedNum(num):
            s = str(num)
            mappedNum = """"
            for c in s:
                mappedNum = mappedNum + str(mapping[int(c)])
            return int(mappedNum)

        sortedNums = []
        for num in nums:
            sortedNums.append((getMappedNum(num), num))
            
        sortedNums.sort(key=lambda x: x[0])
        
        for i, (_, num) in enumerate(sortedNums):
            nums[i] = num
            
        return nums",1
"class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        
        result = []
        
        hashmap = collections.defaultdict(set)
        parent = collections.defaultdict(set)
        # indegree = collections.defaultdict(int)
        
        for a, b in edges:
            hashmap[a].add(b)
            parent[b].add(a)
            # indegree[b] += 1
        
        roots = set()
        leafs = set()
        
        for node in range(n):
            if node not in parent:
                roots.add(node)
            
            if node not in hashmap:
                leafs.add(node)
        
        # print(roots)
        # print(leafs)
        
        # ancestors = collections.defaultdict(set)
        
        @cache
        def find_parent(node):
            parents = set()
            if node in parent:
                for p in parent[node]:
                    parents.add(p)
                    parents |= find_parent(p)
            return parents
            
        
        for node in range(n):
            result.append(sorted(list(find_parent(node))))
        
        return result",1
"class Solution:
    @lru_cache(None)
    def minMovesToMakePalindrome(self, s: str) -> int:
        n = len(s)
        if n<=1:
            return 0
        if s[0] == s[-1]:
            return self.minMovesToMakePalindrome(s[1:-1])
        i = 1
        while s[i]!=s[-1]:
            i+=1
        j = n - 2
        while s[j]!=s[0]:
            j-=1
        if i <= n - 1 - j:
            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])
        else:
            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])",0
"class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        result = 0
        
        if nums[0] > k:
            return self.calSum(0, k+1)
        
        if nums[0] != 1:
            k -= (nums[0] - 1)
            result += self.calSum(0, nums[0])
        
        for i in range(n-1):
            numOfCandidates = nums[i+1] - nums[i] -1
            if numOfCandidates >= 1:
                if numOfCandidates >= k:
                    result += self.calSum(nums[i], nums[i] + k +1)
                    k = 0
                    return result

                elif numOfCandidates < k:
                    k -= numOfCandidates
                    result += self.calSum(nums[i], nums[i+1])
        
        if k > 0:
            result += self.calSum(nums[-1], nums[-1] +k+1)
        
        return result
                      
    # calculate the sum between start and end, both exclude
    def calSum(self, start, end):
        return int((end + start) / 2 * (end -start -1))",0
"class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        node_dict = defaultdict(TreeNode)
        ins = defaultdict(int)
        for p, c, isleft in descriptions:
            ins[p] = ins[p]
            ins[c] += 1
            node_dict.setdefault(p, TreeNode(p))
            node_dict.setdefault(c, TreeNode(c))
            if isleft:
                node_dict[p].left = node_dict[c]
            else:
                node_dict[p].right = node_dict[c]
        
        return node_dict[min((indegree, node) for node, indegree in ins.items())[1]]",0
"class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        if len(nums) == 1: return nums
        
        @cache
        def compute_gcd(x, y) -> int:
            while y:
                x, y = y, x % y
            return x

        @cache
        def compute_lcm(x, y) -> int:
            r = (x*y)//compute_gcd(x,y)
            return r
    
        i, j = 0, 1
        while j < len(nums):
            if compute_gcd(min(nums[i],nums[j]), max(nums[i],nums[j])) != 1:
                nums[i]=compute_lcm(min(nums[i],nums[j]), max(nums[i],nums[j]))
                nums.pop(j)
                if i != 0:
                    i-=1
                    j-=1
            else:
                i+=1
                j+=1
        return nums",0
"class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        # Time: O(nk) which at the worst case could be O(n^2)
        # Space: O(n) because result will never exceed N values
		res = set()
        for index, num in enumerate(nums):
            if num == key:
                for i in range(max(0, index - k), min(len(nums), index + k + 1)):
                    res.add(i)
        return list(res)",0
"class Solution:
    def digArtifacts(self, n: int, artifact: List[List[int]], dig: List[List[int]]) -> int:
        dig_set = set()
        for i in dig:
            dig_set.add(tuple(i))
            
        count = 0
        for afact in artifact:
            flag = True
            r1,c1,r2,c2 = afact
            for i in range(r1,r2+1):
                for j in range(c1,c2+1):
                    if (i,j) not in dig_set:
                        flag = False
                        break
                        
            if(flag == True):
                count += 1
                
        return count",0
"class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        if len(nums) <= 1 and k &amp; 1: return -1       # Case 1: triggered
        end = min(k-1, len(nums))                    # If k is greater than len(nums), end = len(nums), because Case 2 is triggered, else case 3 is triggered, we still need to find max till k-1
        maxi = max(nums[:end]) if k > 1 else 0       # we calculated the max element based on our end. k > 1 I have given to save from error, beacuse if k <= 1, spliced list will be empty.
        kplusOne = nums[k % len(nums)]               # this is for case 3, finding the k + 1 element, k +1 can give array index out of bound exception, so i did %
        return max(maxi, kplusOne)                   # Case 3, we have to decide either we choose to put the max from removed or (k+1) element",0
"class Solution:
  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
    graph,regra = defaultdict(list),defaultdict(list)
    for x,y,d in edges:
      graph[x].append((y,d))
      regra[y].append((x,d))
    for x in graph.keys():
      graph[x].sort(key=lambda p: p[1])
    for x in regra.keys():
      regra[x].sort(key=lambda p: p[1])
    pathfromdest = [float('inf') for _ in range(n)]
    psrcjeden = [float('inf') for _ in range(n)]
    psrcdwa = [float('inf') for _ in range(n)]
    ##
    def expdes(nod,d):
      if d < pathfromdest[nod]:
        pathfromdest[nod] = d
        for som,da in regra[nod]:
          expdes(som,d+da)
          
    
          
    def expsje(nod,d):
      if d < psrcjeden[nod]:
        psrcjeden[nod] = d
        for som,da in graph[nod]:
          expsje(som,d+da)
          
    def expesdwa(nod,d):
      if d < psrcdwa[nod]:
        psrcdwa[nod] = d
        for som,da in graph[nod]:
          expesdwa(som,d+da)
        
    
    expdes(dest,0)
    if pathfromdest[src1] == float('inf') or pathfromdest[src2] == float('inf'): return -1
    expsje(src1,0)
    expesdwa(src2,0)
    ##
    # q = [dest]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in regra[m]:
    #     if pathfromdest[m] + d < pathfromdest[som]:
    #       pathfromdest[som] = pathfromdest[m] + d
    #       q.append(som)
    # ##
    # q = [src1]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in graph[m]:
    #     if psrcjeden[m] + d < psrcjeden[som]:
    #       psrcjeden[som] = psrcjeden[m] + d
    #       q.append(som)
    # ##
    # q = [src2]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in graph[m]:
    #     if psrcdwa[m] + d < psrcdwa[som]:
    #       psrcdwa[som] = psrcdwa[m] + d
    #       q.append(som)
    ##
    ans = min(pathfromdest[ii]+psrcjeden[ii]+psrcdwa[ii] for ii in range(n))
    if ans == float('inf'): return -1
    else: return ans",0
"class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        return not any(v % 2 for v in Counter(nums).values())",0
"class Solution:
    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
        a, b = pattern[0], pattern[1]
        counter = Counter(text)
        def num_subseq():
            rc = Counter(text) # counter for text[i:]
            ans = 0
            for c in text:
                rc[c] -= 1
                if c == a:
                    ans += rc[b]
            return ans

        return num_subseq() + max(counter[a], counter[b])",1
"class Solution:
def halveArray(self, nums: List[int]) -> int:
    import heapq
    target = sum(nums) / 2
    arr = [-i for i in nums]
    heapq.heapify(arr)
    res = 0
    
    while target > 0: # everything will be negative over here, so we will add the halved value
        n = heapq.heappop(arr) / 2
        target += n
        res += 1
        heapq.heappush(arr,n)
    return res",1
"class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        
        # get all locations for white
        loc = [i for i in range(len(floor)) if floor[i] == '1']
        if not loc: return 0        
        
        
        @lru_cache(None)
        # calculate maximum white tiles covered
        def dp(i, numCarpets):
            # if no carpets or reached the end of loc
            if numCarpets == 0 or i >= len(loc):
                return 0

            # if remaining caprets could cover till the end of loc
            if loc[i] + numCarpets * carpetLen - 1 >= loc[-1]:
                return len(loc) - i
            
            ans = -float('inf')
            # maximum carpets required to reach the next loc
            required = math.ceil((loc[i+1] - loc[i]) / carpetLen)
            
            
            for k in range(min(required, numCarpets)+1):
                new_i = bisect.bisect(loc, loc[i] + k*carpetLen - 1)
                ans = max(ans, new_i - i + dp(max(i+1, new_i), numCarpets - k))
            return ans

        return len(loc) - dp(0, numCarpets)",0
"class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        count, new = 0, [nums[0]]
        
        # Create a new array with non-consecutive values
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                new.append(nums[i])

        for i in range(1, len(new)-1):
            count += 1 if (new[i-1] < new[i] > new[i+1] or new[i-1] > new[i] < new[i+1]) else 0

        return count",1
"class Solution:
    def countCollisions(self, directions: str) -> int:
        count = 0
        stack = []
        
        for char in directions:
			# if the stack is empty, and the direction is left, we just continue
            if not stack and char == 'L':
                continue
            # otherwise we add the direction in the stack ('S' or 'R') because they might lead to collisions
            elif not stack and char != 'L':
                stack.append(char)
			# stack is not empty
            else:
				# the top element in the stack
                cur = stack[-1]
				# cases that will not lead to collisions
                if char == cur or cur == 'S' and char == 'R' or cur == 'L' and char == 'S' or cur == 'L' and char == 'R':
                    stack.append(char)
				# collision happen but the top of the stack is already 'S' no need to append
                elif cur == 'S' and char == 'L':
                    count += 1
				# collision happen, append a 'S' at the top
                elif cur == 'R' and char == 'S':
                    count += 1
                    stack.pop()
                    stack.append('S')
				# collision happen, append a 'S' at the top
                elif cur == 'R' and char == 'L':
                    count += 2
                    stack.pop()
                    stack.append('S')
        # here, the stack only contains 'R' and 'S'
		# we only need to deal with the 'R' before 'S' case
        n = len(stack)
        i = 0  
        while i < n:
            rs = 1
            if stack[i] == 'S':
                i += 1
            elif stack[i] == 'R':
                if i == n-1:
                    return count                
                elif stack[i] != stack[i+1]:
                    count += 1
                    i += 1     
                else:   
                    while i < n-1 and stack[i] == 'R' and stack[i] == stack[i+1]:
                        rs += 1
                        i += 1
                    if i == n-1:
                        return count
                    else:
                        count += rs
                        i += 1
        return count",0
"class Solution:
    def __init__(self):
        self.mem = {}  # {(scoring_section,remaining_arrow_count)} = mask
    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        (mask,score) = self.dp(numArrows,0,len(aliceArrows)-1,0,aliceArrows)
        # print(""mask:"",mask)
        r = []
        zeroTarget = numArrows
        for i in range(1,len(aliceArrows)):
            if mask &amp; 1<<i :
                zeroTarget -= aliceArrows[i]+1
                r.append(aliceArrows[i]+1)
            else :
                r.append(0)
        r = [zeroTarget] + r
        return r
    def dp(self,numArrows: int, mask , scoring_section  , score ,aliceArrows: List[int]) -> (int,int):
        if numArrows <= 0 :
            return (mask,score)
        if scoring_section <= 0:
            return (mask,score)
        if (scoring_section,numArrows) in self.mem:
            return self.mem[(scoring_section,numArrows)]
        
        score1 = 0
        if numArrows- (aliceArrows[scoring_section]+1) >= 0:
            mask1,score1 = self.dp(numArrows- (aliceArrows[scoring_section]+1) , mask , scoring_section-1 , score , aliceArrows[:-1])
            mask1 |= 1<<scoring_section
            score1 += scoring_section
        else :
            mask1 = mask
        mask2,score2 = self.dp(numArrows , mask , scoring_section-1 , score , aliceArrows[:-1])
        
        if score1 >= score2 :
            self.mem[(scoring_section,numArrows)] = (mask1,score1)
        else :
            self.mem[(scoring_section,numArrows)] = (mask2,score2)

        return self.mem[(scoring_section,numArrows)]",0
"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        nums1, nums2 = list(set(nums1)), list(set(nums2)) # Converting to set to ensure only unique values remain
        
        new1, new2 = [], [] # New list we'll be adding to
        
        for x in nums1: # Compares first list
            if x not in nums2:
                new1.append(x)
        
        for y in nums2: # Compares second list
            if y not in nums1:
                new2.append(y)
        
        return [new1, new2] # Combines the two",1
"class Solution:
    def minDeletion(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):
		    # if res % 2 == 0, check even indexes
			# if res % 2 == 1, check odd indexes
            if (i + (res % 2)) % 2 == 0 and i + 1 < len(nums) and nums[i] == nums[i + 1]:
                res += 1
        return res + (len(nums) - res) % 2",0
"class Solution:
    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
        def nthPalindrome(n, k):
            half_len = k // 2 - 1 if k % 2 == 0 else k // 2  
            left = str(10 ** half_len + n - 1)
            right = (left if k % 2 == 0 else left[:-1])[::-1]
            res_str = left + right
            return int(res_str) if len(res_str) == intLength else -1
        return [nthPalindrome(query,intLength) for query in queries]",0
"class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        # sort by the maximum prefix sum
        p = sorted([list(accumulate(x[:k], initial=0)) for x in piles], key=lambda x: -x[-1])
        
        @lru_cache(None)
        def dp(i, k):
            if i == len(p):
                return 0
            ans = 0
            for j in range(min(len(p[i]), k+1)):
                ans = max(ans, p[i][j] + dp(i+1, k-j))
            return ans

        return dp(0, k)",0
"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        bstart=bin(start).replace(""0b"","""")
        bgoal=bin(goal).replace(""0b"","""")
      
        diff=len(str(bstart))-len(str(bgoal))
        for i in range(abs(diff)):
            if diff<0:
                bstart='0'+bstart
            elif diff>0:
                bgoal='0'+bgoal
        
        counter=0
        for i in range(len(bstart)):
            if bstart[i]!=bgoal[i]:
                counter+=1
        
        return counter",1
"class Solution:
    def triangular_sum(self, nums: List[int]) -> int:
        nums1 = nums
        while len(nums1) > 1:
            nums2 = []
            for i in range(len(nums1) - 1):
                nums2 += [(nums1[i] + nums1[i + 1]) % 10]
            nums1 = nums2
        return nums1[0]",1
"class Solution:
    def numberOfWays(self, s: str) -> int:
        def find_subsequence_count(S, T):
            m = len(T)
            n = len(S)
            if m > n:
                return 0
            mat = [[0 for _ in range(n + 1)]
                   for __ in range(m + 1)]
            for i in range(1, m + 1):
                mat[i][0] = 0
            for j in range(n + 1):
                mat[0][j] = 1
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    if T[i - 1] != S[j - 1]:
                        mat[i][j] = mat[i][j - 1]
                    else:
                        mat[i][j] = (mat[i][j - 1] +
                                     mat[i - 1][j - 1])
            return mat[m][n]
        x = find_subsequence_count(s, '101')
        y = find_subsequence_count(s, '010')
        return x + y",0
"class Solution:
    def sumScores(self, s: str) -> int:
        n, l, r = len(s), 0, 0
        z = [0] * n
        for i in range(1, n):
            if i <= r:
                z[i] = min(r - i + 1, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] - 1 > r:
                l, r = i, i + z[i] - 1
        return sum(z)+len(s)",0
"class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        count = 0
        
        hour_start = int(current.split("":"")[0])
        hour_end = int(correct.split("":"")[0])
        minute_start = int(current.split("":"")[1])
        minute_end = int(correct.split("":"")[1])
    
        total_start = hour_start * 60 + minute_start
        total_end = hour_end * 60 + minute_end 
        print(total_start,total_end)
        
        while total_start < total_end:
            if abs(total_start - total_end) >= 60 :
                total_start += 60
            elif abs(total_start - total_end) >= 15:
                total_start += 15
            elif abs(total_start - total_end) >= 5 :
                total_start += 5
            elif abs(total_start - total_end) >= 1 :
                total_start += 1
            count += 1
            
        return count",0
"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        lose_dict = defaultdict(list)
        players = set()
        answer = [[],[]]
        
        for winner, loser in matches:
            lose_dict[loser].append(winner)
            players.add(winner)
            players.add(loser)
        
        # find the list of all players that have not lost any matches
        for player in players:
            if player not in lose_dict:
                answer[0].append(player)
        
        # answer[1] is a list of all players that have lost exactly one match
        for player in lose_dict.keys():
            if len(lose_dict[player]) == 1:
                answer[1].append(player)
        
        answer[0].sort()
        answer[1].sort()
        
        return answer",1
"class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if sum(candies) < k:
            return 0
        
        hi = sum(candies) // k                  
        lo = 1                                  # Because sum(candies) >= k, kids can gain at least 1 candy
        
        def can_allo(candies, num, k):          # To determine whether candies can be allocate to at least k piles when pile == num
            count = 0
            for c in candies:
                count += c // num
            return count >= k
        
        while hi > lo:                          # binary search until hi == lo
            mid = (hi + lo) // 2
            if can_allo(candies, mid, k):
                lo = mid + 1
            else:
                hi = mid
        
        if can_allo(candies, hi, k):            # if hi can be allocated: just return hi
            return hi
        else:
            return hi - 1                       # else: it must be hi - 1",0
"class Solution:
    def largestInteger(self, num: int) -> int:
        arr = [n for n in str(num)]
        n = len(arr)
        
        for i in range(n):
            for j in range(i+1, n):
                if int(arr[i]) % 2 == 0 and int(arr[j]) % 2 == 0 and int(arr[j]) > int(arr[i]):
                    arr[i], arr[j] = arr[j], arr[i]
                
                elif int(arr[i]) % 2 == 1 and int(arr[j]) % 2 == 1 and int(arr[j]) > int(arr[i]):
                    arr[i], arr[j] = arr[j], arr[i]
        
        return int("""".join(arr))",0
"class Solution:
    def minimizeResult(self, expression: str) -> str:
        int1, int2 = expression.split('+')
        arr1, tmp1 = [char for char in int1], [char for char in int1]
        arr2, tmp2 = [char for char in int2], [char for char in int2]
        min_res = int(int1) + int(int2)
        res = '(' + expression + ')'
        first_limit = len(int1)
        sec_limit = len(int2)

        for i in range(0, first_limit):
            for j in range(1, sec_limit + 1):
                if i == 0 and j != sec_limit:
                    cur_res = (int(int1[i:]) + int(int2[:j])) * int(int2[j:])
                elif i != 0 and j == sec_limit:
                    cur_res = int(int1[:i]) * (int(int1[i:]) + int(int2[:j]))
                elif i == 0 and j == sec_limit:
                    continue
                else:
                    cur_res = int(int1[:i]) * (int(int1[i:]) + int(int2[:j])) * int(int2[j:])
                    
                if cur_res < min_res:
                    min_res = cur_res
                    arr1.insert(i, '(')
                    arr2.insert(j, ')')
                    res = """".join(arr1) + '+' + """".join(arr2)
                    arr1 = tmp1[:]
                    arr2 = tmp2[:]
        
        return res",0
"class Solution:
    def maximumProduct(self, nums: List[int], k: int) -> int:
        count=Counter(nums) # Get the frequencies of each element
        a=min(count.keys()) # Start with minimum key
        m=1000000007
        p=1 # To store the answer
        while k:
            c=count[a]
            if c<=k:
                count[a]-=c # Reduce it by the number of times the smallest element is encountered
                count[a+1]+=c # Inrease the count by the same magnitude 
                if count[a]==0: # Check if current numbers count reduces to zero
                    a+=1 # If yes then move onto next minimum number
                k-=c # reduce k
                continue
            if c>k: # if count of the smallest element is greater than the number of operations k then
                count[a]-=k # reduce the count of the smallest number by k 
                count[a+1]+=k # increase the count of smallest_num+1 by k
                k=0 # and reduce k to zero
        for key, val in count.items():
            if val: # if val of keys is greater than 0 then use them in result
                p=p*(key**val)%m #Use modulus to reduce the run time
        return p",0
"class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        totf = 0
        for i,f in enumerate(flowers):
            if f>target:
                flowers[i] = target
            totf += min(f,target)
        flowers.sort(reverse=True)
		
		# if newFlowers can make all garden 'full'
        n = len(flowers)
        if n*target - totf<=newFlowers:
            maxscore = n*full # score if all garden 'full'
            if flowers[-1]<target: # score if all garden but one 'full'
                maxscore = max(maxscore,(n-1)*full+(target-1)*partial) 
            return maxscore
        
		# if newFlowers can not make all garden 'full'
        tofill = 0 # no garden full, n gardens to fill
        level = (totf+newFlowers) // (n-tofill) # try fill all n garden
        while level<flowers[tofill]: # not plausible
            totf -= flowers[tofill] # exclude the next garden
            tofill += 1
            level = (totf+newFlowers) // (n-tofill) # try again
        maxscore = level*partial # score if no garden 'full'
        for i in range(len(flowers)): # (i+1) 'garden full'
            newFlowers -= target - flowers[i] 
            if newFlowers<0: # cannot fill any more garden
                break
            score = (i+1)*full # score from (i+1) 'full' garden
            if tofill==i:
                totf -= flowers[i]
                tofill = i+1
            level = (totf+newFlowers) // (n-tofill) # try fill the rest of the gardens
            while level<flowers[tofill]: # not plausible
                totf -= flowers[tofill] # exclude the next garden
                tofill += 1
                level = (totf+newFlowers) // (n-tofill)
            score = score + level * partial # score from partial gardens
            if score>maxscore:
                maxscore = score
        return maxscore",0
"class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2",1
"class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return (root.left.val + root.right.val) == root.val
          

# time O(1)
# space O(1)",1
"class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        result = nums[0]
        for n in nums:
            if abs(n) < abs(result):
                result = n
            elif n == -result  and n > 0:
                result = n

        return result",1
"class Solution:
    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
        p = total // cost1
        ways = 0
        
        for i in range(p + 1):
            t = total - i * cost1
            ways += (t // cost2) + 1
           
        return ways",1
"class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
      
      connection = {}
      
      for source, target in edges:
        if source not in connection: connection[source] = [target]
        else: connection[source].append(target)
          
        if target not in connection: connection[target] = [source]
        else: connection[target].append(source)
          
      res = -1
      
      max_dict = {}
      for key, value in connection.items():
        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize
        n1, n2, n3 = None, None, None
        for element in value:
          if scores[element] > max1:
            max1, max2, max3 = scores[element], max1, max2
            n1, n2, n3 = element, n1, n2
          elif scores[element] > max2:
            max2, max3 = scores[element], max2
            n2, n3 = element, n2
          elif scores[element] > max3:
            max3 = scores[element]
            n3 = element
        max_dict[key] = []
        if n1 != None: max_dict[key].append(n1)
        if n2 != None: max_dict[key].append(n2)
        if n3 != None: max_dict[key].append(n3)
             
      for source, target in edges:
        base = scores[source] + scores[target]
        
        n_s = max_dict[source]
        n_t = max_dict[target]
        if len(n_s) == 1 or len(n_t) == 1:
          pass
        else:
          new_n_s = [x for x in n_s if x != target]
          new_n_t = [x for x in n_t if x != source]
          if new_n_s[0] != new_n_t[0]:
            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])
          else:
            if len(new_n_s) > 1:
              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])
            if len(new_n_t) > 1:
              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      
    
      return res",0
"class Solution(object):
    def digitSum(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: str
        """"""
        while len(s)>k:
            t = """"
            x = 0
            a = 0
            for i in range(len(s)):
                if x==k:
                    x = 1
                    t+=str(a)
                    a = int(s[i])
                else:
                    x+=1
                    a+=int(s[i])
            t+=str(a)
            print(t)
            s = t
        return s",1
"lass Solution(object):
    def minimumRounds(self, tasks):
        """"""
        :type tasks: List[int]
        :rtype: int
        """"""
        d = {}
        for i in tasks:
            if i not in d:
                d[i] = 1
            else:
                d[i]+=1
        ans = 0
        for i in d:
            if d[i]<2:
                return -1
            else:
                if d[i]%3==0:
                    ans+=d[i]//3 
                else:
                    ans += d[i]//3 +1
        return ans",1
"class Solution:
    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        def check(grid, row_order=1, col_order=1):
            above = [[0, 0] for i in range(len(grid[0]))]
            ans = 0
            for row in grid[::row_order]:
                this_row = [0, 0]
                for i, v in enumerate(row[::col_order]):
                    c2 = c5 = 0
                    while v % 2 == 0:
                        c2 += 1
                        v /= 2
                    while v % 5 == 0:
                        c5 += 1
                        v /= 5
                    this_row[0] += c2
                    this_row[1] += c5
                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))
                    above[i][0] += c2
                    above[i][1] += c5
            return ans
        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])",0
"class Solution(object):
    def longestPath(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: int
        """"""
        self.child = {i:[] for i in range(len(parent))}
        for i in range(1,len(parent)):
            self.child[parent[i]].append(i)
        self.m = 0 
        def ser(i,p):
            if len(self.child[i])==0:
                if p==s[i]:
                    return 0 
                self.m = max(self.m,1)
                return 1
            a = []
            for j in self.child[i]:
                a.append(ser(j,s[i]))
            a.sort()
            x = a[-1]
            y = 0  
            if len(a)>1:
                y = a[-2]
            self.m = max(self.m,x+y+1)
            if s[i]==p:
                return 0 
            return x+1 
        ser(0,"""")
        return self.m",0
"class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        return sorted(reduce(lambda x,y: set(x)&amp;set(y), nums))",0
"class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        result = set()
        
        for circle in circles:
            x, y, r = circle
            for i in range(x - r, x + r + 1):
                for j in range(y - r, y + r + 1):
                    if (i - x) * (i - x) + (j - y) * (j - y) <= r * r:
                        result.add((i, j))
                        
        return len(result)",1
"class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
      
      rectangles.sort(key = lambda x : x[0])
      
      for i in range(len(points)):
        points[i] += [i]

      points.sort(key = lambda x : x[0])
      
      data_x = [x[0] for x in rectangles]
      data_y = []
      prev_ind = len(rectangles)
      
      res = [0]*len(points)
      
      for i in range(len(points)-1, -1, -1):
        q_x, q_y, loc = points[i]
        ind = bisect.bisect_left(data_x, q_x)
        for t in range(ind, prev_ind):
          bisect.insort(data_y, rectangles[t][1])
        prev_ind = ind
        res[loc] = len(data_y) - bisect.bisect_left(data_y, q_y)
      
      return res",0
"class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        fakePerson = [[x, 0, i] for i, x in enumerate(persons)]
        flow = []
        for start, end in flowers:
            flow.append([start, -float('inf')])
            flow.append([end, float('inf')])
        flow += fakePerson
        flow.sort()
        cur = 0
        n = len(persons)
        res = [0] * n
        for item in flow:
            if len(item) == 2:
                if item[1] == -float('inf'):
                    cur += 1
                else:
                    cur -= 1
            else:
                _, _, idx = item
                res[idx] = cur
        return res
		```",0
"class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        return sum(1 for word in words if s.startswith(word))",0
"class Solution:
    def minimumAverageDifference(self, nums: List[int]) -> int:
      total_sum = sum(nums)
      start = 0
      prefix_sum = []
      for element in nums:
        start += element
        prefix_sum.append(start)
      mini = sys.maxsize
      res = None
      size_t = len(nums)
      for i in range(len(nums)-1):
        diff = abs(floor(prefix_sum[i]/(i+1)) - floor((total_sum - prefix_sum[i])/(size_t - i - 1)))
        if diff < mini:
          mini = diff
          res = i
      last_diff = abs(floor(total_sum/size_t))
      if last_diff < mini: mini = last_diff; res = size_t - 1
      return res",1
"class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
      grid = [[0]*n for _ in range(m)]
      for x, y in guards:
        grid[x][y] = 'G'
      for x, y in walls:
        grid[x][y] = 'W'
        
      grid2 = [[0]*n for _ in range(m)]
      for x, y in guards:
        grid2[x][y] = 'G'
      for x, y in walls:
        grid2[x][y] = 'W'
        
      for i in range(m):
        cache = []
        has_G = False
        for j in range(n):
          if grid[i][j] == 0:
            cache.append(j)
          elif grid[i][j] == 'G':
            if cache:
              for k in cache:
                grid[i][k] = 'O'
              cache = []
            has_G = True
          else:
            if has_G:
              if cache:
                for k in cache:
                  grid[i][k] = 'O'
                  cache = []
              has_G = False
            else:
              cache = []
        if cache:
          if has_G:
            for k in cache:
                grid[i][k] = 'O'
      
      for j in range(n):
        cache = []
        has_G = False
        for i in range(m):
          if grid2[i][j] == 0:
            cache.append(i)
          elif grid2[i][j] == 'G':
            if cache:
              for k in cache:
                grid2[k][j] = 'O'
              cache = []
            has_G = True
          else:
            if has_G:
              if cache:
                for k in cache:
                  grid2[k][j] = 'O'
                  cache = []
              has_G = False
            else:
              cache = []
        if cache:
          if has_G:
            for k in cache:
                grid2[k][j] = 'O'
      
      res = 0
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 0 and grid2[i][j] == 0: res += 1
      return res",0
"class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        lo = 0
        hi = 1000000000
        fire = [[float('inf')] * C for _ in range(R)]
        q = deque()
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 1:
                    fire[r][c] = 0
                    q.appendleft((r, c))
        step = 0
        while q:
            nq = deque()
            while q:
                r, c = q.pop() 
                for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < R and 0 <= cc < C and grid[rr][cc] == 0 and fire[rr][cc] == float('inf'):
                        nq.appendleft((rr, cc))
                        fire[rr][cc] = min(fire[rr][cc], step + 1)
            step += 1
            q = nq
        def check(mid):
            q = deque([(0, 0)])
            v = {(0, 0): mid} 
            while q:
                r, c = q.pop()
                step = v[r, c] 
                if r == R - 1 and c == C - 1:
                    return True
                for dr, dc in  [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    rr, cc = dr + r, c + dc
                    if 0 <= rr < R and 0 <= cc < C and grid[rr][cc] == 0 and (rr, cc) not in v and \
                        (step + 1 < fire[rr][cc] or (rr, cc) == (R - 1, C - 1) and step + 1 <= fire[rr][cc] ):
                        q.appendleft((rr, cc))
                        v[rr, cc] = step + 1
            return False
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if check(mid):
                lo = mid
            else:
                hi = mid - 1
        if check(lo):
            return lo 
        return -1",0
"class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        res_nums = set()
        pos = 0
        for i in range(number.count(digit)):
            ind = number.index(digit, pos, len(number))
            res = number[:ind] + number[ind+1:]
            if int(res) not in res_nums:
                res_nums.add(int(res))
            pos = ind + 1
        return str(max(res_nums))",1
"class Solution:
    def minimumCardPickup(self, cards: List[int]) -> int:
        dic = defaultdict(int)
        min_num = float('inf')
        
        for i, num in enumerate(cards):
            if num not in dic:
                dic[num] = i
            else:
                min_num = min(min_num, i - dic[num] + 1)
                dic[num] = i
        
        if min_num == float('inf'):
            return -1
        else:
            return min_num",1
"class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        result = set()
        N = len(nums)
        K = k
        for i in range(N):
            k = K
            for j in range(i,N):
                if k>0:
                    if nums[j] % p == 0:
                        k -= 1
                    s = str(nums[i:j+1])
                    if s not in result:
                        result.add(s)
                elif nums[j] % p != 0:
                    s = str(nums[i:j+1])
                    if s not in result:
                        result.add(s)
                else: 
                    break
        return len(result)",0
"class Solution:
    def appealSum(self, s: str) -> int:
        seen_char_at_idx = defaultdict(int)
        total_appeal = 0
        prev_round_added = 0
        for idx in range(len(s)):
            appeal_supposed_to_add = idx + 1
            this_round_adding = prev_round_added + appeal_supposed_to_add
            if s[idx] in seen_char_at_idx:
                this_round_adding -= seen_char_at_idx[s[idx]] + 1
            
            total_appeal += this_round_adding
            prev_round_added = this_round_adding
            seen_char_at_idx[s[idx]] = idx # refreshing last seen index
        return total_appeal",1
"class Solution:
  def largestGoodInteger(self, num: str) -> str:
    letter = """"
    
    i = 0
    while i != len(num) :
      j = i + 1
      while j != len(num) and num[i] == num[j]: j += 1
      if j - i > 2 and letter < num[i]        : letter = num[i]
      
      i = j
    
    return letter * 3",1
"class Solution:
    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        res = 0
        def averageOfSubtreeInner(node):
            nonlocal res
            if not node:
                return (0, 0)
            
            l_cnt, l_sum = averageOfSubtreeInner(node.left)
            r_cnt, r_sum = averageOfSubtreeInner(node.right)
            
            tot_sum = l_sum + r_sum + node.val
            tot_cnt = 1 + l_cnt + r_cnt
            avg = tot_sum//tot_cnt
            if avg == node.val:
                res+=1
            return (tot_cnt, tot_sum)
            
        averageOfSubtreeInner(root)
        return res",1
"class Solution:
    def countTexts(self, pressedKeys: str) -> int:
      res = 0
      
      grid = [0]*(len(pressedKeys)+1)
      
      grid[0] = 1
      
      set1 = {'2', '3', '4', '5', '6', '8'}
      
      for t in range(1,len(grid)):
        target = pressedKeys[t-1]
        res = grid[t-1]
        if target in set1:
          if t >= 2 and pressedKeys[t-2] == target:
            res += grid[t-2]
          if t >= 3 and pressedKeys[t-2] == target and pressedKeys[t-3] == target:
            res += grid[t-3]
        else:
          if t >= 2 and pressedKeys[t-2] ==  target:
            res += grid[t-2]
          if t >= 3 and pressedKeys[t-2] == target and pressedKeys[t-3] == target:
            res += grid[t-3]
          if t >= 4 and pressedKeys[t-2] == target and pressedKeys[t-3] == target and pressedKeys[t-4] == target:
            res += grid[t-4]
            
        grid[t] = res % (10**9 + 7)
      return grid[-1] % (10**9 + 7)",0
"class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
      m, n = len(grid), len(grid[0])
      
      if grid[0][0] == ')': return False
      else:
        
        @lru_cache(None)
        def helper(x, y, acc):
          if x == m-1 and y == n-1:
            if grid[x][y] == ')':
              if acc == 1: return True
              else: return False
          else:
            if grid[x][y] == ')':
              if acc == 0: return False
              else:
                if x < m-1:
                  res = helper(x+1, y, acc-1)
                  if res: return True
                if y < n-1:
                  res = helper(x, y+1, acc-1)
                  if res: return True
                return False
            else:
              acc += 1
              if x < m-1:
                res = helper(x+1, y, acc)
                if res: return True
              if y < n-1:
                res = helper(x, y+1, acc)
                if res: return True
              return False
          
        return helper(0, 0, 0)",0
"class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        num_str = str(num)
        n = len(num_str)
        
        count = 0
        for i in range(n - k + 1):
            sub_num = int(num_str[i:i+k])
            if sub_num == 0 or num % sub_num != 0:
                continue
                
            count += 1
            
        return count",1
"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        running_sum = []
        total = 0
        for i, num in enumerate(nums):
            total += num
            running_sum.append(total)
        
        total = sum(nums)
        splits = 0
        n = len(nums)
        for i in range(n-1):
            if running_sum[i] >= total-running_sum[i]:
                splits += 1
        
        return splits",1
"class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        if not carpetLen or not tiles: return 0
        def get_next(itl, lf, rt):
            if itl < lf - 1:
                next_itr = lf - 1
            elif itl == lf - 1:
                next_itr = lf
            elif lf <= itl < rt:
                next_itr = rt
            elif itl == rt:
                next_itr = rt + 1
            else:
                next_itr = itl + 1
            return next_itr
        tiles.sort()
        itl = -1
        itr = 0
        iwl = iwr = 0
        nw = 0
        max_w = 0
        max_iter = tiles[-1][1]
        prev_itr = -1
        while itr  < (tiles[-1][1] + 1):
            itl = itr - carpetLen
            njump = itr - prev_itr
            
            if njump == 1:
                while itr > tiles[iwr][1] and iwr < len(tiles) - 1:
                    iwr += 1
                lf, rt = tiles[iwr]
                if lf <= itr <= rt:
                    nw += 1

                next_itr = get_next(itr, lf, rt)
                if itl >= 0:
                    while itl > tiles[iwl][1] and iwl < len(tiles) - 1:
                        iwl += 1
                    lf, rt = tiles[iwl]
                    if lf <= itl <= rt:
                        nw -= 1
                    next_itr2 = get_next(itl, lf, rt) + carpetLen
                else:
                    next_itr2 = math.inf
                prev_itr = itr
                itr = min(next_itr, next_itr2)
            else:
                lf, rt = tiles[iwr]
                if lf <= prev_itr <= rt:
                    nw += itr - prev_itr
                if prev_itr - carpetLen >= 0:
                    lf, rt = tiles[iwl]
                    if lf <= prev_itr - carpetLen <= rt:
                        nw -= itr - prev_itr   
                prev_itr = itr
                itr += 1
            max_w = max(max_w, nw)
        return max_w",0
"class Solution:
    def largestVariance(self, s: str) -> int:
        counter = Counter(s)
        res = 0
        
        for a, b in permutations(counter, 2):
            count_a, count_b = 0, 0
            remain_b = counter[b]
            for ch in s:
                if ch not in {a, b}:
                    continue
                if ch == a:
                    count_a += 1
                elif ch == b:
                    count_b += 1
                    remain_b -= 1
                # Kadane's Algorithm, modified
                if count_a < count_b and remain_b > 0:
                    count_a, count_b = 0, 0
                if count_b > 0:
                    res = max(res, count_a - count_b) 

        return res",0
"class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        new = [words[0]]
        for i in range(1, len(words)):
            if Counter(words[i - 1]) == Counter(words[i]):
                continue
            else:
                new.append(words[i])
                
        return new",1
"class Solution:
    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:
        aug = [bottom-1] + sorted(special) + [top+1]
        return max(aug[i]-aug[i-1]-1 for i in range(1, len(aug)))",0
"class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        lst, n = [], len(str(bin(max(candidates)))[2:])
        for x in candidates:
            lst.append(str(bin(x))[2:].zfill(n))

        counter = Counter()
        for x in lst:
            for i, y in enumerate(x):
                if y == ""1"":
                    counter[i] += 1
					
        return max(counter.values())",1
"class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        c=0
        for i in letter:
            if i in s:
                c+=s.count(i)
        return c*100//len(s)",1
"class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        heap = []
        answer = 0
        n = len(rocks)

        for i in range(n):
            heappush(heap, (
                capacity[i] - rocks[i],
                i
            ))

        while heap:
            remainingCapacity, index  = heappop(heap)
            if remainingCapacity == 0:
                answer += 1

            if 0 < remainingCapacity <= additionalRocks and additionalRocks > 0:
                heappush(heap, (
                    0,
                    index
                ))
                additionalRocks -= remainingCapacity


        return answer",1
"class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        if len(stockPrices) == 1 :
            return 0
        if len(stockPrices) == 2:
            return 1
        number = 1
        stockPrices.sort()
        for i in range(2, len(stockPrices)):
            if int((stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i-1][0]-stockPrices[i-2][0])) !=\
               int((stockPrices[i-1][1]-stockPrices[i-2][1])*(stockPrices[i][0]-stockPrices[i-1][0])):
                number = number + 1
                
        return number
		```",1
"class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        ans = 0 
        stack = []
        prefix = list(accumulate(accumulate(strength), initial=0))
        for i, x in enumerate(strength + [0]): 
            while stack and stack[-1][1] >= x: 
                mid = stack.pop()[0]
                lo = stack[-1][0] if stack else -1 
                left = prefix[mid] - prefix[max(lo, 0)]
                right = prefix[i] - prefix[mid]
                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007
            stack.append((i, x))
        return ans",0
"class Solution:
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            if int(num[i]) != num.count(str(i)):
                return False
        return True",1
"class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        d,res,s = {},-1,""""
        for i in range(len(senders)):
            sender = senders[i]
            message_count = len(messages[i].split("" ""))
            d[sender] = d.get(sender,0) + message_count
            if d[sender] > res:
                res = d[sender]
                s = sender
            elif d[sender] == res:
                s = max(sender,s)
            
        return s",0
"class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        dict1={}
        for i in roads:
            if i[0] not in dict1:dict1[i[0]]=1
            else:dict1[i[0]]+=1
            if i[1] not in dict1:dict1[i[1]]=1
            else:dict1[i[1]]+=1
        sorted_dict = {}
        sorted_keys = sorted(dict1, key=dict1.get)  

        for w in sorted_keys:
            sorted_dict[w] = dict1[w]
        
        items = list(sorted_dict.items())
        sorted_dict = {k: v for k, v in reversed(items)}
        
        ans=0
        for i in sorted_dict:
            sorted_dict[i]=n
            n-=1
            
        print(sorted_dict)
        for i in roads:
            hold=sorted_dict[i[0]]+sorted_dict[i[1]]
            ans+=hold
        
        return ans",0
"class Solution:
   def rearrangeCharacters(self, s: str, target: str) -> int:
       c1=Counter(s)
       c2=Counter(target)
       cnt=0
       while (c2&amp;c1)==c2:
           cnt+=1
           c1=c1-c2
       return (cnt)",1
"class Solution:
    def discountPrices(self, sentence: str, discount: int) -> str:
        strings = sentence.split(' ')
        result = []
        
        for string in strings:
            if string[0] == '$': tmp = string[1:] tmp.replace('.', '') if tmp.isdigit(): new = (float)(string[1:]) * ((100 - discount) / 100) new = ""$"" + ""{:.2f}"".format(new)
                    result.append(new)
                else:
                    result.append(string)
            else:
                result.append(string)
        
        return "" "".join(result)",0
"class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        ans = 0 
        stack = []
        for x in nums: 
            val = 1
            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)
            if not stack: val = 0
            stack.append((x, val))
            ans = max(ans, val)
        return ans",1
"class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        
        x = 0 
        while len(nums)>1:
            a = []
            while nums:
                if x:
                    a.append(max(nums[0],nums[1]))
                    nums.pop(0)
                    nums.pop(0)
                    x = 0
                else:
                    a.append(min(nums[0],nums[1]))
                    nums.pop(0)
                    nums.pop(0)
                    x = 1 
            nums = a 
        return nums[0]",1
"class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        answer = 0
        nums.sort()

        while nums:
            smallestNumber = nums.pop(0)
            while nums and smallestNumber <= nums[0] and nums[0] - smallestNumber <= k:
                nums.pop(0)

            answer += 1

        return answer",1
"class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
        hashmap = {}

        for i, number in enumerate(nums):
            hashmap[number] = i

        for start, end in operations:
            if start in hashmap:
                nums[hashmap[start]] = end
                hashmap[end] = hashmap[start]

        return nums",1
"class Solution:
    def strongPasswordCheckerII(self, S: str) -> bool:
        if len(S)<8:
            return False
        num=0
        upper=0
        lower=0
        spec=0
        char=""!@#$%^&amp;*()-+""
        for i in range(len(S)):
            if i>0 and S[i]==S[i-1]:
                return False
            if S[i].isdigit():
                num+=1
            if S[i].isupper():
                upper+=1
            if S[i].islower():
                lower+=1
            if S[i] in char:
                spec+=1
        if num>0 and upper >0 and lower>0 and spec>0 :
            return True
        return False",0
"class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        m = len(potions)  
        return [m - bisect.bisect_left(potions, math.ceil(success / spell))
                for spell in spells]",0
"class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        
#         maintain a map to know which letters can be changed
        d = defaultdict(set)

        for i,j in mappings:
            d[i].add(j)
        
        
        k = len(sub)
        
#         iterate over all possibilities of size len(sub)
        for i in range(len(s)-k+1):
            st = s[i:i+k]
            fl = 0
#          iterate greedily and try if we can replace cur character or not if not we break
            for j in range(k):
                if sub[j] != st[j]: 
                    if st[j] not in d[sub[j]]: 
                        fl = 1
                        break
            if fl ==0: return True
        return False",1
"class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        res = 0
        left = 0
        windowSum = 0
        
        for right, num in enumerate(nums):
            windowSum += num
            windowLength = right - left + 1
            while windowSum * windowLength >= k:
                windowSum -= nums[left]
                left += 1
                windowLength -= 1
            
            res += windowLength
        
        return res",1
"class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        
        ans = 0

        n = len(brackets)
        if income <= brackets[0][0]:
            return income * brackets[0][1] * 0.01

        # brackets[k - 1] < income < brackets[k]
        k = 0
        
        for i in range(n):
            if income > brackets[i][0]:
                k += 1

        j = 1
        ans += brackets[0][0] * brackets[0][1] * 0.01
        while j < k:
            ans += (brackets[j][0] - brackets[j - 1][0]) * brackets[j][1] * 0.01
            j += 1

        ans += (income - brackets[j - 1][0]) * brackets[j][1] * 0.01
        
        return ans",1
"class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dic = defaultdict(list)
        lastRow = set(grid[-1])
        
        for i in range(m*n):
            for j in range(n):
                if i in lastRow:
                    continue
                else:
                    # (cost, dest_col)
                    dic[i].append((moveCost[i][j], j))
                    
        dp = [[float('inf')] * n for _ in range(m)]
        
        for i in range(n):
            dp[0][i] = grid[0][i]
        
        for i in range(m-1):
            for j in range(n):
                start = grid[i][j]
                for cost, dest_col in dic[start]:
                    dp[i + 1][dest_col] = min(dp[i + 1][dest_col], dp[i][j] + cost + grid[i + 1][dest_col])
        
        return min(dp[-1])",0
"class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        ans = sum(cookies)
        N = len(cookies)
        total = [0]*k
        
        def backtrack(i, total):
            nonlocal ans
            if i == N:
                ans = min(ans, max(total))
                return
            
            if max(total) >= ans:
                return
            
            for j in range(k):
                total[j] += cookies[i]
                backtrack(i+1, total)
                total[j] -= cookies[i]
        

        backtrack(0, total)
        return ans",1
"class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        seen = set(ideas)
        freq = Counter()
        letters = {x[0] for x in ideas}
        for idea in ideas: 
            for ch in letters: 
                if ch + idea[1:] not in seen: freq[idea[0], ch] += 1 
        ans = 0 
        for idea in ideas: 
            for ch in letters: 
                if ch + idea[1:] not in seen: ans += freq[ch, idea[0]]
        return ans",1
"class Solution:
    def greatestLetter(self, s: str) -> str:
        d = {}
        ans = """"
        for i in s:
            if i in d:
                ans = max(ans,i.upper())
            else:
                if i.islower():
                    d[i.upper()] = i 
                else:
                    d[i.lower()] = i 
        return ans",1
"class Solution:
    
    
    def minimumNumbers(self, num: int, k: int) -> int:
        if num==0:
            return 0
        if num<k:
            
            return -1
        nums=[]
        
        while k<=num:
            
            nums.append(k)
            k+=10
        
    
        amount=num
        n=len(nums)

        dp=[[10**9]*(num+1)for _ in range(n)]
        for i in range(n):
            dp[i][0]=0
        if nums[0]<=amount:
            if nums[0]!=0 and amount%nums[0]==0:
                dp[0][nums[0]]=amount//nums[0]
                
            
        for i in range(n):
            for j in range(1,num+1):
                take=10**9
                if nums[i]<=j:
                    take=1+dp[i][j-nums[i]]
                not_take=dp[i-1][j]
                
                dp[i][j]=min(take,not_take)
                ans=dp[i][j]
                    
        if ans!=10**9:
            return ans
        
        return -1",0
"class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        # count all '0' first
        # traverse the s from back to front, try each digit '1'
        
        target = bin(k)[2:]
        result = s.count('0')
        n = len(s)
        cur_sum = 0
        
        for i in range(n-1, -1, -1):
            char = s[i]
            
            if char == '1':
                cur_num = 2 ** ((n-1)-i)
                cur_sum += cur_num
                
                if cur_sum > k:
                    return result
                else:
                    result += 1
        
        return result",1
"class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        mp = {(h, w) : p for h, w, p in prices}
        
        @cache
        def fn(m, n): 
            """"""Return max money of a mxn piece of wood.""""""
            if m == 0 or n == 0: return 0
            ans = 0 
            if (m, n) in mp: ans = mp[m, n]
            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))
            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))
            return ans 
        
        return fn(m, n)",0
"class Solution:
    def countAsterisks(self, s: str) -> int:
        
        result = 0
        
        for i, chunk in enumerate(s.split(""|"")):
            if i % 2 == 0:
                result += chunk.count(""*"")
        
        return result",1
"class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        g = collections.defaultdict(list)
        seen = set()
        res = []
        
        # generate an adjacency list from edges
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        
        # count nodes in each disjoint graph segments
        def dfs(node):
            if node in seen:
                return
            
            self.count += 1
            seen.add(node)
            for nei in g[node]:
                dfs(nei)
                
            return
        
        for i in range(n):
            self.count = 0
            if i not in seen:
                dfs(i)
                
            res.append(self.count) 
            self.count = 0
                
        # returning sum of product all unique pairs 
        # (a1+a2+a3+...)^2 = (a1^2 + a2^2 + ...) + 2*(a1.a2 + a2.a3 + ...)
        # using above formula we can return the desired result
        return (sum(res)**2 - sum(num**2 for num in res))//2",1
"class Solution:
    def maximumXOR(self, nums: List[int]) -> int:
        return reduce(lambda x,y:x|y, nums)",1
"class Solution:
    def distinctSequences(self, n: int) -> int:
        MOD = 10**9 + 7
        @cache
        def dfs(i, prev, prev_prev):
            if i >= n:
                return 1
            result = 0
            for dice in range(1, 7):
                if dice == prev or dice == prev_prev:
                    continue
                if dice % 2 == 0 and prev % 2 == 0:
                    continue
                if dice % 3 == 0 and prev % 3 == 0:
                    continue
                result += dfs(i + 1, dice, prev)
            return result % MOD
        return dfs(0, -1, -1)",0
"class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        
        for i in range(n):
            for j in range(n):
                if i == j or i == n - j - 1:
                    if grid[i][j] == 0:
                        return False
                else:
                    if grid[i][j] != 0:
                        return False
                    
        return True",1
"class Solution:
    def countHousePlacements(self, n: int) -> int:
        mod = 1000000007
        if n==1:
            return 4
      
        
        count_end = 1
        count_space = 1
        
        for i in range(2,n+1):
            prev_end = count_end
            prev_space = count_space
            
            count_space = prev_end + prev_space
            count_end  =prev_space
            
        ways = count_end + count_space
        
        return (ways*ways)%mod",1
"class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        v1 = v2 = m1 = m2 = 0
        for x1, x2 in zip(nums1, nums2): 
            v1 = max(0, v1+x2-x1)
            v2 = max(0, v2+x1-x2)
            m1 = max(m1, v1)
            m2 = max(m2, v2)
        return max(sum(nums1)+m1, sum(nums2)+m2)",0
"class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        tree = [set() for _ in range(n)]
        for e in edges:
            tree[e[0]].add(e[1])
            tree[e[1]].add(e[0])

        def make_tree(i, parent):
            ancestors[i].add(parent)
            for j in ancestors[parent]:
                ancestors[i].add(j)
            tree[i].remove(parent)
            for child in tree[i]:
                make_tree(child, i)
                xor[i] ^= xor[child]

        xor = [nums[i] for i in range(n)]
        ancestors = [set() for _ in range(n)]
        for child in tree[0]:
            make_tree(child, 0)
            xor[0] ^= xor[child]

        ans = 2 ** 31 - 1
        for i in range(1, n - 1):
            for j in range(i + 1, n):
                if i in ancestors[j]:
                    parts = [xor[0] ^ xor[i], xor[i] ^ xor[j], xor[j]]
                elif j in ancestors[i]:
                    parts = [xor[0] ^ xor[j], xor[i], xor[i] ^ xor[j]]
                else:
                    parts = [xor[0] ^ xor[i] ^ xor[j], xor[i], xor[j]]
                ans = min(ans, max(parts) - min(parts))
        return ans",0
"class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        i = 97
        encMap = {' ': ' '}
        for c in key:
            if c not in encMap:
                encMap[c] = chr(i)
                i += 1
        
        res = []
        for c in message:
            res.append(encMap[c])
        
        return ''.join(res)",1
"class Solution:
    def spiralMatrix(self, rows: int, cols: int, head: Optional[ListNode]) -> List[List[int]]:
        ans = [[-1] * cols for _ in range(rows)]
        rows1, cols1 = rows - 1, cols - 1
        min_layers = min(rows, cols) // 2
        for i in range(min_layers):
            for c in range(i, cols1 - i):
                ans[i][c] = head.val
                head = head.next
                if not head:
                    return ans
            col = cols1 - i
            for r in range(i, rows1 - i):
                ans[r][col] = head.val
                head = head.next
                if not head:
                    return ans
            row = rows1 - i
            for c in range(cols1 - i, i, -1):
                ans[row][c] = head.val
                head = head.next
                if not head:
                    return ans
            for r in range(rows1 - i, i, -1):
                ans[r][i] = head.val
                head = head.next
                if not head:
                    return ans
        if rows <= cols and rows % 2:
            for c in range(min_layers, cols - min_layers):
                ans[min_layers][c] = head.val
                head = head.next
                if not head:
                    return ans
        elif cols % 2:
            for r in range(min_layers, rows - min_layers):
                ans[r][min_layers] = head.val
                head = head.next
                if not head:
                    return ans
        return ans",0
"class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        
        '''
        Time: O(n)
        Space: O(n)
        '''
        # record the newly pepole who know the secret on the given day
        dp = [0]*(n+1)
        dp[1] = 1
        share = 0
        MOD = 10**9 + 7
        for i in range(2, n+1):
            # newly people who know the secret today is the sum of days(forget:delay]
            dp[i] = share = (share + dp[i - delay] - dp[i - forget]) % MOD

        # return the sum of days where people not forget the secret yet
        return sum(dp[n-forget+1:]) % MOD",1
"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        '''
        time, space: O(m*n)
        similar to : https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
        '''
        R, C = len(grid), len(grid[0])
        memo = {}
        MOD = 10**9 + 7
        
        def dfs(i, j, R, C, memo):
            if (i, j) in memo:
                return memo[(i,j)]
            
            res = 1
            for di,dj in [(1,0), (0,1), (-1,0), (0,-1)]:
                ni, nj = i+di, j+dj
                if 0<=ni<R and 0<=nj<C and grid[ni][nj] > grid[i][j]:
                    # res = max(res, dfs(ni, nj, R, C, memo))
                    res += dfs(ni, nj, R, C, memo)
            memo[(i, j)] = res % MOD
            return memo[(i, j)]
            
            
        ans = 0
        for i in range(R):
            for j in range(C):
                #ans = max(ans, dfs(i, j, R, C, memo))
                ans += dfs(i, j, R, C, memo) % MOD
                
        return ans % MOD",0
"class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if root.left is None:
            return root.val
        if root.val==2:
            return self.evaluateTree(root.left) or self.evaluateTree(root.right)
        else:
            return self.evaluateTree(root.left) and self.evaluateTree(root.right)",1
"class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        buses = sorted(buses)
        passengers = deque(sorted(passengers))
        res = buses[-1]
        
        s = set(passengers)
        prev = passengers[0]
        
        for i, bus in enumerate(buses):
            cap = capacity
            while cap and passengers and passengers[0] <= bus:
                val = passengers.popleft()
                prev = val
                cap -= 1
                if val-1 not in s:
                    res = val-1
                
            if cap:
                for k in range(bus, prev, -1):
                    if k not in s:
                        res = k
                        break
        
        return res",0
"class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        
        nums = [abs(a - b) for a, b in zip(nums1, nums2) if a != b]
        if k1 + k2 >= sum(nums): return 0

        cnt = Counter(nums)
                
        q = []
        for k in cnt:
            heappush(q, -k)        
        
        tot = sum(pow(x, 2) for x in nums)        
        k = k1 + k2
        # ops on largest diff
        while k > 0 and q:
            cur = -heappop(q)
            diff = cur + q[0] if q else cur
            # reduce current diff to next smaller diff
            if diff * cnt[cur] <= k:
                k -= diff * cnt[cur]
                cnt[-q[0]] += cnt[cur]
                tot += (pow(-q[0], 2) - pow(cur, 2)) * cnt[cur] 
            # apply all remaining ops
            else:
                a, b = divmod(k, cnt[cur])
                tot += (pow(cur - a - 1, 2) * b + pow(cur - a, 2) * (cnt[cur] - b)) - pow(cur, 2) * cnt[cur]
                k = 0                   
            
        
        return tot",0
"class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        nums.append(0)
        stack = [(0, -1)]
        for i, v in enumerate(nums):
            while len(stack) > 1 and v <= stack[-1][0]:
                if stack[-1][0] > threshold / (i - 1 - stack[-2][1]):
                    return i - 1 - stack[-2][1]
                stack.pop()
            stack.append((v, i))
        return -1",1
"class Solution:
    def fillCups(self, amount: List[int]) -> int:
        amount.sort()
        a = amount[-1]
        b = amount[0] + amount[1]
        if b>a: 
            if (b-a)%2==0:
                return a + (b-a)//2
            else:
                return a + 1 + (b-a)//2
        return a",1
"class Solution:
    def canChange(self, start: str, target: str) -> bool:
        d = {}
        e = {}
        for i in range(len(start)):
            if start[i] not in d:
                d[start[i]] = [i]
                e[start[i]] = i
            else:
                d[start[i]].append(i)
        if ""L"" not in e:
            e[""L""] = -1
            d[""L""] = []
        if ""R"" not in e:
            e[""R""] = -1
            d[""R""] = []
        a = target.count(""L"")
        b = target.count(""R"")
        if a!=len(d[""L""]) or b!=len(d[""R""]):
            return False
        for i in range(len(target)):
            if target[i]==""L"":
                if e[""L""]>=i and ((e[""R""]!=-1 and e[""R""]>e[""L""]) or e[""R""]==-1):
                    if d[""L""]:
                        d[""L""].pop(0)
                        if d[""L""]:
                            e[""L""] = d[""L""][0]
                        else:
                            e[""L""] = -1 
                    else:
                        return False
                else:
                    return False 
            elif target[i]==""R"":
                if e[""R""]<=i and ((e[""L""]!=-1 and (e[""L""]>i)) or e[""L""]==-1):
                    if d[""R""]:
                        d[""R""].pop(0)
                        if d[""R""]:
                            e[""R""] = d[""R""][0]
                        else:
                            e[""R""] = -1 
                    else:
                        False
                else:
                    return False
        return True",0
"class Solution:
    def __init__(self):
        self.MOD = 1000000007
        self.memo = {0: 1}
        self.fact = [1 for i in range(10100)]
        
    def inv(self, x):
        if x>1: return self.inv(self.MOD%x)*(self.MOD-self.MOD//x)%self.MOD 
        else: return x
        
    def choose(self, n, k):
        return ((self.fact[n] * self.inv(self.fact[n-k]) ) % self.MOD )* self.inv(self.fact[k]) %self.MOD
    
    def factors(self, x):
        a = []
        i = 2
        while x > 1:
            re = 0
            while x % i == 0:
                re += 1
                x //= i
            if re: a.append(re)
            i += 1
        return a   
    
    def h(self, v):
        if v in self.memo: return self.memo[v]
        self.memo[v] = self.choose(v+self.c, self.c)
        return self.memo[v]
        
    def idealArrays(self, n: int, maxValue: int) -> int:
        s = 0
        self.c = n-1
        
        for i in range(2,10100):
            self.fact[i] = self.fact[i-1] * i % self.MOD

        for i in range(1, maxValue+1):
            cur = 1
            fa = self.factors(i)
            for f in fa: cur = (cur*self.h(f))%self.MOD
            s = (s+cur)%self.MOD
        return s",0
"class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        answer = [0, 0]
        mydict = defaultdict(int)
        for num in nums:
            mydict[num] += 1
        for key in mydict:
            answer[0] += mydict[key] // 2
            answer[1] += mydict[key] % 2
        return answer",1
"class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        hmap = collections.defaultdict(list)
        
        for n in nums:
            total = sum([int(i) for i in str(n)])
            
            hmap[total] = hmap[total] +[n]
            hmap[total] = sorted(hmap[total], reverse=True)[:2]
        
        result = -1
        for k, v in hmap.items():
            if len(v) == 2:
                result = max(result, sum(v))
        return result",1
"class Solution:
    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        A = list(enumerate(nums)) # (1)
        res = []
        for k, t in queries:
            A.sort(key=lambda x: (int(x[1][len(x[1]) - t:]), x[0])) # (2)
            res.append(A[k - 1][0]) # (3)
        return res",1
"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        GCD = reduce(lambda x,y: gcd(x,y), numsDivide)
        nums.sort()
        
        for idx, num in enumerate(nums):
            if(GCD % num == 0):
                return idx 
        return -1",1
"class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:
        r = collections.Counter(ranks)
        s = collections.Counter(suits)
        for i in s:
            if s[i] >= 5:
                return ""Flush""
        for i in r:
            if r[i] >= 3:
                return ""Three of a Kind""
        for i in r:
            if r[i] >= 2:
                return ""Pair""
        return ""High Card""",1
"class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        temp = [0] * (len(nums) + 1)
        for index, num in enumerate(nums, start=1):
            if num == 0:
                temp[index] = 1 + temp[index - 1]

        return sum(temp)",1
"class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        res = 0
        s = set()
        for i in range(len(rolls)):
            num = rolls[i]
            if num not in s:
                s.add(num)
                if len(s) == k:
                    res+=1
                    s = set()
        return res+1",1
"class Solution:
    def repeatedCharacter(self, s: str) -> str:
        l = []
        for i in s:
            if i in l:
                return i
            else:
                l.append(i)",1
"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        root = {}
        n = len(grid)
        for i in range(n):
            tmp = root
            for j in range(n):
                if grid[i][j] not in tmp:
                    tmp[grid[i][j]] = {}
                tmp = tmp[grid[i][j]]
            if '#' in tmp:
                tmp['#'] += 1
            else:
                tmp['#'] = 1
        
        numPair = 0
        for j in range(n):
            tmp = root
            for i in range(n):
                if grid[i][j] not in tmp:
                    break
                tmp = tmp[grid[i][j]]
            if '#' in tmp:
                numPair += tmp['#']
        
        return numPair",1
"class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        freq = Counter(map(int.bit_count, set(nums)))
        return sum(v1*v2 for k1, v1 in freq.items() for k2, v2 in freq.items() if k1+k2 >= k)",0
"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        nums.sort()
        count = 0 
        while nums.count(0) != len(nums) : 
            count += 1 
            nums.sort()
            flag, min_num = True, 0
            for i in range(len(nums)) : 
                if (nums[i] != 0) and flag :
                    min_num = nums[i]
                    flag = False 
                nums[i] -= min_num
        return count",1
"class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        if len(grades) <= 2 : 
            return 1 
        else : 
            grades.sort()
            dict_group ={}
            group_len = 1 
            i = 0
            end = 0
            while end < len(grades) :
                start, end = i, i + group_len
                # if end >= len(grades) : 
                #     break 
                if group_len != 1 :
                    if (sum(grades[start: end]) > sum(dict_group[group_len - 1])) and (len(grades[start: end]) == (end - start)) :
                        # print(start, end)
                        dict_group[group_len] = grades[start: end] 
                    else : 
                        return len(dict_group)
                else : 
                    dict_group[group_len] = grades[start: end] 
                    
                group_len += 1 
                i = end 
                # print(dict_group)
            return len(dict_group)",0
"class Solution:
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        ## RC ##
        ## APPROACH: GRAPH ##
        ## LOGIC ##
        ## 1. Typical Graph problem, just do what the question asks
        ## 2. Watch out for race conditions, a) when no common node b) multiple paths for the same node
        graph = collections.defaultdict(list)
        for u, v in enumerate(edges):
            if v != -1:
                graph[u].append(v)
        
        res = float('inf')
        ans = -1
        visited1 = {}
        def dfs1(node, d):
            nonlocal res
            nonlocal ans
            if node == node2:
                res=min(res, d)
                ans=node
            if node in visited1:
                if visited1[node] > d:
                    visited1[node] = d
                return
            visited1[node] = d
            if node in graph:    
                dfs1(graph[node][0], d +1)
        
        dfs1(node1, 0)
        
        visited2 = {}
        def dfs2(node, d):
            nonlocal res
            nonlocal ans
            if node == node1:
                if res > d:         # if already found in first node, then check for max distance
                    res = d
                    ans=node
            if node in visited2:
                if visited2[node] > d:
                    visited2[node] = d
                return
            visited2[node] = d
            if node in graph:    
                dfs2(graph[node][0], d +1)
        
        dfs2(node2, 0)
        for node in sorted(visited1.keys()):
            if node in visited2:
                if max(visited1[node], visited2[node]) < res:
                    res = max(visited1[node], visited2[node])
                    ans = node
        return ans",0
"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        
        ans = -1
        
        def checkLoop(start):
            temp = {}
            count = 0
            while start != -1:
                if start in temp:
                    return count - temp[start]
                elif start in visited:
                    return -1
                
                visited.add(start)
                temp[start] = count
                count += 1
                start = edges[start]
            return -1
                
        visited = set()
        
        for value in edges:
            if value in visited:
                continue
            else:
                ans = max(ans, checkLoop(value))
        
        return ans",1
"class Solution:
    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        weight = {} # or defaultdict(int)
        values, weights = zip(*items1, *items2)
        for val, wt in zip(values, weights):
            weight[val] = weight.get(val, 0) + wt
        return sorted(weight.items())",0
"class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        k = len(nums)
        res = k * (k - 1) // 2 # (1)
        c = Counter([i - n for i, n in enumerate(nums)]) # (2) and (3)
        for n in c.values():
            res -= n * (n - 1) // 2 # (4)
        return res",1
"class Solution:
    def taskSchedulerII(self, tasks: List[int], space: int) -> int:
        ld={}
        d=0
        for t in tasks:
            ld[t]=0
        for t in tasks:
            if ld[t]==0:
                d+=1
                ld[t]=d
            else:
                nd=ld[t]+space
                ld[t]=max(nd+1,d+1)
                d=ld[t]
        return d",1
"class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        
        def helper(n, to_deal):                 # return (times needed to divide, biggest left-most num)
            if n <= to_deal:
                return (0, n)
            if n % to_deal == 0:                # For example: [9, 3]
                return (n//to_deal - 1, to_deal)
            else:
                times = n // to_deal            # For example: [10, 4], it should at least deivide (n1 // to_deal) times
                x = n // (times+1)              # Since we know 10 must divided into 3 num, the biggest left-most num will be 10//3 = 3
                return (times, x)
                
        to_deal = nums[-1]                      
        res = 0
        i = len(nums) - 2                       # Iterate from the second-last element. 
        
        while i >= 0:
            times, left_most_num = helper(nums[i], to_deal)
            res += times
            to_deal = left_most_num             # Update to_deal to the left_most_num .
            i -= 1
        
        return res",0
"class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        ans = 0 
        seen = set()
        for x in nums: 
            if x-diff in seen and x-2*diff in seen: ans += 1
            seen.add(x)
        return ans",1
"class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        g = defaultdict(list)
        restrict = set(restricted)
        
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
            
        seen = set()
        stack = [0]
        res = 0

        while stack:
            node = stack.pop()

            if node not in seen:
                res += 1
                seen.add(node)

            for adj in g[node]:
                if adj not in seen and adj not in restrict:
                    stack.append(adj)
                    
        return res",1
"class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        dp = [False]*(len(nums)+1)
        dp[-1] = True 
        for i in range(len(nums)-1, -1, -1): 
            if i+1 < len(nums) and dp[i+2] and nums[i] == nums[i+1] \
            or i+2 < len(nums) and dp[i+3] and (nums[i] == nums[i+1] == nums[i+2] or nums[i]+2 == nums[i+1]+1 == nums[i+2]): dp[i] = True
        return dp[0]",0
"class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        
        s = [ord(c) - ord('a') for c in s]
        
        m = 0
        
        hm = {}
        
        for i,v in enumerate(s) :
            
            m = 1
            for h in hm:
                if abs(v - h) <= k:
                    m = max(m, hm[h] +1)
            
            hm[v] = m
        
        return max(hm.values())",1
"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        edge_cnts = defaultdict(int)
        max_idx, max_val = 0, 0
        
        for inp, out in enumerate(edges):
            edge_cnts[out] += inp
            
        for idx in range(len(edges)):
            if edge_cnts[idx] > max_val:
                max_idx, max_val = idx, edge_cnts[idx]
                
        return max_idx",1
"class Solution:
    def smallestNumber(self, pattern: str) -> str:
        
        
        l = len(pattern)
        
        sol = """"
        
        visited = set([1,2,3,4,5,6,7,8,9])
        
        def backtrack(cur, i ):
            nonlocal l
            nonlocal sol
            
            if len(cur) == l+1:
                sol = cur
                return True

            for j in visited:
                k = int(cur[-1]) 
                if pattern[i] == 'I' and j <= k:
                    continue
                if pattern[i] == 'D' and j >= k:
                    continue
                
                visited.remove(j)
                if backtrack(cur + str(j), i+1):
                    return True
                visited.add(j)
            
            return False

        for j in visited:
            visited.remove(j)
            if backtrack(str(j), 0):
                return sol
            visited.add(j)",0
"class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        vals = list(map(int, str(n)))
        
        @cache
        def fn(i, m, on): 
            """"""Return count at index i with mask m and profile flag (True/False)""""""
            ans = 0 
            if i == len(vals): return 1
            for v in range(vals[i] if on else 10 ): 
                if m &amp; 1<<v == 0: 
                    if m or v: ans += fn(i+1, m ^ 1<<v, False)
                    else: ans += fn(i+1, m, False)
            if on and m &amp; 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)
            return ans 
        
        return fn(0, 0, True)-1",0
"class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        start_index = 0
        length = len(blocks)
        res = float(""inf"")
        count = 0
        for i in range(start_index, k):
            if blocks[i] == ""W"":
                count += 1
        res = min(res, count)
        
        for i in range(k, length):
            if blocks[start_index] == ""W"":
                count -= 1
            if blocks[i] == ""W"":
                count += 1
            
            res = min(res, count)
            start_index += 1
        return res",0
"class Solution:
    def secondsToRemoveOccurrences(self, s: str) -> int:
        
        seconds = 0
        my_list = [*s]
        my_string = s
        
        while '01' in my_string:
            i = 0
            while i < len(my_list) - 1:
                if my_list[i] == '0' and my_list[i + 1] == '1':
                    my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
                    i += 2
                else:
                    i += 1

            my_string = ''.join(my_list)
            seconds += 1
            
        return seconds",1
"class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        ops = [0]*(len(s)+1)
        
        for start, end, direction in shifts:
            ops[start] +=  1 if direction == 1 else -1
            ops[end+1] += -1 if direction == 1 else  1
        
        runningDelta = 0
        w = []
        
        for ind, letter in enumerate(s):
            runningDelta += ops[ind]
            newLetter = chr( (ord(letter) - ord('a') + runningDelta) % 26 + ord('a'))
            w.append(newLetter)
            
        return """".join(w)",1
"class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        running, sum_before = 0, []
        for num in nums:
            running += num
            sum_before.append(running)
        sum_before.append(0) # [-1]
            
        def get_sum(start, end):
            return sum_before[end] - sum_before[start - 1]
        
        removed, res = [-1, len(nums)], []
        max_seg_sums = [float('-inf'), sum(nums)]
        
        for i in removeQueries:
            ins = bisect_left(removed, i)
            before, after = removed[ins - 1], removed[ins]
            
            to_del = bisect_left(max_seg_sums, get_sum(before + 1, after - 1))
            del max_seg_sums[to_del]
            
            new_l, new_r = get_sum(before + 1, i - 1), get_sum(i + 1, after - 1)
            res.append(max(max_seg_sums[-1], new_l, new_r))
            
            bisect.insort(removed, i)
            bisect.insort(max_seg_sums, new_l)
            bisect.insort(max_seg_sums, new_r)
        
        return res",0
"class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        #Approach: Do a single traversal and for every ith opponent, compare your current energy and exp to opponent
        #and adjust so you always win! How much you have to adjust will be number of hours of training you have to invest
        #before you compete!
        
        #At the end, return answer!
        ans = 0
        
        cenergy = initialEnergy
        cexp = initialExperience
        #n = number of opponents to face!
        n = len(energy)
        for i in range(n):
            if(cenergy <= energy[i]):
                ans += (energy[i] - cenergy + 1)
                cenergy = 1
                #if current player has lower exp, then he needs to make it up for it!
                #difference + 1 wil take his current exp to next exp value from opp so he can win!
                #but also, in doing so, he needs to already be 1 ahead! -> set cexp to opponent's exp + 1!
                #Regardless, since he won, he needs to get ith opponents exp added!
                if(cexp <= experience[i]):
                    ans += (experience[i] - cexp + 1)
                    cexp = experience[i] + 1
                #regardless, current experience only goes up!
                cexp += (experience[i])
                continue
                
                
            else:
                cenergy -= energy[i]
                if(cexp <= experience[i]):
                    ans += (experience[i] - cexp + 1)
                    cexp = experience[i] + 1
                cexp += (experience[i])
                
        
        return ans",0
"class Solution:
    def largestPalindromic(self, num: str) -> str:
        
        counter = Counter(num)
        
        l = [(-int(n), c) for n, c in counter.items()]
        heapq.heapify(l)
        
        left, right = [], []
        mid = None

        while l:
            n, c = heapq.heappop(l)
            n = -n 
            
            if c % 2 == 0:
                left = left + [n] * (c // 2)
                right = [n] * (c // 2) + right
            else:
                if c - 1 > 0:
                    heapq.heappush(l, (-n, c - 1))
                if mid is None:
                    mid = n
    
        if mid is None and l:
            mid = -l[0][0]
        
        while right and right[-1] == 0:
            right.pop()

        res = left[:len(right)] + [mid] + right if mid is not None else left[:len(right)] + right
        
        if not res:
            return ""0""

        return ''.join([str(i) for i in res])",0
"class Solution:
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
		### building the map, see for each node who it touches ###
        queue = [(root, None)]
        mapping = {}
        while (queue):
            curr, parent = queue.pop()
            touches = []
            if (curr.left):
                touches.append(curr.left.val)
                queue.append((curr.left, curr))
            if (curr.right):
                touches.append(curr.right.val)
                queue.append((curr.right, curr))
            if (parent):
                touches.append(parent.val)
            mapping[curr.val] = touches
        
		
		### do a simulation kinda ###
        time = 0
        current_wave = [start]
        next_wave = []
        seen = set()
        seen.add(start)
        
        while (current_wave):
            node_id = current_wave.pop()
            for touch in mapping[node_id]:
                if touch not in seen:
                    next_wave.append(touch)
                    seen.add(touch)
            
            if (len(current_wave) == 0):
                if (len(next_wave) == 0):
                    return time
                else:
                    time += 1
                    current_wave = next_wave
                    next_wave = []
        
        return 0",0
"class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        m = sum(x for x in nums if x > 0)
        pq = [(-m, 0)] 
        vals = sorted(abs(x) for x in nums)
        for _ in range(k): 
            x, i = heappop(pq)
            if i < len(vals): 
                heappush(pq, (x+vals[i], i+1))
                if i: heappush(pq, (x-vals[i-1]+vals[i], i+1))
        return -x",0
"class Solution:
    def answerQueries(self, nums: List[int], q: List[int]) -> List[int]:
        nums.sort()
        pref=[]
        pref.append(nums[0])
        for i in nums[1:]:
            pref.append(i+pref[-1])
        
        ans=[]
        for i in q:
            ans.append(bisect.bisect(pref, i))
        
        return ans",1
"class Solution:
#Time-Complexity: O(N^2)
#Space-Complexity:O(1)
#Space-Complexity:O(
    def removeStars(self, s: str) -> str:
        #Brute-Force approach: As long as star character appears in string input s, continously simulate!
        #while ""*"" in s:
            #iterate from left to right char by char until you hit star! then update s to subsequence!
            #for i in range(len(s)):
             #   cur_char = s[i]
             #   if(cur_char == '*'):
                    #reupdate s!
              #      s = s[:i-1] + s[i+1:]
               #     break
        
        #return s
        
        #optimized version: Simply traverse linearly using single pointer in linear time
        #by taking advantage of fact that the star char you see when you traverse from L to R is s.t. the last char
        #in built up string will be one char to be removed along with star char per operation!
        
        ans = """"
        
        for i in range(len(s)):
            cur_char = s[i]
            if(cur_char == '*'):
                #pop off last char!
                ans = ans[:len(ans)-1]
                continue
            else:
                ans += cur_char
        
        return ans",0
"class Solution:
    #If I let n = travel.length and m = garbage.length...
    #Time-Complexity: O(travel.length + garbage.length*10 + 3*garbage.length) -> O(n + m)
    #Space-Complexity: O(3m + (n+1)) ->O(m + n)
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        
        #Approach: First, traverse through garbage array and identify the count as well as the index position of houses
        #each type of garbage is at!
        
        #Utilize 3 hashmaps: one for metal , one for glass , and one for paper!
        #key: index pos -> count: number of garbage at index pos house of that particular type!
        
        metal = {}
        paper = {}
        glass = {}
        
        #need to allocate another array that describes time cost to reach ith index house!
        travel_cost = []
        travel_cost.append(0)
        cur_cost = 0
        
        for e in travel:
            cur_cost += e
            travel_cost.append(cur_cost)
            
        for i in range(len(garbage)):
            for c in garbage[i]:
                if(c == 'M'):
                    if(i not in metal):
                        metal[i] = 1
                    else:
                        metal[i] += 1
                elif(c == 'P'):
                    if(i not in paper):
                        paper[i] = 1
                    else:
                        paper[i] += 1
                else:
                    if(i not in glass):
                        glass[i] = 1
                    else:
                        glass[i] += 1
        
        #once hashmaps are updated, handle 3 types of garbage collection!
        
        #1. Metal
        metal_cost = 0
        pre = 0
        metal_keys = sorted(metal.keys())
        for mk in metal_keys:
            metal_cost += metal[mk]
            metal_cost += (travel_cost[mk] - travel_cost[pre])
            pre = mk
        
        #2. Paper
        paper_cost = 0
        pre2 = 0
        paper_keys = sorted(paper.keys())
        for pk in paper_keys:
            paper_cost += paper[pk]
            paper_cost += (travel_cost[pk] - travel_cost[pre2])
            pre2 = pk
        
        #3. glass
        glass_cost = 0
        pre3 = 0
        glass_keys = sorted(glass.keys())
        for gk in glass_keys:
            glass_cost += glass[gk]
            glass_cost += (travel_cost[gk] - travel_cost[pre3])
            pre3 = gk
        
        return metal_cost + paper_cost + glass_cost",0
"class Solution:
    def buildMatrix(self, k: int, rowCond: List[List[int]], colCond: List[List[int]]) -> List[List[int]]:
        # topological sort:
        # For rows, in other words ""above"" should be put on the rows with index smaller than ""after""
        # so if we could form an k-length result array with the order restricted by rowCondition
        # then we know we should put the numbers to the rows accordingly 
        
        # For example, as for example 1,
        # if we get [3, 1, 2] as one of the topological sorted result array,
        # we know that 3 should be put in the first row (idx = 0), 1 in the second row (idx = 1), 2 in the third row(idx = 2)
        # so we get the row index for each number in [1, k]
        # We could get the col index similarily 
        
        def topo(cond):
            G = defaultdict(list)
            indegree = [0] * (k + 1)
            # build graph, above_edge -> below_edge, or left -> right
            for a, b in cond:
                G[a].append(b)
                indegree[b] += 1
                
            queue = deque([i for i in range(1, k + 1) if indegree[i] == 0])
            res = []
            while queue:
                cur = queue.popleft()
                res.append(cur)
                for nxt in G[cur]:
                    indegree[nxt] -= 1
                    if indegree[nxt] == 0:
                        queue.append(nxt)
            return res 
                
        rows, cols = topo(rowCond), topo(colCond)
        
        # can not form a solution with exact k value sorted in topological order
        if len(rows) != k or len(cols) != k:
            return []
        
        # build num -> idx mp for easier queries 
        mp1, mp2 = {}, {}
        for i, r in enumerate(rows):
            mp1[r] = i
        
        for i, c in enumerate(cols):
            mp2[c] = i
        
        res = [[0] * k for _ in range(k)]
        for num in range(1, k + 1):
            ri, ci = mp1[num], mp2[num]
            res[ri][ci] = num
        return res",0
"class Solution:
    def findSubarrays(self, nums: List[int]) -> bool:
        subSum = 0
        p1 = 0
        count = defaultdict(int)
        
        for p2, num in enumerate(nums):
            subSum += num
            ln = p2 - p1 + 1
            if(ln < 2):
                continue
            elif(ln > 2):
                subSum -= nums[p1] 
                p1 += 1
            count[subSum] += 1
            if(count[subSum] == 2):
                return True
            
        return False",1
"class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        return False",1
"class Solution:
    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        m, n = len(mat), len(mat[0])
        masks = []
        for i in range(m): 
            mask = reduce(xor, (1<<j for j in range(n) if mat[i][j]), 0)
            masks.append(mask)
        ans = 0 
        for x in range(1<<n): 
            if x.bit_count() <= cols: 
                ans = max(ans, sum(mask &amp; x == mask for mask in masks))
        return ans",0
"class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        ii = rsm = 0
        qq = deque()
        for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): 
            rsm += rc 
            while qq and qq[-1][0] <= ct: qq.pop()
            qq.append((ct, i))
            if chargeTimes[qq[0][1]] + (i - ii + 1) * rsm > budget: 
                if qq[0][1] == ii: qq.popleft()
                rsm -= runningCosts[ii]
                ii += 1
        return len(chargeTimes)-ii",0
"class Solution:
    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        if abs(startPos - endPos) > k:
            return 0
        
        @cache
        def dp(currentPosition: int = startPos, stepsAvailable: int = k) -> int:
            if stepsAvailable == 0:
                return 1 if currentPosition == endPos else 0
                
            numWays = dp(currentPosition + 1, stepsAvailable - 1) + dp(currentPosition - 1, stepsAvailable - 1)
            return numWays % (10 ** 9 + 7)
        
        return dp()",0
"class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        last = -1
        ror = 0
        for first in range(n):
            if first > last:
                last = first
                ror = nums[first]
            else:
                ror = nums[first]
                for i in range(first + 1, last + 1):
                    ror = ror | nums[i]
            while last+1<=n-1 and (ror &amp; nums[last+1] == 0):
                ror = ror | nums[last+1]
                last = last + 1
            ans = max(ans, last - first + 1)
            # print((first, last), ror, ans)
        return ans",0
"class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        number_of_meetings_in_room = [0] * n
        room_is_available          = [0] * n
        meetings.sort()
        heap = []
        for meeting_start, meeting_end in meetings:
            meeting_length = meeting_end - meeting_start
            while heap and heap[0][0] <= meeting_start:
                end_time, room_number = heapq.heappop(heap)
                # MAKE SURE TO MAKE ROOM AVAILABLE AFTER!!
                room_is_available[room_number] = 0
            if len(heap) < n:
                for room_number, available in enumerate(room_is_available):
                    if available == 0:
                        number_of_meetings_in_room[room_number] += 1
                        room_is_available[room_number] = meeting_start + meeting_length
                        heapq.heappush(heap, (meeting_start + meeting_length, room_number))
                        break
            else:
                end_time, room_number = heapq.heappop(heap)
                heapq.heappush(heap, (end_time + meeting_length, room_number))
                number_of_meetings_in_room[room_number] += 1
        return -max((meetings, -index) for index, meetings in enumerate(number_of_meetings_in_room))[1]",0
"class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        freq = -1
        ans = -1
        for i in sorted(set(nums)):
            if i%2 == 0 and nums.count(i) > freq:
                freq = nums.count(i)
                ans = i
        return ans",1
"class Solution:
    def partitionString(self, s: str) -> int:
        count=1
        word=""""
        for i in s:
            if i in word:
                count+=1
                word=i
            else:
                word+=i
        return count",1
"class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        line = []
        for x, y in intervals: 
            line.append((x, 1))
            line.append((y+1, 0))
        ans = prefix = 0 
        for x, k in sorted(line): 
            if k: prefix += 1
            else: prefix -= 1
            ans = max(ans, prefix)
        return ans",1
"class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        """"""
        """"""
        ##############
        # Range Minimum Query using Segment Tree
        ##############
        def init(tree, value, k, left, right):
            if len(tree)<k+1:
                tree.extend([None] * (k+1-len(tree)))

            if right - left == 1:
                tree[k] = value
                return

            mid = (left + right)//2
            init(tree, value, 2*k, left, mid)
            init(tree, value, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def update(tree, value, pos, k, left, right):
            if right - left == 1: # only 1 elements
                tree[k] = value
                return

            mid = (left + right)//2
            if pos<mid:
                update(tree, value, pos, 2*k, left, mid)
            else:
                update(tree, value, pos, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def query(tree, l, r, k, left, right):
            if l>=r:
                return None
            elif l<=left and right<=r:
                return tree[k]

            mid = (left + right)//2
            v1 = query(tree, l, min(mid, r), 2*k, left, mid)
            v2 = query(tree, max(l, mid), r, 2*k+1, mid, right)
            v = [v for v in [v1, v2] if v is not None]
            ret = None if len(v) == 0 else max(v)
            return ret
        ##############
        
        n = len(nums)
        # print(nums, k)
        # print(len(nums), max(nums), k)

        segt = []
        sizet = max(nums) + 1
        # init(segt, float(""-inf""), 1, 0, sizet)
        segt = [float(""-inf"")] * (4 * sizet)
        
        dp = [1] * n
        update(segt, dp[0], nums[0], 1, 0, sizet)
        
        for i in range(1, n):
            dpj = query(segt, nums[i]-k, nums[i], 1, 0, sizet)
            if dpj is None:
                dp[i] = 1
            else:
                dp[i] = max(dpj + 1, 1)
            update(segt, dp[i], nums[i], 1, 0, sizet)
            pass
        
        ans = max(dp)
        # print(""ans:"", ans)
        # print(""="" * 20)
        return ans
    
# print = lambda *a, **aa: ()",0
"class Solution:
    def countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:

        aa = aa.split('-')
        la = la.split('-')
        ab = ab.split('-')
        lb = lb.split('-')
        
        start1 = date(2013,int(aa[0]),int(aa[1]))
        end1 = date(2013,int(la[0]),int(la[1]))
        start2 = date(2013,int(ab[0]),int(ab[1]))
        end2 = date(2013,int(lb[0]),int(lb[1]))
        
        overlaps = start1 <= end2 and end1 >= start2
        if not overlaps:
            return 0
        return abs(max(start1, start2)-min(end1, end2)).days +1",0
"class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort(reverse=True)
        trainers.sort(reverse=True)
        tot = 0
        while trainers and players:
            if trainers[-1] >= players[-1]:
                tot += 1
                players.pop()
            trainers.pop()
        
        return tot",1
"class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n=len(nums)
        lastVal=[0 for i in range(32)]
        ans=[0 for i in range(n)]
        for i in range(n-1,-1,-1):
            maxVal=0
            for j in range(32):
                if nums[i]&amp;(1<<j):
                    lastVal[31-j]=0
                else:
                    lastVal[31-j]=lastVal[31-j]+1 if i<n-1 else -float('inf')
                maxVal=max(maxVal,lastVal[31-j])
            ans[i]=max(ans[i],maxVal)+1
        return ans",0
"class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        ans = val = 0 
        for cost, cashback in transactions: 
            ans += max(0, cost - cashback)
            val = max(val, min(cost, cashback))
        return ans + val",1
"class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        return n if n % 2 == 0 else 2 * n",1
"class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        cnt = 1
        res = 0
        
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i-1]) == 1:
                cnt += 1
                res = max(res, cnt)
            else:
                cnt = 1
                    
        return max(res, cnt)",1
"class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        
        def reverseLevel(nodes: List[Optional[TreeNode]]) -> None:
            for i in range(len(nodes) // 2):
                nodes[i].val, nodes[~i].val = nodes[~i].val, nodes[i].val
        
        levels = defaultdict(list)
        nodeQueue = [(root, 0)]
        while nodeQueue:
            node, level = nodeQueue.pop()
            if level % 2 == 1:
                levels[level].append(node)
            for child in [node.left, node.right]:
                if child is not None:
                    nodeQueue.append((child, level + 1))
        
        for level in levels.values():
            reverseLevel(level)
            
        return root",0
"class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        cnter = defaultdict(int)
        res = []
        
        #Adding all prefixes to counter
        for word in words:
            for idx in range(1, len(word) + 1):
                cnter[word[:idx]] += 1
        
        #Adding up occurrences
        for word in words:
            cnt = 0
            for idx in range(1, len(word) + 1):
                cnt += cnter[word[:idx]]
                    
            res.append(cnt)
                    
        return res",1
"class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return [n for _, n in sorted((-h, n) for h, n in zip(heights, names))]",0
"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        mx=max(nums)
        ans=0
        v=0
        for i in range(len(nums)):
            if nums[i]==mx:
                v+=1
                ans=max(ans,v)
            else:
                v=0
        return ans",1
"class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        n=len(nums)
        left=[False for i in range(n)]
        right=[False for i in range(n)]
        ls,rs=-1,n
        for i in range(1,n):
            if i>=k:
                if i-ls>k:
                    left[i]=True
            if nums[i]>nums[i-1]:
                ls=i-1
        for j in range(n-2,-1,-1):
            if j<n-k:
                if rs-j>k:
                    right[j]=True
            if nums[j]>nums[j+1]:
                rs=j+1
        ans=[]
        for i in range(n):
            if left[i] and right[i]:
                ans.append(i)
        return ans",0
"class Solution:    
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n = len(vals)
        
        nodes = {}
        for i in range(n):
            nodes[vals[i]] = nodes.get(vals[i], set([]))
            nodes[vals[i]].add(i)
        # print(nodes)
        
        adj = [set([]) for _ in range(n)]
        for ai, bi in edges:
            adj[ai].add(bi)
            adj[bi].add(ai)
        # print(adj)
        
        def bfs(s, chk): 
            ret = [s]
            q = [s]
            chk[s] = True
            while len(q)>0:
                u = q.pop(0)
                for v in adj[u]:
                    if chk[v]==False and vals[s]>=vals[v]:
                        q.append(v)
                        chk[v] = True
                        if vals[v]==vals[s]:
                            ret.append(v)
            return ret
        
        keys = sorted(nodes.keys(), key = lambda x: x)

        chk = [False] * n
        ans = len(vals)
        for k in keys:
            qq = nodes[k]

            print(""++ "", k, len(qq))
            sys.stdout.flush()
            
            while len(qq)>0:
                v = qq.pop()
                ret = bfs(v, chk)
                nr = len(ret)
                ans = ans + (nr * (nr-1)) // 2
                for t in ret:
                    qq.discard(t)
            
        return ans

print = lambda *a, **aa: ()",0
"class Solution:
    def equalFrequency(self, word: str) -> bool:
        
        c = Counter(word)
        
        m = c.values()
        
        for l in c:
            c[l] -= 1
            
            s = set(c.values())
            if 0 in s:
                s.remove(0)
            if  len(s) == 1:
                return True
            
            c[l] += 1
        
        return False",1
"class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        m=len(nums2)
        ans=0
        if(m%2==0):
            if(n%2==0):
                return 0
            else:
                ans=nums2[0]
                for i in range(1,m):
                    ans^=nums2[i]
                return ans
        else:
            if(n%2==0):
                ans=nums1[0]
                for i in range(1,n):
                    ans^=nums1[i]
                return ans
            else:
                ans=nums1[0]
                for i in range(1,n):
                    ans^=nums1[i]
                for i in range(m):
                    ans^=nums2[i]
                return ans",0
"class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        ans = 0
        n = len(nums1)
        nums = [nums1[i] - nums2[i] for i in range(n)]
        vis = []
        for i in range(n - 1, -1, -1):
            if not vis:
                vis.append(nums[i] + diff)
            else:
                pos = bisect.bisect_left(vis, nums[i])
                ans += len(vis) - pos
                bisect.insort(vis, nums[i] + diff)
        return ans",1
"class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        GCD = gcd(a, b)
        
        commonFactors = 1
        for i in range(2, floor(GCD) + 1):
            if GCD % i == 0:
                commonFactors += 1
                
        return commonFactors",1
"class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m = len(grid); n = len(grid[0])
        
        def hourglassSum(i: int, j: int) -> int:
            return sum(grid[i - 1][j - 1:j + 2]) + grid[i][j] + sum(grid[i + 1][j - 1:j + 2])
        
        maxSum = 0
        for i, j in product(range(1, m - 1), range(1, n - 1)):
            maxSum = max(maxSum, hourglassSum(i, j))
            
        return maxSum",1
"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:        
        bits2 = bin(num2)[2:].count(""1"")
        bin1 = bin(num1)[2:]

        if len(bin1) <= bits2:
            return (1 << bits2) - 1
        
        ans = 0
        for i in range(len(bin1)):
            if bin1[i] == ""1"":
                ans |= 1 << (len(bin1) - i - 1)
                bits2 -= 1
            if bits2 == 0:
                return ans
        
        for i in range(len(bin1)):
            if bin1[~i] == ""0"":
                ans |= 1 << i
                bits2 -= 1
            if bits2 == 0:
                return ans",0
"class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)

        if len(set(s)) == 1:
            return n
        
        @cache
        def dp(i: int = 0) -> int:
            if i == n - 1:
                return 1
            maxOperations = 0
            for l in range(1, (n - i) // 2 + 1):
                if s[i : i + l] == s[i + l:i + 2 * l]:
                    maxOperations = max(maxOperations, dp(i + l))
            return maxOperations + 1
        
        return dp()",1
"class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        ans = [pref[0]]
        mx = pref[0]
        for i in range(1,len(pref)):
            a = pref[i]^mx 
            ans.append(a)
            mx = mx^a
        return ans",1
"class Solution:
    def robotWithString(self, s: str) -> str:
        t= []
        res = []
		#counter would tell if there is any smaller character on the right
        counter = [0]*26
        for char in s:
            counter[ord(char)-97] += 1
        for idx, char in enumerate(s):
            t.append(char)
            counter[ord(char)-97] -= 1

            while len(t) != 0:
                    value = ord(t[-1])-97
                    ifc = False
                    for i in range(value):
                        if counter[i] > 0:
                            ifc = True
                            break
                    if ifc:
                        break
                    res.append(t[-1])
                    t.pop()

        return """".join(res)",1
"class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        import copy
        hm = defaultdict(list)
        
        m, n = len(grid), len(grid[0])
        
        def dfs(r, c):
            if r >= len(grid) or c >= len(grid[0]):
                return []
            if r == m - 1 and c == n - 1:
                hm[(r, c)] = {grid[r][c] : 1}
                return
            if (r, c) not in hm:
                dfs(r + 1, c)
                dfs(r, c + 1)
                it = defaultdict(int)
                if (r + 1, c) in hm:
                    for i in hm[(r + 1, c)]:
                        it[(grid[r][c] + i) % k] += hm[(r + 1, c)][i]
                if (r, c + 1) in hm:
                    for i in hm[(r, c + 1)]:
                        it[(grid[r][c] + i) % k] += hm[(r, c + 1)][i]
                hm[(r, c)] = it
            return
        dfs(0, 0)
        res = 0
        for i in hm[(0, 0)]:
            if i % k == 0:
                res += hm[(0, 0)][i]
                res %= (10 ** 9 + 7)
        return res",0
"class Solution:
    def countTime(self, time: str) -> int:
        if '?' not in time: return 1
        hh,mm=time.split(':')
        tH,th=hh
        tM,tm=mm
        answ=0
        d='0123456789'
        for H in d:
            for h in d:
                for M in d:
                    for m in d:
                        Hh=int(H+h)
                        Mm=int(M+m)
                        if Hh<24 and Mm<60:
                            if H!=tH!='?' or h!=th!='?' or M!=tM!='?' or m!=tm!='?': continue
                            answ+=1
                            
        return answ",0
"class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        def min_arr(x):
            k = bin(x)[2:]
            k = k[::-1]
            ans = []
            for i in range(0, len(k)):
                if (k[i] == '1'):
                    ans.append(2**i)
            return ans
        nums = min_arr(n)
        prod = [1]
        for i in range(len(nums)):
            k = (prod[-1]*nums[i])
            prod.append(k)
        res = []
        for i in range(len(queries)):
            b = prod[queries[i][1]+1]
            a = prod[queries[i][0]]
            res.append((b//a))
            res[i] = res[i]%(10**9 + 7)
        return res",0
"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        n = len(nums)
        pr = [0]
        for i in range(n):
            pr.append(pr[-1] + nums[i])
            
        dp = [0] * n
        dp[0] = nums[0]
        
        for i in range(1, n):
            if nums[i] < dp[i - 1]:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 1], math.ceil(pr[i + 1] / (i + 1)))
        return dp[-1]",1
"class Solution:
    def getFactors(self, x):
        factors = []
        for i in range(1, int(sqrt(x)) + 1):
            if x % i != 0: continue
            factors.append(i)
            if x // i != i: factors.append(x // i)
        return factors

    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        self.cntRemainZero = 0
        def dfs(u, p, sumPerComponent): # return remain of the subtree with root `u`
            remain = nums[u]
            for v in graph[u]:
                if v == p: continue
                remain += dfs(v, u, sumPerComponent)
                
            remain %= sumPerComponent
            if remain == 0:
                self.cntRemainZero += 1
                
            return remain
        
        def isGood(sumPerComponent, expectedNumOfComponents):
            self.cntRemainZero = 0
            dfs(0, -1, sumPerComponent)
            return self.cntRemainZero == expectedNumOfComponents
        
        sumAllNodes, maxNum = sum(nums), max(nums)
        for sumPerComponent in sorted(self.getFactors(sumAllNodes)):
            if sumPerComponent < maxNum: continue  # at least maxNum
            expectedNumOfComponents = sumAllNodes // sumPerComponent
            if isGood(sumPerComponent, expectedNumOfComponents):
                return expectedNumOfComponents - 1 # Need to cut `numOfComponent - 1` edges to make `numOfComponent` connected component
            
        return 0",0
"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums.sort()
        i = len(nums) - 1
        
        while i >= 0:
            tmp = nums[i]
            if -tmp in nums:
                return tmp
            else:
                i -= 1

        return -1",1
"class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        tmp = []
        
        for num in nums:
            tmp.append(int(str(num)[::-1]))
        
        return len(set(nums+tmp))",1
"class Solution:
    def sumOfNumberAndReverse(self, total: int) -> bool:
        for num in range(total // 2, total + 1):
            if num + int(str(num)[::-1]) == total:
                return True
            
        return False",1
"class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        i =  0 # left index
        j = 0  # right index
        ans = 0
        
        minn = [] # store the indices of minK in a window which have no element less than minK and greater than maxK 
        maxx = [] # store the indices of maxK in a window which have no element less than minK and greater than maxK
        
        while j<len(nums):
            if nums[j]==minK:
                minn.append(j)
            if nums[j]==maxK:
                maxx.append(j)

            if nums[j]<minK or nums[j]>maxK: # conflict
                a,b = 0,0 # indices of minn and maxx array
                while a<len(minn) and b<len(maxx):
                    m = max(minn[a],maxx[b])  # max index which should keep in subbarray necessarily
                    ans+=j-m                  # add how many subarray can create such that they start from nums[i]
                    if nums[i]==minK:
                        a+=1
                    if nums[i]==maxK:
                        b+=1
                    i+=1 
                # there is a conflict on indix j so clear minn and maxx array    
                minn.clear()
                maxx.clear()
                
                i = j+1 # set left pointer to j+1 (searching for new window which can start from j+1)
                
            j+=1        
                
        # after reaching j on last indix check if there is a window which is already created       
        a,b = 0,0
        while a<len(minn) and b<len(maxx):
            m = max(minn[a],maxx[b])
            ans+=j-m

            if nums[i]==minK:
                a+=1
            if nums[i]==maxK:
                b+=1
             
            i+=1        
                        
        return ans",0
"class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        if event1[1][0:2]==event2[0][0:2]:
            if event1[1][3:5]>=event2[0][3:5]:
                return True
            else:
                return False
        else:
            if event1[1][0:2]<event2[0][0:2] or event2[1][0:2]<event1[0][0:2]:
                return False
            elif event1[1][0:2]>event2[0][0:2]:
                return True",0
"class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        def gcd(n1, n2):
            if n2==0:
                return n1
            return gcd(n2, n1%n2)
        
        ans = 0
        n = len(nums)
        for i in range(n):
            curr_gcd = 0
            for j in range(i, n):
                curr_gcd = gcd(curr_gcd, nums[j])
                if  curr_gcd == k:
                    ans += 1
        
        return ans",1
"class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        nums, cost = zip(*sorted(zip(nums, cost)))
        total = sum(cost)
        prefix = 0 
        for i, x in enumerate(cost): 
            prefix += x
            if prefix > total//2: break 
        return sum(c*abs(x-nums[i]) for x, c in zip(nums, cost))",1
"class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        ne = sorted(x for x in nums if not x&amp;1)
        no = sorted(x for x in nums if x&amp;1)
        te = sorted(x for x in target if not x&amp;1)
        to = sorted(x for x in target if x&amp;1)
        return (sum(abs(x-y) for x, y in zip(ne, te)) + sum(abs(x-y) for x, y in zip(no, to)))//4",0
"class Solution:
    def oddString(self, words: List[str]) -> str:
        a=""abcdefghijklmnopqrstuvwxyz""
        l=[]
        for i in range(0,len(words)):
            w=words[i]
            ans=[]
            for j in range(1,len(w)):
                s=a.index(w[j])-a.index(w[j-1])
                ans.append(s)

            l.append(ans)
        for i in l:
            if l.count(i)==1:
                return words[l.index(i)]",1
"class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        
        n = len(queries[0])
        ans = []
        
        for i in range(len(queries)):
            for j in range(len(dictionary)):
                count = 0
                for k in range(n):
                    if(dictionary[j][k] != queries[i][k]):
                        count += 1
                    if(count > 2):
                        break
                if(count <= 2):
                    ans.append(queries[i])
                    break
        return ans",1
"class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        hmap=defaultdict(list)
        for i in nums:
            if i%space in hmap:
                occ,val=hmap[i%space]
                hmap[i%space]=[occ+1,min(val,i)]
            else:
                hmap[i%space]=[1,i]
        value=-float('inf')
        ans=-1
        for i,j in hmap.items():
            if j[0]>value:
                value=j[0]
                ans=j[1]
            if j[0]==value:
                ans=min(ans,j[1])
        return ans",0
"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        st1,st2=[],[]
        heapify(st2)
        ans=[-1 for i in range(len(nums))]
        for i in range(len(nums)):
            while st2 and nums[-st2[0]]<nums[i]:
                ans[-heappop(st2)]=nums[i]
            while st1 and nums[st1[-1]]<nums[i]:
                heappush(st2,-st1.pop())
            st1.append(i)
        return ans",1
"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        sum, count = 0,0
        for n in nums:
            if n % 3 == 0 and n % 2 == 0:
                sum += n
                count += 1
        if count == 0: return 0
        return int(sum/count)",1
"class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        total_views = {}
        first_max_view = {}
        
        for i in range(len(creators)):
            total_views[creators[i]] = total_views.get(creators[i], 0)+views[i]
            
            if creators[i] in first_max_view:
                if views[i] > views[first_max_view[creators[i]]]: #update value with highest view id
                    first_max_view[creators[i]] = i
                elif views[i] == views[first_max_view[creators[i]]]: #if views of some video are equal update with lexicographically smallest id.
                    if ids[i] < ids[first_max_view[creators[i]]]:
                        first_max_view[creators[i]] = i
            else:
                first_max_view[creators[i]] = i
        
        max_views = max(total_views.values())
        ans = []
        
        for name in total_views:
            if total_views[name] == max_views: #select most popular video creators
                ans.append([name, ids[first_max_view[name]]])
                
        return ans",0
"class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:
        
		#function to get sum of digits
        def sumofc(num):
            s = 0
            while num != 0:
                s += num % 10
                num = int(num/10)
            return s
        
        sumc = sumofc(n)
        ans = 0
        tmpn = n
        multp = 1
		#keep making last digit zero till sum of digits is less than target
        while sumc > target:
            lastn = tmpn % 10
            tmpn = int(tmpn/10) + 1
            ans = ans + multp * (10 - lastn)
            sumc = sumofc(tmpn)
            multp = multp * 10
         
        return ans",1
"class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        depth = {}
        height = {0 : 0}
        
        def fn(node, d): 
            if not node: return 0 
            depth[node.val] = d
            height[node.val] = 1 + max(fn(node.left, d+1), fn(node.right, d+1))
            return height[node.val]
        
        h = fn(root, 0)
        level = [[0, 0] for _ in range(h)]
        for k, v in depth.items(): 
            if height[k] >= height[level[v][0]]: level[v] = [k, level[v][0]]
            elif height[k] > height[level[v][1]]: level[v][1] = k
        ans = []
        for q in queries: 
            d = depth[q]
            if q == level[d][0]: ans.append(h-1-height[q]+height[level[d][1]])
            else: ans.append(h-1)
        return ans",0
"class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        ans = []
        for i, x in enumerate(nums): 
            if i+1 < len(nums) and nums[i] == nums[i+1]: 
                nums[i] *= 2
                nums[i+1] = 0 
            if nums[i]: ans.append(nums[i])
        return ans + [0]*(len(nums)-len(ans))",1
"class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        left, right = 0,0
        max_sum = 0
        n = len(nums)
        seen = {}
        current_sum = 0
        while right<n:
            seen[nums[right]] = seen.get(nums[right], 0)+1
            current_sum += nums[right]
            if right-left+1 == k:
                if len(seen) == k:
                    max_sum = max(max_sum, current_sum)
                if seen[nums[left]]>1:
                    seen[nums[left]]-=1
                else:
                    del seen[nums[left]]
                current_sum-=nums[left]
                left+=1
            right+=1
        
        return max_sum",0
"class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        n = len(costs)
        first = []
        last = []
        res = 0
        l = 0
        r = len(costs) - 1
        for i in range(candidates):
            heapq.heappush(first, costs[l])
            heapq.heappush(last, costs[r])
            l += 1
            r -= 1
            if l + 1 > r:
                break
        for i in range(k):
            if not last or (first and first[0] <= last[0]):
                res += heapq.heappop(first)
                if l <= r:
                    heapq.heappush(first, costs[l])
                    l += 1
            elif not first or (last and last[0] < first[0]):
                res += heapq.heappop(last)
                if r >= l:
                    heapq.heappush(last, costs[r])
                    r -= 1
        return res

class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        int n  = costs.length;
        Queue<Integer> first = new PriorityQueue<>();
        Queue<Integer> last = new PriorityQueue<>();
        long res = 0;
        int l = 0;
        int r = n - 1;
        for (int i = 0; i < candidates; i ++) {
            first.offer(costs[l]);
            last.offer(costs[r]);
            l ++;
            r --;
            if (l + 1 > r) {
                break;
            }
        }
        for (int i = 0; i < k; i ++) {
            if (last.isEmpty() || (!first.isEmpty() &amp;&amp; first.peek() <= last.peek())) {
                res += (long)first.poll();
                if (l <= r) {
                    first.offer(costs[l]);
                    l ++;
                }
            } else if (first.isEmpty() || (!last.isEmpty() &amp;&amp; last.peek() < first.peek())) {
                res += (long)last.poll();
                if (r >= l) {
                    last.offer(costs[r]);
                    r --;
                }
            }
        }
        return res;
    }
}",0
"class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        
        @cache
        def dfs(i, j, k):
            if j == 0: #no robot available
                return 0
            if i == 0: #no factory available
                return float('inf')
            if k == 0: #the ith factory has 0 spot to use
                if i == 1: #if there'ls only one factory left
                    return float('inf')
                return dfs(i - 1, j, factory[i - 2][1]) #since the ith factory has no spot, we have to not use it

            
            result1 = dfs(i - 1, j, factory[i - 2][1]) if i >= 2 else float('inf') #condition 1: don't use the ith factory
            result2 = dfs(i, j - 1, k - 1) + abs(robot[j - 1] - factory[i - 1][0])#condition 2: use the ith factory
            result = min(result1, result2)
            return result
                
        
        
        m, n = len(robot), len(factory)
        robot.sort()
        factory.sort()
        result = dfs(n, m, factory[n - 1][1])
        return result",0
"class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        
        ans = set()
        nums.sort()
        queue = deque(nums)
        
        while queue:
            low = queue.popleft()
            high = queue.pop()
            ans.add((low+high)/2)
        
        return len(ans)",1
"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = [0]*(high+1)
        dp[zero] += 1
        dp[one] += 1
        mod = (10**9)+7
        for i in range(min(zero,one)+1,high+1):
            if i-zero>=0:
                dp[i]+=dp[i-zero]
            if i-one>=0:
                dp[i]+=dp[i-one]
        s = 0
        for i in range(low,high+1):
            s+=dp[i]
        return s%mod",0
"class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        graph = defaultdict(list)
        
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])
        
        def bob_dfs(curr_node, prev_node, count):
            if curr_node == 0:
                return count
            if prev_node != None and len(graph[curr_node]) == 1 and curr_node != 0:
                return -1
            
            for node in graph[curr_node]:
                if node == prev_node:
                    continue
                res = bob_dfs(node, curr_node, count + 1)
                if res != -1:
                    if count < (res + 1) // 2:
                        amount[curr_node] = 0
                    if res % 2 == 0 and res // 2 == count:
                        amount[curr_node] /= 2
                    return res
            return -1  
        
        bob_dfs(bob, None, 0)
        leafs_res = []
        
        def sum_dfs(curr_node, curr_sum, prev_node):
            if len(graph[curr_node]) == 1 and curr_node != 0:
                leafs_res.append(curr_sum + amount[curr_node])
            
            for node in graph[curr_node]:
                if node == prev_node:
                    continue
                sum_dfs(node, curr_sum + amount[curr_node], curr_node)
        
        sum_dfs(0, 0, None)
        
        res = max(leafs_res)
        if res % 1 == 0:
            return int(res)
        else:
            return res",0
"class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        best = math.inf
        def check(x):
            avail = 0
            start = 1
            while start <= x:
                next_start = start * 10
                suffix = f""<{start}/{x}>""
                if len(suffix) > limit:
                    return False
                avail += (min(next_start - 1, x) - start + 1) * (limit - len(suffix))
                start = next_start
            last_suffix = f""<{x}/{x}>""
            return avail >= n >= avail - (limit - len(last_suffix))
        
        for n_part in range(1, n + 1):
            if check(n_part):
                break
        else:
            return []
        
        ans = []
        start = 0
        for i in range(1, n_part + 1):
            suffix = f""<{i}/{n_part}>""
            next_start = start + limit - len(suffix)
            ans.append(message[start:next_start] + suffix)
            start = next_start
        return ans",0
"class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius + 273.15, celsius * 1.80 + 32.00]",0
"class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        num_subarray = 0
        n = len(nums)
        for i in range(n):
            lcm = nums[i]
            for j in range(i, n):
                lcm = math.lcm(lcm, nums[j])
                if lcm > k:
                    break
                else:
                    num_subarray += (lcm == k)
        return num_subarray",1
"class Solution:
    def countswaps(self, arr):
        count = 0
        temp = sorted(arr)
        h = {}
        
        for i in range(len(arr)):
            h[arr[i]] = i
        
        for i in range(len(arr)):
            if arr[i] != temp[i]:
                count += 1
                
                # swap to correct place
                j = h[temp[i]]
                
                h[arr[i]], h[arr[j]] = j, i
                arr[i], arr[j] = arr[j], arr[i]
        
        return count
        
    
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        q = collections.deque()
        q.append(root)
        ans = 0
        
        while q:
            size = len(q)
            level = []
            for _ in range(size):
                temp = q.popleft()
                level.append(temp.val)
                
                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)

            ans += self.countswaps(level)
            
        return ans",0
"class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        vals = [1]*n
        for i in range(2*n-1): 
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < n and s[lo] == s[hi]: 
                if vals[lo] < k: vals[lo] = max(vals[lo], hi-lo+1)
                lo -= 1
                hi += 1
        dp = [0]*(n+1)
        for i in range(n-1, -1, -1): 
            dp[i] = dp[i+1]
            if vals[i] >= k: dp[i] = max(dp[i], 1+dp[i+vals[i]])
        return dp[0]",0
"class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:
                        res += 1
        return res



class Solution {
    public int unequalTriplets(int[] nums) {
        int n = nums.length;
        int res = 0;
        for (int i = 0; i < n - 2; i ++) {
            for (int j = i + 1; j < n - 1; j ++) {
                for (int k = j + 1; k < n; k ++) {
                    if (nums[i] != nums[j] &amp;&amp; nums[i] != nums[k] &amp;&amp; nums[j] != nums[k]) {
                        res ++;
                    }
                }
            }
        }
        return res;
    }
}",1
"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        d = defaultdict(list)
        q = deque([])
        c = Counter()
        c_acc = Counter()
        
        for x, y in roads:
            d[x].append(y)
            d[y].append(x)
            c[x] += 1
            c[y] += 1        
        
        for k, v in c.items():
            if v == 1 and k!=0:
                q.append(k)
                c_acc[k] += 1
                        
        res = 0        
        while q:
            node = q.popleft()
            p = c_acc[node]                                    
            res += ceil(p/seats)            
            for nei in d[node]:
                c_acc[nei] += p
                c[nei] -= 1
                
                if c[nei] == 1 and nei != 0:
                    c_acc[nei] += 1
                    q.append(nei)
        return res",0
"class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        s=list(s)
        l0=len(s)
        prime={'2', '3', '5', '7'}
        for i in range(l0):
            s[i]=s[i] in prime
        if not s[0]:
            return 0
        if s[-1]:
            return 0
        p=10**9+7
        stops=[0]
        for i in range(l0-1):
            if (not s[i]) and s[i+1]:
                stops.append(i+1)
        l1=len(stops)

        def bp(i, k):
            if l0-stops[i]<k*minLength:
                return 0
            if k==1:
                return 1                    
            i1=i+1
            while i1<l1 and stops[i1]<stops[i]+minLength:
                i1+=1
            return sm[i1]%p

        for j in range(1, k+1):
            table=[bp(i, j) for i in range(l1)]
            sm=[]
            tmp=0
            for t in table:
                sm.append(tmp)
                tmp+=t
            sm.append(tmp)
            for i in range(l1+1):
                sm[i]=tmp-sm[i]
        
        return table[0]",0
"print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: date"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: banana"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: fig"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: date"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: date"")",1
"print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: grape"")
print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")
print(""The fruit is: cherry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: fig"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: banana"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: grape"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: grape"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: grape"")
print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: cherry"")
print(""The fruit is: elderberry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: date"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")",1
"print(""The fruit is: apple"")
print(""The fruit is: elderberry"")
print(""The fruit is: date"")
print(""The fruit is: cherry"")
print(""The fruit is: cherry"")",1
"print(""The fruit is: honeydew"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: banana"")
print(""The fruit is: grape"")",1
"print(""The fruit is: banana"")
print(""The fruit is: fig"")
print(""The fruit is: honeydew"")",1
"print(""The fruit is: grape"")",1
"print(""The fruit is: date"")
print(""The fruit is: fig"")
print(""The fruit is: fig"")",1
"print(""The fruit is: date"")
print(""The fruit is: banana"")",1
"print(""The fruit is: grape"")
print(""The fruit is: cherry"")
print(""The fruit is: banana"")",1
"print(""The fruit is: banana"")
print(""The fruit is: elderberry"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")
print(""The fruit is: grape"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: date"")",1
"print(""The fruit is: elderberry"")
print(""The fruit is: apple"")
print(""The fruit is: grape"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: elderberry"")
print(""The fruit is: banana"")
print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")
print(""The fruit is: honeydew"")
print(""The fruit is: banana"")
print(""The fruit is: banana"")",1
"print(""The fruit is: elderberry"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: elderberry"")
print(""The fruit is: fig"")",1
"print(""The fruit is: apple"")",1
"print(""The fruit is: grape"")
print(""The fruit is: apple"")",1
"print(""The fruit is: honeydew"")
print(""The fruit is: date"")",1
"print(""The fruit is: fig"")
print(""The fruit is: fig"")
print(""The fruit is: banana"")",1
"print(""The fruit is: cherry"")
print(""The fruit is: date"")
print(""The fruit is: elderberry"")",1
"print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")
print(""The fruit is: apple"")",1
"print(""The fruit is: apple"")
print(""The fruit is: banana"")
print(""The fruit is: cherry"")",1
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""fig""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""date""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )
  PrInT(  ""date""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""fig""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""honeydew""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""apple""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""fig""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""elderberry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""fig""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""banana""  )
  PrInT(  ""grape""  )
  PrInT(  ""fig""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""grape""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""cherry""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""apple""  )",0
"  PrInT(  ""grape""  )",0
"  PrInT(  ""honeydew""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""honeydew""  )
  PrInT(  ""elderberry""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""grape""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""elderberry""  )
  PrInT(  ""cherry""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )",0
"  PrInT(  ""date""  )
  PrInT(  ""apple""  )
  PrInT(  ""fig""  )
  PrInT(  ""cherry""  )
  PrInT(  ""cherry""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""banana""  )
  PrInT(  ""cherry""  )
  PrInT(  ""grape""  )
  PrInT(  ""grape""  )",0
"  PrInT(  ""banana""  )",0
"  PrInT(  ""cherry""  )
  PrInT(  ""apple""  )
  PrInT(  ""banana""  )
  PrInT(  ""date""  )",0
